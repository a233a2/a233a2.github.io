[{"content":"7 1.ci： 这个目录通常包含与持续集成（CI）相关的配置文件，例如Jenkins、Travis CI或GitHub Actions的配置。它负责自动化编译、测试、部署等任务。\n2.clusterfuzzlite： 用于与ClusterFuzzLite相关的配置文件，这是一种自动化模糊测试框架，帮助发现代码中的安全漏洞。\n3.devcontainer： 包含VSCode开发容器的配置，用于在隔离的容器环境中开发PX4代码。方便开发人员在一致的开发环境中工作。\n4.github： 包含GitHub的配置文件，如GitHub Actions、Issue模板和Pull Request模板，用于自动化流程和优化项目管理。\n5.vscode： 包含Visual Studio Code的配置文件，定义了编译、调试和代码检查的工作流，以便开发人员在VSCode中更方便地开发PX4代码。\n6.Documentation： 包含项目的文档文件，帮助开发者和用户了解如何使用、配置和开发PX4飞控系统。通常包括用户指南、API文档、教程等。\n7.ROMFS： ROMFS是只读文件系统，通常用于存储PX4固件中的静态数据，如参数文件、启动脚本等。\n8.Tools： 这个目录包含各种开发工具和脚本，常用于构建、测试、仿真和部署PX4代码。比如，可能包含用于自动化工具链配置的脚本。\n9.boards： 包含与各种硬件平台（如飞控板、传感器等）相关的定义和配置文件。每种硬件的特定启动配置和硬件抽象层都位于该目录中。\n10.cmake： 包含CMake构建系统的配置文件，用于定义如何编译PX4代码。CMake是一个跨平台的构建工具，管理依赖项和生成编译文件。\n11.integrationtests/python_src/px4_it： 包含集成测试相关的Python脚本，主要用于自动化测试PX4的不同模块和功能，以确保系统的稳定性和正确性。\n12.launch： 包含与ROS或仿真环境中的启动文件相关的配置，通常是用于启动PX4在仿真器或真实硬件上的配置文件。\n13.msg： 包含与PX4通信协议（如MAVLink）相关的消息定义文件，用于定义飞控系统与外部系统（如地面站、传感器等）之间的消息格式。\n14.platforms： 包含与不同硬件平台相关的底层代码和配置，如NuttX的初始化文件、硬件抽象层等。\n15.posix-configs： 包含POSIX系统（如Linux）上的配置文件，通常用于定义在仿真环境中运行PX4的配置。\n//16.src： 源代码目录，包含PX4的主要功能模块的实现代码，如飞行控制算法、传感器处理、姿态估计等。\n17.srv： 服务定义文件，通常用于ROS系统中的服务（services），用于系统内不同节点之间的通信和请求/响应模式的交互。\n18.test： 包含测试代码和测试框架，用于对PX4功能进行单元测试和集成测试，确保各个模块功能的正确性和健壮性。\n19.test_data： 包含测试所需的测试数据或测试脚本，用于集成测试和回归测试，以验证代码改动是否影响系统行为。\n20.validation： 包含验证代码、数据或测试的文件，确保PX4的各个部分在特定条件下的表现符合预期。\n21.clang-tidy： Clang-Tidy是一个C++代码分析工具，这个文件包含其配置，用于代码的静态分析，发现潜在的错误和优化点。\n22.editorconfig： EditorConfig配置文件，用于定义代码格式的规则，如缩进、换行符、字符编码等，确保不同开发者之间代码风格的一致性。\n23.gitattributes、.gitignore： 用于Git的配置文件。.gitattributes用于定义文件的特定处理方式，.gitignore则列出需要被Git忽略的文件和目录。\n24.CMakeLists.txt： 这是CMake项目的核心配置文件，定义了如何编译整个PX4项目，包括源文件的路径、依赖项、编译选项等。\n25.CODE_OF_CONDUCT.md： 项目的行为准则，规定了开发者在贡献代码和参与社区时需要遵守的行为规范。\n26.CONTRIBUTING.md： 为开发者提供的贡献指南，解释了如何参与项目开发、提交代码和报告问题等流程。\n27.CTestConfig.cmake： CMake的测试配置文件，定义了如何运行项目的测试，并收集测试结果。\n28.Jenkinsfile： Jenkins持续集成系统的配置文件，定义了在Jenkins上自动化构建和测试的流水线。\n29.Kconfig： 用于配置系统的文件，通常用于嵌入式系统中，定义了各个硬件模块或软件模块的配置选项。\n30.LICENSE： 项目的开源许可证文件，说明了PX4的使用和分发权限。\n31.Makefile： 传统的编译配置文件，定义了如何使用Make工具构建项目。对于不使用CMake的部分或平台，Makefile提供了另一种编译方式。\n32.README.md： 项目的概述和基本介绍，通常包括如何编译、安装和使用PX4飞控系统的基本信息。\n33.SECURITY.md： 有关安全漏洞报告和处理流程的文档，指导开发者如何报告和解决项目中的安全问题。\n34.package.xml： 通常用于ROS包，定义了包的元数据，如依赖项、版本号和维护者信息。\nSRC文件解析 src/modules/mc_att_control： 这个目录包含与多旋翼无人机姿态控制相关的代码。姿态控制的核心就是通过PID控制器来调节无人机的滚转、俯仰和偏航角的稳定性。 mc_att_control_main.cpp 是姿态控制的主要代码文件。\nsrc/modules/mc_pos_control： 这个目录包含与多旋翼无人机位置控制相关的代码。PID控制器在此负责无人机的三维位置和高度控制。 mc_pos_control_main.cpp 是位置控制的核心实现文件，包含位置控制的PID逻辑。\nsrc/lib/controllib： 这个目录下包含PX4的控制库，其中定义了PID控制器的通用实现。这里的文件用于多个模块的控制需求。 pid.cpp 是PID控制器的核心实现，定义了如何计算误差、比例项、积分项和微分项。\nsrc/modules/fw_att_control 和 src/modules/fw_pos_control： 如果你关注的是固定翼无人机的PID控制，可以查看这两个目录。它们分别负责固定翼无人机的姿态控制和位置控制。\n参数文件 (ROMFS)： PID控制器的参数通常在参数文件中定义，可以通过修改这些参数调整控制器的性能。可以在 ROMFS/px4fmu_common/init.d 目录中找到默认的参数文件，里面会定义PID控制器的增益值（如P、I、D系数）。\nNuttxRTOS 这应该是个很复杂的单片机实时系统。\nMAVLink协议 QGC地面站会通过MAVLink协议将QGC针对飞机的配置参数发送给飞控系统，而飞控系统则将这些参数存储在存储设备中。 暂时用不太上。\nQGC地面站试飞 在QGC地面站对PX4飞控进行调试试飞，开始时抖动剧烈，随着将速度环PID参数特别是D项降低后抖动变小。但是只能在高度模式稳定飞行，在自稳以及特技等模式均不稳定。 后续准备加入GPS自动飞行来测试稳定性。\n高度（Altitude）模式试飞视频 QGC地面站通信无线数传配置 数传模块使用了LQ的无线串口模块。将SH1.25-6Pin接口与XH2.54杜邦线进行连接后，使用绝缘胶布进行绝缘处理。将SH1.25-6Pin接入飞控的TELEM1口进行配置。 地面站中将TELEM1的波特率输出改为115200（LQ无线串口模块的BAUD），在QCG设置中添加一个数据连接接口。即可完成数传的配置。但是可能因为数据传输较大，距离在5m左右传输已经是极限了。\n对原有飞行模式修改与添加新的功能 1、PX4中的飞行模式主要定义文件： Commander模块（src/modules/commander）：\n主要负责飞行模式的管理和状态机控制。\ncommander.cpp：这是Commander模块的主文件，包含了飞行模式的状态机逻辑。commander_state.cpp：管理飞行模式的状态定义。\nFlight Mode Manager模块（src/modules/mc_pos_control 和 src/modules/fw_pos_control_l1）：\n多旋翼飞行器（mc_pos_control） 和 **固定翼飞行器（fw_pos_control_l1）**的飞行模式控制。\n在这些模块中，具体的飞行控制算法实现了如何根据不同的飞行模式，进行姿态、位置或速度控制。\n飞行模式的状态机逻辑位于commander.cpp文件中。它根据用户输入、飞行器状态和环境条件来决定当前飞行模式。你需要熟悉这些状态之间的切换条件以及各模式的具体功能实现。\n定义新的飞行模式： 在commander_state.h文件中，添加新的飞行模式枚举。例如，如果你要创建一个自定义的“智能悬停模式”： VEHICLE_MODE_FLAG_SMART_HOVER 实现飞行模式逻辑：\n在commander.cpp文件中，添加或修改相应的飞行模式逻辑。\n你可以参考已有的飞行模式（如POSCTL或ALTCTL）的实现方式，将自定义逻辑嵌入其中。比如，你可以根据条件判断激活智能悬停模式： if (user_input == CUSTOM_SMART_HOVER_CONDITION) { vehicle_status_s = VEHICLE_MODE_FLAG_SMART_HOVER; } 实现控制算法：\n根据自定义飞行模式的功能需求，你可能需要在姿态控制模块（mc_att_control）或位置控制模块（mc_pos_control）中添加自定义的控制算法。 可以根据飞行器当前的状态、位置、高度等数据来设计智能悬停的控制算法，使其在特定条件下表现出不同的控制行为。 测试飞行模式\n在模拟环境（如SITL）中对修改后的飞行模式进行测试。 确保飞行模式在不同情况下能够正确切换和响应用户输入。\nPixhawk 2.4.8 的接线 TELEM1/2 GPS接口的定义为 VCC TX RX TX1 RX1 GND\nI2C接口的定义为 VCC SDA SCL GND\nPX4工程的编译 git\nBootloader烧录 源文件编译与烧录 ","date":"2024-10-10T00:00:00Z","permalink":"https://a233a2.github.io/p/px4%E9%A3%9E%E8%A1%8C%E6%8E%A7%E5%88%B6%E5%99%A8%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/","title":"PX4飞行控制器开发日志"},{"content":"变频器设计 ","date":"2024-10-10T00:00:00Z","permalink":"https://a233a2.github.io/p/%E5%8F%98%E9%A2%91%E5%99%A8%E8%AE%BE%E8%AE%A1/","title":"变频器设计"},{"content":"FreeRTOS FreeRTOS在嵌入式的开发中十分的重要，本人之前对于同一时间进行多种任务的做法普遍都是设置定时器中断程序。这样做或许能解决燃眉之急，但是在大型项目中便有一些捉襟见肘，尤其是使用这种方式对于MCU的任务调度十分的不明确，显得十分的乱。故对于FreeRTOS这种MCU操作系统的应用便显得尤为重要。 官方文档：https://freertos.org/zh-cn-cmn-s/Documentation/00-Overview\nFreeRTOS核心机制 优先级调度 高优先级的准备就绪后，直接抢占CPU。\nFCFS(先来先服务)\n同优先级，按照准备就绪的先后顺序执行。\n时间片轮询\n有相同优先级的两个任务，其中一个一直没被抢占，则运行时间达到一个时间片则主动让出CPU。\nps：低优先级的任务对时间的控制较为不精确。高优先级的任务可以做到时间精确控制。\nFreeRTOS延时函数 vTaskDelay(ms);\n当前任务暂时暂停xx ms，程序进入阻塞态，其中暂时时间内可以执行其他任务。\nHAL_Delay(ms);\nCPU暂时挂起xx ms，啥也不执行。类似裸机运行时的delay。\nFreeRTOS的部署 ","date":"2024-09-18T00:00:00Z","permalink":"https://a233a2.github.io/p/freertos%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","title":"FreeRTOS学习笔记"},{"content":"ADRC课程笔记 本人对ADRC控制有着深厚的研究兴趣。在讨论研究韩京清先生的ADRC知识之前，我想先给不太专业的自己补习一些经典与现代控制理论方向的相关知识。\n前馈控制 前馈控制是一种基于对扰动的预测进行补偿的控制方法。它通过测量可能影响系统输出的扰动变量，并根据扰动变量与系统输出之间的关系，计算出所需的控制量，在扰动对系统产生影响之前就进行调节，以抵消扰动的影响。 在自动控制系统理论中学习过，由传递函数理论数学推导，前馈的引入可以完全的消除系统的扰动误差。现在这显然并不是这么的简单，这需要对系统数学模型有着十分精确的掌握。\n生理前馈系统 在生理学上，前馈控制的例子是在实际体力活动之前，自主神经系统对心跳的正常预期调节。前馈控制可以比作对已知线索的预期反应（预测编码）。心跳的反馈调节为机体提供了进一步对运动的适应性。 \u0026ndash;wiki百科\n在前馈系统中，控制变量的调整不是以目标和回授之间的误差为基础，它是以过程数学模型的知识和过程扰动的知识或测量为基础。\n所以对于数学模型的整体掌握是对系统扰动进行前馈消除的前提。\n正所谓要想系统稳得住，必须得有前馈引入。前馈控制在某些控制场合下是必须项。\n状态观测器 ","date":"2024-09-16T00:00:00Z","permalink":"https://a233a2.github.io/p/adrc%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/","title":"ADRC课程笔记"},{"content":"KiCad学习日记 导出Gerber文件-JLC打样 1 导出Gerber的设置： 从b站搬运：https://www.bilibili.com/read/cv22773523/?spm_id_from=333.976.0.0 （KiCAD设计使用立创免费打样的方法及KiCAD插件） 生成gerber文件\n生成钻孔文件\n生成的gerber文件最终结构如下：\n2 修改Gerber文件使得可在JLC打样 创建两个文件 1 2 from .give_me_free_PCB import GiveMeFreePCB # Note the relative import! GiveMeFreePCB().register() # Instantiate and register to Pcbnew 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 import pcbnew import os import shutil import zipfile import datetime # 工程目录下Gerber和钻孔文件的存放位置 path_out = \u0026#34;out\u0026#34; # 下单用的文件的位置 path_final = \u0026#34;out/final\u0026#34; # 用于检查文件是否为Gerber文件以判断是否进行替换操作 file_filter = (\u0026#39;.gbl\u0026#39;,\u0026#39;.gbs\u0026#39;,\u0026#39;.gbp\u0026#39;,\u0026#39;.gbo\u0026#39;,\u0026#39;.gm1\u0026#39;,\u0026#39;gm13\u0026#39;, \u0026#39;.gtl\u0026#39;,\u0026#39;.gts\u0026#39;,\u0026#39;.gtp\u0026#39;,\u0026#39;.gto\u0026#39;,\u0026#39;.drl\u0026#39;,\u0026#39;.G1\u0026#39;, \u0026#39;.G2\u0026#39;,\u0026#39;.gko\u0026#39;) jlc_header=\u0026#34;\u0026#34;\u0026#34;G04 Layer: BottomSilkscreenLayer* G04 EasyEDA v6.5.25, 2023-03-20 21:11:36* **********************************至少这一行要换成自己的************************************ G04 Gerber Generator version 0.2* G04 Scale: 100 percent, Rotated: No, Reflected: No * G04 Dimensions in millimeters * G04 leading zeros omitted , absolute positions ,3 integer and 6 decimal *\\n\u0026#34;\u0026#34;\u0026#34; # 两张对应表，分别根据结尾和文件名来判断该给什么生成的文件什么名称 replace_list_end = [(\u0026#39;.gbl\u0026#39;,\u0026#34;Gerber_BottomLayer.GBL\u0026#34;), (\u0026#39;.gko\u0026#39;,\u0026#34;Gerber_BoardOutlineLayer.GKO\u0026#34;), (\u0026#39;.gbp\u0026#39;,\u0026#34;Gerber_BottomPasteMaskLayer.GBP\u0026#34;), (\u0026#39;.gbo\u0026#39;,\u0026#34;Gerber_BottomSilkscreenLayer.GBO\u0026#34;), (\u0026#39;.gbs\u0026#39;,\u0026#34;Gerber_BottomSolderMaskLayer.GBS\u0026#34;), (\u0026#39;.gtl\u0026#39;,\u0026#34;Gerber_TopLayer.GTL\u0026#34;), (\u0026#39;.gtp\u0026#39;,\u0026#34;Gerber_TopPasteMaskLayer.GTP\u0026#34;), (\u0026#39;.gto\u0026#39;,\u0026#34;Gerber_TopSilkscreenLayer.GTO\u0026#34;), (\u0026#39;.gts\u0026#39;,\u0026#34;Gerber_TopSolderMaskLayer.GTS\u0026#34;), (\u0026#39;.gd1\u0026#39;,\u0026#34;Drill_Through.GD1\u0026#34;), (\u0026#39;.gm1\u0026#39;,\u0026#34;Gerber_MechanicalLayer1.GM1\u0026#34;), (\u0026#39;.gm13\u0026#39;,\u0026#34;Gerber_MechanicalLayer13.GM13\u0026#34;)] replace_list_contain = [(\u0026#39;_PCB-PTH\u0026#39;, \u0026#34;Drill_PTH_Through.DRL\u0026#34;), (\u0026#39;_PCB-NPTH\u0026#39;, \u0026#34;Drill_NPTH_Through.DRL\u0026#34;), (\u0026#39;-PTH\u0026#39;, \u0026#34;Drill_PTH_Through.DRL\u0026#34;), (\u0026#39;-NPTH\u0026#39;, \u0026#34;Drill_NPTH_Through.DRL\u0026#34;), (\u0026#39;_PCB-In1_Cu\u0026#39;, \u0026#34;Gerber_InnerLayer1.G1\u0026#34;), (\u0026#39;_PCB-In2_Cu\u0026#39;, \u0026#34;Gerber_InnerLayer2.G2\u0026#34;), (\u0026#39;_PCB-Edge_Cuts\u0026#39;, \u0026#34;Gerber_BoardOutlineLayer.GKO\u0026#34;)] def zipFolder(folder_path, output_path): \u0026#34;\u0026#34;\u0026#34; 压缩指定路径下的文件夹 :param folder_path: 要压缩的文件夹路径 :param output_path: 压缩文件的输出路径 \u0026#34;\u0026#34;\u0026#34; with zipfile.ZipFile(output_path, \u0026#34;w\u0026#34;, zipfile.ZIP_DEFLATED) as zip: for root, dirs, files in os.walk(folder_path): for file in files: file_path = os.path.join(root, file) zip.write(file_path, os.path.relpath(file_path, folder_path)) # 读取Gerber文件和钻孔文件，修改名称并给Gerber文件内容添加识别头后写入到输出文件夹 def fileTransform(filename, path_out): # 按行读取文件内容 lines = open(filename).readlines() # 检查文件类型并给新文件取好相应的名称，写入识别头和原来的文件内容 hit_flag = 0 for replace_couple in replace_list_end: if filename.endswith(replace_couple[0]): file_new = open(path_out + \u0026#39;/\u0026#39; + replace_couple[1], \u0026#39;w\u0026#39;) hit_flag = 1 break if hit_flag == 0: for replace_couple in replace_list_contain: if filename.find(replace_couple[0]) != -1: file_new = open(path_out + \u0026#39;/\u0026#39; + replace_couple[1], \u0026#39;w\u0026#39;) hit_flag = 1 break if hit_flag == 1: hit_flag = 0 file_new.write(jlc_header) for line in lines: file_new.write(line) file_new.close() def pathInit(path_out): # 检查下目录是否存在，没有就创建 folder_out = os.path.exists(path_out) if not folder_out: os.makedirs(path_out) print(\u0026#34;Folder %s created!\u0026#34; % path_out) else: print(\u0026#34;Folder \\\u0026#34;%s\\\u0026#34; already exists!\u0026#34; % path_out) # 清空目录 for files in os.listdir(path_out): path = os.path.join(path_out, files) try: shutil.rmtree(path) except OSError: os.remove(path) print(\u0026#34;Folder \\\u0026#34;%s\\\u0026#34; clean!\u0026#34; % path_out) class GiveMeFreePCB(pcbnew.ActionPlugin): def defaults(self): self.name = \u0026#34;Give me free PCB!\u0026#34; self.category = \u0026#34;A descriptive category name\u0026#34; self.description = \u0026#34;A description of the plugin\u0026#34; self.show_toolbar_button = True # Optional, defaults to False self.icon_file_name = os.path.join(os.path.dirname(__file__), \u0026#39;icon.png\u0026#39;) # Optional # 关于路径，写的是处理工程目录下out目录里的文件， def Run(self): # 获取当前工程路径 path_workdir = os.environ.get(\u0026#39;KIPRJMOD\u0026#39;) # 把工程根目录设为工作目录 os.chdir(path_workdir) path_out_abs = os.path.join(os.getcwd(), path_out) pathInit(os.path.join(path_workdir, path_final)) file_count = 0 path_files = os.listdir(os.path.join(os.getcwd(), path_out)) # 遍历out目录下的文件，识别类型并进行相应的处理 for p in path_files: if(os.path.isfile(os.path.join(path_out_abs, p))): if(p.endswith(file_filter)): print(\u0026#34;Gerber file %s found.\u0026#34; % p) fileTransform(os.path.join(path_out_abs, p), os.path.join(os.getcwd(), path_final)) file_count += 1 timestamp = datetime.datetime.now().strftime(\u0026#39;%Y%m%d%H%M%S\u0026#39;) board = pcbnew.GetBoard() project_name = os.path.splitext(os.path.basename(board.GetFileName()))[0] zipFolder(path_out_abs + \u0026#39;/\u0026#39; + \u0026#34;final\u0026#34;, path_out_abs + \u0026#39;/\u0026#39; + \u0026#34;out_\u0026#34; + project_name + \u0026#39;-\u0026#39; + timestamp + \u0026#34;.zip\u0026#34;) # 打开资源管理器 os.system(\u0026#34;explorer.exe %s\u0026#34; % path_out_abs) 对源文件进行替换，把标*的行之上换为自己的工程的。\n在Kicad的脚本控制台中输入如下：来引入脚本 任意选择其中一个地址放入两个.py文件。之后点击工具-外部插件-刷新插件。出现新的插件即表示成功，注意文件编码为UTF-8，不然插件刷新不出来 输出时候需要输出Gerber的时候在路径那里敲个./out，不然找不到文件。\n然后点击插件即可输出JLC支持的Gerber文件！\n","date":"2024-09-16T00:00:00Z","permalink":"https://a233a2.github.io/p/kicad%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/","title":"KiCad学习日记"},{"content":"YSYX学习日记 学习记录： 学习记录。\nUbuntu安装 ","date":"2024-09-16T00:00:00Z","permalink":"https://a233a2.github.io/p/ysyx%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/","title":"YSYX学习日记"},{"content":"分数阶数学控制 ARDC课程上得到了有关于在分数阶下控制的相关知识，得知其是因为传统的整数阶控制存在一定的信息丢失。使得控制精度在某些场合不尽理想，所以近现代诞生出分数阶控制的相关理论研究。\n巧合的是，分数阶微分的英文缩写居然是FOC！(Fractional Calculus)\n","date":"2024-09-16T00:00:00Z","permalink":"https://a233a2.github.io/p/%E5%88%86%E6%95%B0%E9%98%B6%E6%95%B0%E5%AD%A6%E6%8E%A7%E5%88%B6/","title":"分数阶数学控制"},{"content":"臭猫FOC驱动器设计日志 主控芯片：WCH-CH32V307VCT6\n预驱芯片：EG2133\nMOS：NEC6050\n下载芯片：CH549G\n电流检测：INA240A2 2024-9-15 期待已久的FOC驱动器终于开工设计！设计完成PCB以及原理图。第一次设计双路的FOC驱动器，也是第一次是设计功率地与普通的GND隔离。\n另外就是电流检测芯片选择的是TI的INA240A2，有点难以购买qaq0.0每个芯片的价格在3元左右，属实有点成本爆炸。下次准备学习更换更为便宜的INA199或者其他国产方案。\n2024-9-17 计划物料到货开始焊接\n这板子有一些bug，就是CH549G下载电路的供电有些问题。在使用DC-12v供电测试的时候，CH549G下载电路的供电不稳定。 另外在开环测试的时候供电也不稳定。不知道是不是程序问题。 接下来抽时间对驱动器进行软件开发\n开环FOC驱动测试 开环运行即根据系统时间为索引，根据时间固定生成三相的正弦波。需要涉及Clark变换以及Park变换。 simpleFOC的开环速度代码如下 参考了：https://github.com/haotianh9/DengFOC_on_STM32 电压控制\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 static inline uint32_t LL_SYSTICK_IsActiveCounterFlag(void) { return ((SysTick-\u0026gt;CTRL \u0026amp; SysTick_CTRL_COUNTFLAG_Msk) == (SysTick_CTRL_COUNTFLAG_Msk)); } uint32_t getCurrentMicros(void) { /* Ensure COUNTFLAG is reset by reading SysTick control and status register */ LL_SYSTICK_IsActiveCounterFlag(); uint32_t m = HAL_GetTick(); const uint32_t tms = SysTick-\u0026gt;LOAD + 1; __IO uint32_t u = tms - SysTick-\u0026gt;VAL; if (LL_SYSTICK_IsActiveCounterFlag()) { m = HAL_GetTick(); u = tms - SysTick-\u0026gt;VAL; } return (m * 1000 + (u * 1000) / tms); } //【应该是获取运行时间的代码段。】 float _electricalAngle(float shaft_angle, int pole_pairs) { return (shaft_angle * pole_pairs); } float _normalizeAngle(float angle){ float a = fmod(angle, 2*M_PI); //取余运算可以用于归一化，列出特殊值例子算便知 return a \u0026gt;= 0 ? a : (a + 2*M_PI); //三目运算符。格式：condition ? expr1 : expr2 //其中，condition 是要求值的条件表达式，如果条件成立，则返回 expr1 的值，否则返回 expr2 的值。 //可以将三目运算符视为 if-else 语句的简化形式。 //fmod 函数的余数的符号与除数相同。因此，当 angle 的值为负数时，余数的符号将与 _2M_PI 的符号相反。 //也就是说，如果 angle 的值小于 0 且 _2M_PI 的值为正数，则 fmod(angle, _2M_PI) 的余数将为负数。 //例如，当 angle 的值为 -M_PI/2，_2M_PI 的值为 2M_PI 时，fmod(angle, _2M_PI) 将返回一个负数。 //在这种情况下，可以通过将负数的余数加上 _2M_PI 来将角度归一化到 [0, 2M_PI] 的范围内，以确保角度的值始终为正数。 } void setPwm(float Ua, float Ub, float Uc) { //\t// 限制上限 Ua = _constrain(Ua, 0.0f, voltage_limit); Ub = _constrain(Ub, 0.0f, voltage_limit); Uc = _constrain(Uc, 0.0f, voltage_limit); // 计算占空比 // 限制占空比从0到1 dc_a = _constrain(Ua / voltage_power_supply, 0.0f , 1.0f ); dc_b = _constrain(Ub / voltage_power_supply, 0.0f , 1.0f ); dc_c = _constrain(Uc / voltage_power_supply, 0.0f , 1.0f ); //写入PWM到PWM 0 1 2 通道 TIM1-\u0026gt;CCR1 = (uint32_t) roundf(dc_a*period); TIM1-\u0026gt;CCR2 = (uint32_t) roundf(dc_b*period); TIM1-\u0026gt;CCR3 = (uint32_t) roundf(dc_c*period); } void setPhaseVoltage(float Uq,float Ud, float angle_el) { angle_el = _normalizeAngle(angle_el + zero_electric_angle); // 帕克逆变换 Ualpha = -Uq*sin(angle_el); Ubeta = Uq*cos(angle_el); // 克拉克逆变换 Ua = Ualpha + voltage_power_supply/2; Ub = (sqrt(3)*Ubeta-Ualpha)/2 + voltage_power_supply/2; Uc = (-Ualpha-sqrt(3)*Ubeta)/2 + voltage_power_supply/2; setPwm(Ua,Ub,Uc); } //开环速度函数 float velocityOpenloop(float target_velocity){ //\tuint32_t now_us = getCurrentMicros(); //\tuint32_t now_us = HAL_GetTick(); // Provides a tick value in microseconds. //计算当前每个Loop的运行时间间隔 // float Ts = (now_us - open_loop_timestamp) * 1e-3f; float Ts=5E-3f; // 通过乘以时间间隔和目标速度来计算需要转动的机械角度，存储在 shaft_angle 变量中。 //在此之前，还需要对轴角度进行归一化，以确保其值在 0 到 2π 之间。 shaft_angle = _normalizeAngle(shaft_angle + target_velocity*Ts); //以目标速度为 10 rad/s 为例，如果时间间隔是 1 秒，则在每个循环中需要增加 10 * 1 = 10 弧度的角度变化量，才能使电机转动到目标速度。 //如果时间间隔是 0.1 秒，那么在每个循环中需要增加的角度变化量就是 10 * 0.1 = 1 弧度，才能实现相同的目标速度。 //因此，电机轴的转动角度取决于目标速度和时间间隔的乘积。 // Uq is not related to voltage limit float Uq = 5.5; setPhaseVoltage(Uq, 0, _electricalAngle(shaft_angle, pole_pairs)); // open_loop_timestamp = now_us; //用于计算下一个时间间隔 return Uq; } 波形图根据上述代码来生成的话有些错误。这导致电机不能正确转动。而发出固定的啸叫。\n时间改为us后，波形图更加混乱。\n将时间的获取改为定时器中断+全局变量后。首先设置1us生成波形图如下：\n调整为200us时波形图如下：\n按理说这样运行开环已经可以完美运行，但是接入电脑5v-usb供电的时候电机依然跳动+啸叫。\n接入正常12v电源供电时，板子直接没了反应。。可能是设计的电源出现了问题。将电压降低到5v后板子可以正常上电启动，但是无法正常运行，整体是一种上电运行后，电机转动力巨大，然后系统死机重启陷入了死循环。\n电源设计还是不太过关。。。而且设计的有些混乱。。计划下一板改进，但是这种工程耗费时间太大了，下次进行工程实现之前应该提前做好功课。\nAS5600磁编码器电机底板 2024-9-18 PCB刚刚到货，准备抽时间进行焊接。再一次把CM_FOC的串口通信部分焊接完成，方便查看波形等。 SH1.25的接口画错了，属实是大意了。飞线暂时解决了问题。 AS5600磁编码器数据读取 AS5600是12位的霍尔磁编码器，它的地址是0x36，只需要读取0x0C、0x0D这两个寄存器就可以读出角度的原始数据，再将其乘以360，再除以4096，就可以获得角度值。\n鸽了一段时间，等忙完就马上开始测试。在此之前还需要把电源修好、、、、悲\n速度闭环测试 ","date":"2024-09-15T00:00:00Z","permalink":"https://a233a2.github.io/p/cm_foc%E9%A9%B1%E5%8A%A8%E5%99%A8/","title":"CM_FOC驱动器"},{"content":"hello！ hello！ 猪锅的CSGO精彩时刻 ","date":"2024-09-14T22:20:23+08:00","permalink":"https://a233a2.github.io/p/%E4%B8%AA%E4%BA%BA%E6%9D%82%E8%AE%B0/","title":"个人杂记"},{"content":"CH32平衡车开发板设计 主控芯片：CH32V307VCT6 电机驱动：TB6612方案 下载芯片：CH549G 开源链接：https://github.com/a233a2/CH32_DC_BalanceCar\nPID平衡部分计划使用两种方案进行对比 1 pid_1.c文件 即不通过控制角度来确定速度，通过将直立环PID的目标设为重力0点，来维持平衡，之后通过速度环调速。 2 pid.c文件 通过控制角度来确定速度，速度环输出目标速度下的应得角度，直立环与速度环串级，直立环负责达到对应角度。\n某些地方还并不完善，比如PID参数方面还不尽完美。在之后我将从算法方面对其进行优化。从数学角度找找这两种方案的不同之处。\n","date":"2024-07-15T00:00:00Z","permalink":"https://a233a2.github.io/p/ch32%E5%B9%B3%E8%A1%A1%E8%BD%A6%E5%BC%80%E5%8F%91%E6%9D%BF/","title":"CH32平衡车开发板"}]