[{"content":"前面已经完成了环境配置：simulink-px4-wsl2仿真环境搭建 接下来使用这个开发环境进行特殊算法的部署，记录在这个页面。\nSimulink电机转动模型 ","date":"2024-11-30T00:00:00Z","permalink":"https://a233a2.github.io/p/simulink-px4-wsl%E5%BC%80%E5%8F%91/","title":"Simulink-PX4-WSL开发"},{"content":"PX4-Simulink联合环境配置 参考如下教学： PX4与Simulink联合仿真-入门篇 PX4与Simulink联合仿真-进阶篇 使用Pixhawk2.4.8基于Simulink进行入门级飞控算法自主开发的操作 基于Simulink的PX4飞控算法的开发实践（1.硬件支持包配置） 基于Simulink的ROS2下PX4无人机控制框架-入门篇\nPX4版本：适配matlab 2022b的v1.12.3 Matlab版本：2022b windows：Windows11家庭版 遇到的错误：在编译时一直提示找不到.px4文件的错误如下图： 直接放弃2022的了，改用2024的Matlab进行开发的尝试。\n开发环境的配置1 更换各部件版本如下 电脑：LEGION Y7000P IRX9 LAPTOP 硬件：Intel(R) Core(TM) i7-14650HX 2.20 GHz + RTX4060 + 16GB PX4版本：适配matlab 2024b的v1.14 Matlab版本：2024b windows：Windows11专业版-24H2版本（现改的） 首先安装如下的几个必须的依赖，再安装这个工具箱。 安装的附加功能如下 WSL2的安装 此时在WSL中没有Ubuntu系统，需要安装一下22.04的ubuntu 不知道为啥这win11用wsl命令一直下载不下来，卡在0%半天不动。网上说是系统更新的原因。。。网上建议去手动下载，或者是Store里面下载，但是我Store也是打不开，所以手动下载地址如下： 下载地址：Manual installation steps for older versions of WSL 安装完后显示这个错误，是因为我的设置导致新应用安装到了D盘，需要更改以下Ubuntu的位置到C盘。 卸载重装一般是没用的，这个貌似是默认安装在你选择的默认安装位置，所以需要更改默认安装位置再安装或者是直接移动App。 卸载重装是不行的，需要选择移动到C盘才可以。。。 之后成功安装了Ubuntu系统 但是仍然打开工具箱后无法跳转到下一步，按照社区给的指示操作如下。 更改以下系统的类型到专业版，方便后续更改电脑的语言。 弄到这我也是服了，这b win11语言一直下载不下来，网上尝试了各种办法都特么不行。 然后重启了几次，显示更新xxx，结果重新打开matlab之后便可以进行到下一步了。。。。。我特么！ 在这里怀疑一个很大的原因是没有设置默认WSL启动为ubuntu，可以按照matlab文档里面设置一下，就CMD一个命令。然后重启打开Matlab。 PS:折腾了半天，win11的语言包终于能下载了，不过也没用了。。。 开发环境的配置2 ok，过了第一步剩下的其实好说。 配置参考：https://blog.csdn.net/weixin_29062909/article/details/138366879\nPX4源码下载 这里选择Python地址来验证。没有尝试过他的自动下载，也不建议自动。 这里去下载PX4的源码，2024B系列Matlab支持的是PX4 v1.14版本 这里与之前的2022版本的Matlab的UAV工具箱不同，固件要下载到WSL目录之下。\nCloning the firmware in WSL2 home directory is crucial. If you clone it outside of the WSL file system, then you will encounter slow execution issues and access right / permission errors. 在 WSL2 主目录中克隆固件至关重要。如果将其克隆到 WSL 文件系统之外，那么您将遇到执行缓慢的问题和访问权限/权限错误。\n执行如下的命令以在WSL中下载固件。可能就是安装到C盘去了，作为我这个上古时代的电脑分盘使用者来说很不友好，弄得我很不爽。\n1 2 3 4 5 6 mkdir mypx4 cd mypx4 git clone https://github.com/PX4/PX4-Autopilot.git --recursive cd PX4-Autopilot git checkout v1.14.0 -f git submodule update --init --recursive 这里出现了个没有分支的错误，我们创建一个。不创建也问题不大，这里官方文档中并没有这一步。 git switch -c \u0026lt;v1.14\u0026gt; 接下来就是漫长的下载submodule时间。。。。 下载完成后，对上面的硬件设置窗口，点击下一步。 在文件资源管理器中，可以找到Linux的地址，一般是home下，找到地址复制过去。验证。ok！ PX4 ToolChain下载以及编译程序 https://www.mathworks.com/help/releases/R2024b/uav/px4/ug/setup-px4-toolchain-wsl.html 跟着官网教程进入目录 运行脚本下载即可。这些都是前人为我们铺好的路。 此处时间较长可以给自己弄杯咖啡等着。。。。 下面检验下工具链的安装是否正确。 在PX4-Autopilot目录下运行了make px4_fmu-v3_default 出现了在ubuntu配置时以前遇到过的缺少STM32在Linux下开发工具的错误。 之前的解决方法：编译时报错：The CMAKE_CXX_COMPILER arm-none-eabi is not a full path and was not found in the PATH.的问题解决方法 重启之后，之前的错误居然没了。成功编译。 这里与我之前ubuntu下配置一样。我不禁思考我在配置ubuntu时，是不是重启一下也能解决呢？ 配置引导页面 重启之后，这个导引窗口也没了安装工具链那一步了。 让我们确认 翻译如下： 应该是问你是否要自己设计控制器，自己要设计控制器的话，勾选，后续可能需要自己搭建。 我们此处选项勾选。不勾选的以后再试试。 下一步，选择我们的F427老爷飞控。 应该是选自启动脚本。第一个是选择在PX4自身中的默认启动脚本。第二个是选择在SD卡中的用户编辑的脚本。 CSDN博主说选择第二个较为繁琐，那我们选第一个。 确定QGC地面站的位置 这一步，应该是让我们在QGC中选择鸡架,先下一步吧。Mavlink还没连接上应该也选择不了。 编译工程。我们勾选删除所有目标xxxx。 我们之前人工make构建了一次，这里再点一次，直接秒成功了。可能是检测到了之前构建产生的px4文件。 再次在matlab中构建，依然成功。 这里叫我们测试硬件连接。这里我拿之前焊的PX4进行连接。 连接上之后烧录固件。如果开着QGC，需要关掉。否则串口占用没法下载 Matlab页面显示下载烧录完成。 可以验证以下陀螺仪加速度数据。可以看到我这里能正常读取数据。 获取陀螺仪数据的Simulink实例程序 官方教程地址：Getting Started with Connected I/O for PX4 Host Target 这可以作为我们的第一个开发程序。 在simulink建模中，模型设置，按照官方给出的指导设置如下。 Simulink建立一个这样的简单读取数据的模型。 可以看到可以成功读取到数据，仿真10秒。之前我没动，后面动了两下。实在是太开心了。 再来一张吧 配合可视化平台进行仿真 ","date":"2024-11-29T00:00:00Z","image":"https://a233a2.github.io/p/simulink-px4-wsl2%E4%BB%BF%E7%9C%9F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/fengmian_hu12044621347677834083.png","permalink":"https://a233a2.github.io/p/simulink-px4-wsl2%E4%BB%BF%E7%9C%9F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/","title":"Simulink-PX4-WSL2仿真环境搭建"},{"content":"非电子专业自用知识点，水平低下请见谅。\n电分基础定理 基尔霍夫电流定律（KCL） 基尔霍夫电流定律：简写为KCL，可描述为对任一集总参数电路，在任一时刻，流入（或“流出”）任一结点的电流的代数和等于零。 在任何一个节点处，所有进入该节点的电流之和等于所有离开该节点的电流之和。\n基尔霍夫电压定律（KVL） 基尔霍夫电压定律：简写为KVL，其可表述为对任一集总参数电路，在任一时刻，环绕任一回路（可自行假定为逆时针环绕或者顺时针环绕）,所有支路电压降（或“电压升”）的代数和等于零。 在一个封闭回路中，总电压降等于总电动势。\n路的等效分析方法 戴维南定理：电路可以替代为一个电压源和一个电阻构成的等效电路。其中求等效电阻时将电压源短路，电流源断路。\n诺顿定理：线性二端电路可以由电流源IN和与之并联的电阻RN构成的等效电路替代，其中IN为流过端口的短路电流，RN为独立电流源关闭时端口的输入电阻（或等效）电阻。\n元器件电路分析 二极管 三极管 场效应管 运算放大器 阻抗匹配 具有电阻、电感和电容的电路里，对交流电所起的阻碍作用叫做阻抗。阻抗常用Z表示。阻抗由电阻、感抗和容抗三者组成，但不是三者简单相加。阻抗的单位是欧。\n电路元件的阻抗 如果将元件在正弦稳态时电压相量与电流相量之比定义为该元件的阻抗Z，则有： $$ Z=\\frac{\\overset{\\bullet}{U}}{\\overset{\\bullet}{I}} $$\n$$ Z_R=R $$\n$$ Z_C=\\frac{1}{j\\omega C} $$\n$$ Z_L=j\\omega L $$\n传输线的特征阻抗 传输线上的反射 ","date":"2024-11-29T00:00:00Z","permalink":"https://a233a2.github.io/p/%E7%94%B5%E8%B7%AF%E5%AD%A6%E5%9F%BA%E7%A1%80/","title":"电路学基础"},{"content":"基础操作 PADS简易教程 EDAHelper\u0026ndash;EDA增强工具 教程 | 24小时教会使用PADS进行PCB设计 PADS 入门教程（一） PADS VX系列 全套零基础入门PCB Layout设计实战视频教程PCB设计培训凡亿教育 PADS Layout：封装 PADS Logic：原理图 PADS Router：布线\n绘制板框 在Layout页面右下角可以切换mm或者mil单位。\n全选画的线，右键选择特性，类型选择板框。另外i有DXF文件也可以导入DXF文件来确定板框。\n原理图转PCB 原理图与PCB通过Logic连接。点击发送网表即可。也可以在PCB页面手动导入网表（.asc文件） 然后在原理图中勾选部分元件，在PCB上右键勾选的元件，点击“分散”即可将元件分散开，方便之后布局。\nPS：在原理图选择后，在PCB上高亮。快捷键Ctrl+E可以快速选择移动。\nLayout 布局位置确定后，可以右键器件选择特性，勾选胶粘G。可以防止误移。\n得到PCB和SCH工程后如何建库关联 原理就是新建一个库，把所有现存的封装都加进去，然后就可以了，十分简单。 首先新建一个库，将其放到最开始。这样索引的时候可以最先索引。 选择原理图中的元件，只选原件。 选中后，右键选择保存到库中。 全选-确定。提示有重复的话直接覆盖就可以。 PCB也是如此，在开始时，可能由于有胶粘元件的设置无法选中元件，在空白处右键选择筛选条件，把胶粘元件勾选上。 一样的操作，全选，覆盖。 之后PCB和原理图中的封装就对应起来了。可以进行二次开发了。\n","date":"2024-11-21T00:00:00Z","image":"https://a233a2.github.io/p/pads%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/pads_hu1782877542276546065.jpg","permalink":"https://a233a2.github.io/p/pads%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/","title":"PADS学习日记"},{"content":"参考： Docker-从入门到实践\u0026mdash;一本书 求求你了，用Docker吧\u0026mdash;某博客 Docker安装教程\u0026mdash;官方安装教程 GeekHour-30分钟Docker入门教程\u0026mdash;特别棒\nDocker基础的几个概念 镜像 Image 理解为一个虚拟机的快照，内部包含要部署的应用程序以及他所关联的所有库。 是一个包含有文件系统的面向Docker引擎的只读模板。镜像是一个模板,装了一些系统的配置文件, 我们可以通过镜像建立更多的容器, 容器从镜像启动时,Docker在镜像的上层创建一个可写层, 镜像本身不变。\n容器 Container 通过镜像Image，可以创建许多不同的容器Container。容器可以比喻为一台台运行起来的虚拟机，容器中运行着要部署的程序。每个容器相互独立运行，互不影响。 容器是基于镜像创建, 相互隔离的, 可以理解为小型虚拟机，真正的执行单元。\n相当于每一个实例。\n一台计算机上可以运行几个虚拟机，但是可以运行几百个容器。\n容器和镜像的关系 镜像和容器的关系就像java中类和实例的关系一样（我也没学过java..抄的） 镜像就类似一个食谱，容器就是根据食谱做出来的一道菜。\nDockerfile 自动化脚本，用以创建镜像。\nDocker 仓库-Docker Repository 存放镜像的仓库 最流行的是DockerHub，是一个公共仓库，集中存储和管理Docker镜像。另外还有Harbor\nDocker容器化 将应用程序打包成容器，然后在容器中运行程序的过程。 1# 创建Dockerfile 告诉Docker构建应用程序镜像所需的步骤以及配置。 2# 使用Dockerfile构建镜像。 3# 使用镜像创建和运行容器。\nDocker简单HelloDocker实践 创建HelloDocker文件，创建node.js文件\n1 console.log(\u0026#34;欢迎来到Docker！\u0026#34;) Dockerfile中写入如下的运行流程，交给Docker自动运行。 项目根目录创建名为Dockerfile的文件\n1 2 3 FROM node:14-alpine COPY index.js /index.js CMD [\u0026#34;node\u0026#34;,\u0026#34;/index.js\u0026#34;] 输出结果： 有个小Warning,暂时不清楚原因。\nplay with docker网站 在线运行docker镜像 https://labs.play-with-docker.com/\nDocker命令小计 1 2 3 4 5 docker images #查看安装的镜像 docker image ls #查看安装的镜像 docker run 镜像名称 #运行程序 docker pull xxx #获取镜像 DockerDesktop的使用 DockerDesktop集成了容器日常使用与管理的各种常用功能\nDocker Compose 统筹各个容器，形成一个项目。 使用一个yml文件定义，使用一条命令来自动安装各种依赖以及配置环境。然后在本地运行项目。\n1 $ docker compose up Docker部署深度学习项目实例 先鸽了\nDocker部署PX4开发环境实例 Docker的PX4容器项目地址：https://github.com/PX4/PX4-containers\n1 克隆项目到本地 2 执行 1 2 cd docker docker build -t px4io/px4-dev-ros-melodic -f Dockerfile_ros-melodic . 构建完成镜像大小为6.5GB左右\n3 构建Firmware时使用Docker环境？ 3这个还没试过\n","date":"2024-11-20T00:00:00Z","image":"https://a233a2.github.io/p/docker%E5%9F%BA%E7%A1%80/11_hu13753747889707102422.jpg","permalink":"https://a233a2.github.io/p/docker%E5%9F%BA%E7%A1%80/","title":"Docker基础"},{"content":"凉快\n","date":"2024-11-15T00:00:00Z","permalink":"https://a233a2.github.io/p/%E4%B8%93%E5%B1%9E%E7%A9%BA%E8%B0%83%E6%88%BF/","title":"专属空调房"},{"content":"INAV无人机搭建 飞控：重山AT32 F435VIM7\n电调：\n电机：2004-1750kv电机\n机架：5寸-牙签机架 图传：\n","date":"2024-11-13T00:00:00Z","image":"https://a233a2.github.io/p/inav%E6%97%A0%E4%BA%BA%E6%9C%BA%E6%90%AD%E5%BB%BA/INAV1_hu151214664103745662.png","permalink":"https://a233a2.github.io/p/inav%E6%97%A0%E4%BA%BA%E6%9C%BA%E6%90%AD%E5%BB%BA/","title":"INAV无人机搭建"},{"content":"机器学习分类 无监督学习 聚类问题 监督学习 回归问题 分类问题 强化学习 无监督学习 ","date":"2024-11-13T00:00:00Z","permalink":"https://a233a2.github.io/p/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/","title":"机器学习基础"},{"content":"基础 两层神经网络分析为例 摘自zhihu：神经网络15分钟入门！足够通俗易懂了吧 任务描述：在坐标系中，给出一个坐标系，使用神经网络进行分类象限。\n输入层 在我们的例子中，输入层是坐标值，例如（1,1），这是一个包含两个元素的数组， 也可以看作是一个12的矩阵。输入层的元素维度与输入量的特征息息相关，如果输 入的是一张3232像素的灰度图像，那么输入层的维度就是32*32。\n输入层到隐藏层 连接输入层和隐藏层的是W1和b1。由X计算得到H十分简单，就是矩阵运算： $$ H=XW1+b1 $$ 如上图中所示，在设定隐藏层为50维（也可以理解成50个神经元）之后，矩阵H的大小为（150）的矩阵。\n隐藏层到输出层 连接隐藏层和输出层的是W2和b2。同样是通过矩阵运算进行的： $$ Y=H*W2+b2 $$ 通过上述两个线性方程的计算，我们就能得到最终的输出Y了，但是如果你还对线性代数的计算有印象的话，应该会知道：一系列线性方程的运算最终都可以用一个线性方程表示。也就是说，上述两个式子联立后可以用一个线性方程表达。对于两次神经网络是这样，就算网络深度加到100层，也依然是这样。这样的话神经网络就失去了意义。\n激活层 神经网络中的激活层（Activation Layer）主要负责为网络中的每一层神经元引入非线性因素。没有激活函数，神经网络就只能执行线性变换，而线性变换无法表达复杂的模式和特征。因此，激活函数是神经网络能够处理非线性问题、进行更复杂计算的关键。\n简而言之，激活层是为矩阵运算的结果添加非线性的。常用的激活函数有三种，分别是阶跃函数、Sigmoid和ReLU。 其中，阶跃函数输出值是跳变的，且只有二值，较少使用；Sigmoid函数在当x的绝对值较大时，曲线的斜率变化很小（梯度消失），并且计算较复杂；ReLU是当前较为常用的激活函数。 激活函数具体是怎么计算的呢？ 假如经过公式H=X*W1+b1计算得到的H值为：(1,-2,3,-4,7\u0026hellip;)，那么经过阶跃函数激活层后就会变为(1,0,1,0,1\u0026hellip;)，经过ReLU激活层之后会变为(1,0,3,0,7\u0026hellip;)。 需要注意的是，每个隐藏层计算（矩阵线性运算）之后，都需要加一层激活层，要不然该层线性计算是没有意义的。 神经网络之所以能够处理复杂的任务，正是因为非线性激活函数的存在。激活函数将线性变换的输出“扭曲”成非线性，从而让网络能够捕捉数据中的非线性关系，例如在图像、语音、文本等复杂场景中。\n输出的正规化 现在我们的输出Y的值可能会是(3,1,0.1,0.5)这样的矩阵，诚然我们可以找到里边的最大值“3”，从而找到对应的分类为I，但是这并不直观。我们想让最终的输出为概率，也就是说可以生成像(90%,5%,2%,3%)这样的结果，这样做不仅可以找到最大概率的分类，而且可以知道各个分类计算的概率值。\nSoftmax正规化 $$ S_i=\\frac{e^i}{\\sum{_je^j}} $$ 简单来说分三步进行：（1）以e为底对所有元素求指数幂；（2）将所有指数幂求和；（3）分别将这些指数幂与该和做商。这样求出的结果中，所有元素的和一定为1，而每个元素可以代表概率值。 我们将使用这个计算公式做输出结果正规化处理的层叫做“Softmax”层。此时的神经网络将变成如上图所示：\n衡量输出的好坏 通过Softmax层之后，我们得到了I，II，III和IV这四个类别分别对应的概率，但是要注意，这是神经网络计算得到的概率值结果，而非真实的情况。\n比如，Softmax输出的结果是(90%,5%,3%,2%)，真实的结果是(100%,0,0,0)。虽然输出的结果可以正确分类，但是与真实结果之间是有差距的，一个优秀的网络对结果的预测要无限接近于100%，为此，我们需要将Softmax输出结果的好坏程度做一个“量化”。 一种直观的解决方法，是用1减去Softmax输出的概率，比如1-90%=0.1。不过更为常用且巧妙的方法是，求对数的负数。 还是用90%举例，对数的负数就是：-log0.9=0.046 可以想见，概率越接近100%，该计算结果值越接近于0，说明结果越准确，该输出叫做“交叉熵损失（Cross Entropy Error）”。 我们训练神经网络的目的，就是尽可能地减少这个“交叉熵损失”。 反向传播与参数优化 上边的1~4节，讲述了神经网络的正向传播过程。一句话复习一下：神经网络的传播都是形如Y=WX+b的矩阵运算；为了给矩阵运算加入非线性，需要在隐藏层中加入激活层；输出层结果需要经过Softmax层处理为概率值，并通过交叉熵损失来量化当前网络的优劣。 算出交叉熵损失后，就要开始反向传播了。其实反向传播就是一个参数优化的过程，优化对象就是网络中的所有W和b（因为其他所有参数都是确定的）。 神经网络的神奇之处，就在于它可以自动做W和b的优化，在深度学习中，参数的数量有时会上亿，不过其优化的原理和我们这个两层神经网络是一样的。\n迭代 神经网络需要反复迭代。 如上述例子中，第一次计算得到的概率是90%，交叉熵损失值是0.046；将该损失值反向传播，使W1,b1,W2,b2做相应微调；再做第二次运算，此时的概率可能就会提高到92%，相应地，损失值也会下降，然后再反向传播损失值，微调参数W1,b1,W2,b2。依次类推，损失值越来越小，直到我们满意为止。 此时我们就得到了理想的W1,b1,W2,b2。 此时如果将任意一组坐标作为输入，利用图4或图5的流程，就能得到分类结果。\n各类型神经网络 CNN卷积神经网络30分钟入门 摘自：【深度学习-第2篇】CNN卷积神经网络30分钟入门！足够通俗易懂了吧（图解）\n从前馈神经网络到CNN 前馈神经网络（Feedforward Neural Networks）是最基础的神经网络模型，也被称为多层感知机（MLP）。\n它由多个神经元组成，每个神经元与前一层的所有神经元相连，形成一个“全连接”的结构。每个神经元会对其输入数据进行线性变换（通过权重矩阵），然后通过一个非线性函数（如ReLU或Sigmoid）进行激活。这就是前馈神经网络的基本操作。 卷积神经网络（Convolutional Neural Network, 简称CNN）开始。很大程度上，是由于CNN的基本组成部分与前馈神经网络有很紧密的关联，甚至可以说，CNN就是一种特殊的前馈神经网络。 这两者的主要区别在于，CNN在前馈神经网络的基础上加入了卷积层和池化层（下边会讲到），以便更好地处理图像等具有空间结构的数据。\n现在画图说明一下。对于前馈神经网络，我们可以将简化后的网络结构如下图表示： 当然，【全连接层-ReLU】可以有多个，此时网络结构可以表示为： 简单地说，CNN就是在此基础上，将全连接层换成卷积层，并在ReLU层之后加入池化层（非必须），那么一个基本的CNN结构就可以表示成这样： 卷积层 使用卷积是为了更好的处理图像等信息。若使用全连接前馈神经网络来处理图像，会使得参数太多、不利于表达空间上的结构。另外难以反应平移不变性。CNN由于权重共享，可以无论特征在何处出现都能被检测到，从而提供了一种平移不变性。另外难以表征抽象层级。CNN通过多个卷积层和池化层的叠加，可以从低级的边缘和纹理特征逐渐抽取出高级的语义特征。这个特性使得CNN非常适合于处理图像等需要多层抽象表示的数据。 卷积的过程，其实是一种滤波的过程，所以卷积核（Convolution Kernel）还有一个别名叫做Filter，也就是滤波器。 当一组数像滑窗一样滑过另外一组数时，将对应的数据相乘并求和得到一组新的数，这个过程必然和卷积有着莫大的关系。 其中权重系数都为1/3，也就是均值滤波的过程。变换不同的权重系数，滤波器将展现出不同的滤波特性。所以我们又可以得到一个结论：当权重系数（卷积核）的参数改变时，它可以提取的特征类型也会改变。所以训练卷积神经网络时，实质上训练的是卷积核的参数。 1 2 3 4 5 1.定义一个卷积核：卷积核是一个小的矩阵（例如3x3或5x5），包含一些数字。这个卷积核的作用是在图像中识别特定类型的特征，例如边缘、线条等，也可能是难以描述的抽象特征。 2.卷积核滑过图像：卷积操作开始时，卷积核会被放置在图像的左上角。然后，它会按照一定的步长（stride）在图像上滑动，可以是从左到右，也可以是从上到下。步长定义了卷积核每次移动的距离。 3.计算点积：在卷积核每个位置，都会计算卷积核和图像对应部分的点积。这就是将卷积核中的每个元素与图像中对应位置的像素值相乘，然后将所有乘积相加。 4.生成新的特征图：每次计算的点积结果被用来构建一个新的图像，也称为特征图或卷积图。 5.重复以上过程：通常在一个 CNN 中，我们会有多个不同的卷积核同时进行卷积操作。这意味着我们会得到多个特征图，每个特征图捕捉了原始图像中的不同特征。 ReLU在CNN中的位置 卷积层和全连接一样，也是一种线性变换，无论进行多少次这样的操作，都只能获得输入数据的线性组合。如果没有非线性的激活函数，那么即使是多层的神经网络，在理论上也可以被一个单层的神经网络所表达，这极大地限制了网络的表达能力。\nReLU函数是一个非线性函数，只保留正数元素，将负数元素设置为0。这种简单的修正线性单元具有许多优点，例如，它能够缓解梯度消失问题，计算速度快，同时ReLU的输出是稀疏的，这有助于模型的正则化。ReLU的响应函数图像如下： 化繁为简的池化层 ReLU激活层之后就是池化层。 池化层的主要作用是对非线性激活后的结果进行降采样，以减少参数的数量，避免过拟合，并提高模型的处理速度。 池化层主要采用最大池化（Max Pooling）、平均池化（Average Pooling）等方式，对特征图进行操作。以最常见的最大池化为例，我们选择一个窗口（比如 2x2）在特征图上滑动，每次选取窗口中的最大值作为输出，这就是最大池化的工作方式： 大致可以看出，经过池化计算后的图像，基本就是左侧特征图的“低像素版”结果。也就是说池化运算能够保留最强烈的特征，并大大降低数据体量。\n到现在，“卷积层→ReLU→池化层”这样一个CNN网络中的基本组成单元的基础概念就讲完了。但是需要注意，卷积层、ReLU和池化层的组合是一种常见模式，但不是唯一的方式。比如池化层作为降低网络复杂程度的计算环节，在算力硬件条件越来越好的当下，有些时候是可以减少采用次数的，也就是池化层可以在部分层设置、部分层不设置。 关于输出层 在卷积神经网络中，最后一层（或者说最后一部分）通常被称为输出层。这个层的作用是将之前所有层的信息集合起来，产生最终的预测结果。\n对于CNN进行分类任务时，输出部分的网络结构通常是一个或多个全连接层，然后连接Softmax。\n当然，如果想要从卷积层过渡到全连接层，你需要对卷积层的输出进行“展平”处理，简而言之就是将二维数据逐行串起来，变成一维数据。\n由于此时数据经过多层卷积和池化操作，数据量已大大减少，所以全连接层设计的参数就不会有那么多了。\n由基础模块搭建摩天大楼 在实际应用中，CNN网络往往是由多个卷积层构成，后续再缀接卷积层，则就是将上一层的输出作为后续的输入，然后重复“输入层→卷积层→ReLU→池化层”这个过程，当然池化层是非必须的。\n实例分析 CNN基础实验，手写数字识别！ 在bilibili上观看了手写数字识别的教程，跟着配置下来非常简单，是基于Python代码的。调用了torch来进行模型训练与识别。\nmodel.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 import torch from torch import nn #定义神经网络Network class Network(nn.Module): def __init__(self): super().__init__() # 线性层1，输入层和隐藏层之间的线性层 self.layer1 = nn.Linear(784, 256) # 线性层2，隐藏层和输出层之间的线性层 self.layer2 = nn.Linear(256, 10) # 在前向传播，forward函数中，输入为图像x def forward(self, x): x = x.view(-1, 28 * 28) # 使用view函数，将x展平 x = self.layer1(x) # 将x输入至layer1 x = torch.relu(x) # 使用relu激活 return self.layer2(x) # 输入至layer2计算结果 #手动的遍历模型中的各个结构，并计算可以训练的参数 def print_parameters(model): cnt = 0 for name, layer in model.named_children(): #遍历每一层 # 打印层的名称和该层中包含的可训练参数 print(f\u0026#34;layer({name}) parameters:\u0026#34;) for p in layer.parameters(): print(f\u0026#39;\\t {p.shape} has {p.numel()} parameters\u0026#39;) cnt += p.numel() #将参数数量累加至cnt #最后打印模型总参数数量 print(\u0026#39;The model has %d trainable parameters\\n\u0026#39; % (cnt)) #打印输入张量x经过每一层时的维度变化情况 def print_forward(model, x): print(f\u0026#34;x: {x.shape}\u0026#34;) # x从一个5*28*28的输入张量 x = x.view(-1, 28 * 28) # 经过view函数，变成了一个5*784的张量 print(f\u0026#34;after view: {x.shape}\u0026#34;) x = model.layer1(x) #经过第1个线性层，得到5*256的张量 print(f\u0026#34;after layer1: {x.shape}\u0026#34;) x = torch.relu(x) #经过relu函数，没有变化 print(f\u0026#34;after relu: {x.shape}\u0026#34;) x = model.layer2(x) #经过第2个线性层，得到一个5*10的结果 print(f\u0026#34;after layer2: {x.shape}\u0026#34;) if __name__ == \u0026#39;__main__\u0026#39;: model = Network() #定义一个Network模型 print(model) #将其打印，观察打印结果可以了解模型的结构 print(\u0026#34;\u0026#34;) print_parameters(model) #将模型的参数打印出来 #打印输入张量x经过每一层维度的变化情况 x = torch.zeros([5, 28, 28]) print_forward(model, x) test.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 from model import Network from torchvision import transforms from torchvision import datasets import torch if __name__ == \u0026#39;__main__\u0026#39;: transform = transforms.Compose([ transforms.Grayscale(num_output_channels=1), transforms.ToTensor() ]) # 读取测试数据集 test_dataset = datasets.ImageFolder(root=\u0026#39;./mnist_images/test\u0026#39;, transform=transform) print(\u0026#34;test_dataset length: \u0026#34;, len(test_dataset)) model = Network() # 定义神经网络模型 model.load_state_dict(torch.load(\u0026#39;mnist.pth\u0026#39;)) # 加载刚刚训练好的模型文件 right = 0 # 保存正确识别的数量 for i, (x, y) in enumerate(test_dataset): output = model(x) # 将其中的数据x输入到模型 predict = output.argmax(1).item() # 选择概率最大标签的作为预测结果 # 对比预测值predict和真实标签y if predict == y: right += 1 else: # 将识别错误的样例打印了出来 img_path = test_dataset.samples[i][0] print(f\u0026#34;wrong case: predict = {predict} y = {y} img_path = {img_path}\u0026#34;) # 计算出测试效果 sample_num = len(test_dataset) acc = right * 1.0 / sample_num print(\u0026#34;test accuracy = %d / %d = %.3lf\u0026#34; % (right, sample_num, acc)) train.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 import torch from torch import nn from torch import optim from model import Network from torchvision import transforms from torchvision import datasets from torch.utils.data import DataLoader if __name__ == \u0026#39;__main__\u0026#39;: # 图像的预处理 transform = transforms.Compose([ transforms.Grayscale(num_output_channels=1), # 转换为单通道灰度图 transforms.ToTensor() # 转换为张量 ]) # 读入并构造数据集 train_dataset = datasets.ImageFolder(root=\u0026#39;./mnist_images/train\u0026#39;, transform=transform) print(\u0026#34;train_dataset length: \u0026#34;, len(train_dataset)) # 小批量的数据读入 train_loader = DataLoader(train_dataset, batch_size=64, shuffle=True) print(\u0026#34;train_loader length: \u0026#34;, len(train_loader)) model = Network() # 模型本身，它就是我们设计的神经网络 optimizer = optim.Adam(model.parameters()) # 优化模型中的参数 criterion = nn.CrossEntropyLoss() # 分类问题，使用交叉熵损失误差 # 进入模型的迭代循环 for epoch in range(10): # 外层循环，代表了整个训练数据集的遍历次数 # 整个训练集要循环多少轮，是10次、20次或者100次都是可能的， # 内存循环使用train_loader，进行小批量的数据读取 for batch_idx, (data, label) in enumerate(train_loader): # 内层每循环一次，就会进行一次梯度下降算法 # 包括了5个步骤: output = model(data) # 1.计算神经网络的前向传播结果 loss = criterion(output, label) # 2.计算output和标签label之间的损失loss loss.backward() # 3.使用backward计算梯度 optimizer.step() # 4.使用optimizer.step更新参数 optimizer.zero_grad() # 5.将梯度清零 # 这5个步骤，是使用pytorch框架训练模型的定式，初学的时候，先记住就可以了 # 每迭代100个小批量，就打印一次模型的损失，观察训练的过程 if batch_idx % 100 == 0: print(f\u0026#34;Epoch {epoch + 1}/10 \u0026#34; f\u0026#34;| Batch {batch_idx}/{len(train_loader)} \u0026#34; f\u0026#34;| Loss: {loss.item():.4f}\u0026#34;) torch.save(model.state_dict(), \u0026#39;mnist.pth\u0026#39;) # 保存模型 数据的下载 数据采用mnist国际通用的手写数字识别库，下载方式采用python自动下载，参考了网上大佬的开源，脚本如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 \u0026#39;\u0026#39;\u0026#39; 1. 通过 torchvision.datasets.MNIST 下载、解压和读取 MNIST 数据集； 2. 使用 PIL.Image.save 将 MNIST 数据集中的灰度图片以 PNG 格式保存。 \u0026#39;\u0026#39;\u0026#39; import sys, os from torchvision.datasets import MNIST from tqdm import tqdm sys.path.insert(0, os.getcwd()) # 将当前工作目录添加到模块搜索路径的开头 if __name__ == \u0026#34;__main__\u0026#34;: # 图片保存路径 root = \u0026#39;mnist_images\u0026#39; # 定义保存图片的根目录 if not os.path.exists(root): # 如果根目录不存在 os.makedirs(root) # 创建根目录 # 训练集60K、测试集10K # torchvision.datasets.MNIST接口下载数据 training_dataset = MNIST( # 实例化torchvision.datasets.MNIST 类，加载MNIST数据集 root=\u0026#39;mnist\u0026#39;, # 数据集将被下载到当前工作目录下的 mnist 文件夹中 train=True, # 指定要下载的是训练集 download=True, # 如果本地路径中没有找到数据集，则联网下载；如果数据集已经存在于指定的 root 目录中，则不会重新下载 ) test_dataset = MNIST( # 实例化torchvision.datasets.MNIST 类，加载MNIST数据集 root=\u0026#39;mnist\u0026#39;, # 数据集将被下载到当前工作目录下的 mnist 文件夹中 train=False, # 指定要下载的是测试集 download=True, # 如果本地路径中没有找到数据集，则联网下载；如果数据集已经存在于指定的 root 目录中，则不会重新下载 ) # 保存训练集图片 with tqdm(total=len(training_dataset), ncols=150) as pro_bar: # 创建进度条，宽度为150个字符 for idx, (X, y) in enumerate(training_dataset): # 遍历训练集，enumerate函数为training_dataset的每个元素生成一个包含索引（idx）和元素本身（X,y）的元组，X代表图像数据，y则为对应标签 # 创建目标文件夹 train_dir = os.path.join(root, \u0026#34;train\u0026#34;, str(y)) # 定义保存训练集图片的目录 if not os.path.exists(train_dir): # 如果目录不存在 os.makedirs(train_dir) # 创建目录 f = os.path.join(train_dir, f\u0026#34;training_{y}_{idx}.png\u0026#34;) # 保存的文件名 X.save(f) # 保存图片，torchvision.datasets.MNIST默认将图像加载为PIL图像格式，.save() 是PIL库中图像对象的一个方法，用于将图像保存到文件 pro_bar.update(n=1) # 更新进度条 # 保存测试集图片 with tqdm(total=len(test_dataset), ncols=150) as pro_bar: # 创建进度条，宽度为150个字符 for idx, (X, y) in enumerate(test_dataset): # 遍历测试集，enumerate函数为training_dataset的每个元素生成一个包含索引（idx）和元素本身（X,y）的元组，X代表图像数据，y则为对应标签 # 创建目标文件夹 test_dir = os.path.join(root, \u0026#34;test\u0026#34;, str(y)) # 定义保存测试集图片的目录 if not os.path.exists(test_dir): # 如果目录不存在 os.makedirs(test_dir) # 创建目录 f = os.path.join(test_dir, f\u0026#34;test_{y}_{idx}.png\u0026#34;) # 保存的文件名 X.save(f) # 保存图片，torchvision.datasets.MNIST默认将图像加载为PIL图像格式，.save() 是PIL库中图像对象的一个方法，用于将图像保存到文件 pro_bar.update(n=1) # 更新进度条 ","date":"2024-11-13T00:00:00Z","permalink":"https://a233a2.github.io/p/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/","title":"神经网络基础"},{"content":"反步法 本质上也是利用李雅普诺夫第二方法对系统的控制器进行状态反馈设计。通过对系统的每一个状态方程依次进行迭代设计，最终串联成一个控制方案。 反步法(Backsteping method)又称为后推法，是一种由前往后递推的设计方法，该方法所对应的系统是通过串联形成的非线性系统，最初由科克托维奇(Kokotovic)于1991年提出，该方法的提出最初是用于线性系统，随着研究的深入发现它针对非线性系统也有很好的控制。 它的设计思想是将复杂的系统分解成若干个不超过原系统阶数的子系统，然后根据Lyapunov稳定性定理，针对每个子系统设计出中间的虚拟控制量，一直“反推”至整个系统，从而设计出系统的总控制律。\n简单的二阶非线性系统 对于一个简单的二阶非线性系统： 控制目标：使系统控制到原点处。（如果要控制在别的地方，先进行方程的坐标变换到原点即可）\n对于二阶系统的反步法，我们对两个方程分别分两步设计进行： 第一步，对第一个方程，将$x_2$看作输入。设计一个反馈控制率$x_2=\\phi \\left( x_1 \\right)$ ，使得第一个方程稳定； 第二步，对第二个方程，将$u$看做输入，设计一个反馈控制率，使得第二个方程也稳定；\n最后，得到的最终反馈控制率$u$，可以使得整个系统稳定。\n卡尔曼滤波算法 扩展卡尔曼滤波算法（EKF） 傅里叶变换 快速傅里叶变换法 滑膜算法 模糊PID算法 ","date":"2024-11-08T00:00:00Z","permalink":"https://a233a2.github.io/p/%E7%AE%97%E6%B3%95%E6%8C%96%E5%9D%91%E5%A1%AB%E5%9D%91/","title":"算法挖坑填坑"},{"content":"PMSM的数学建模 自然坐标系下PMSM的三相电压方程以及磁链方程。\n磁链（Flux Linkage） 是描述电磁现象的一个物理量，它表示穿过某个回路的磁场的总效应。 在电机中，磁链通常用来描述电流与磁场之间的关系。磁链的概念在电机控制和电磁学中非常重要。 在永磁同步电机（PMSM）和其他电机中，磁链是分析电压、电流和转矩的关键因素。 根据电磁感应定律，磁链的变化会在导体中产生感应电动势（电压）。 在控制系统中，通过控制磁链的大小和方向，可以间接控制电机的转矩和转速。 磁链的定义为：穿过导体线圈的磁通量与线圈匝数的乘积。 数学表达式为：\n$$𝜆=𝑁⋅Φ$$\n$𝜆$表示磁链（Flux Linkage），单位为韦伯（Wb）。\n$N$为线圈的匝数。\n$Φ$为磁通量（Flux），表示穿过线圈的磁场强度的总量，单位也是韦伯（Wb）。\n电流产生的磁链：当电流通过线圈时，会产生一个环绕线圈的磁场，这个磁场的磁通量在线圈中累积，形成磁链。永磁体产生的磁链：在永磁同步电机中，转子上的永磁体产生的磁场也会在定子绕组中产生磁链，这个磁链通常称为“转子磁链”或“永磁体磁链”。 根据法拉第电磁感应定律，磁链的变化率决定了感应电动势的大小，数学表达为： $$e=−dt/dλ$$ 因此，磁链的变化直接影响电机的电压方程和控制策略。\n自然坐标系下PMSM的三相电压方程以及磁链方程 电磁转矩 电磁转矩另外可以理解为电机中磁场储能对机械角度的偏导数。（来源于教材） 这种理解来源于电机中的能量转换原理，即电磁能量的变化会推动转子旋转，形成电磁转矩。\n磁场储能公式 教材中有电流转置，是因为电流需要加一个转置符号通常是因为在电机控制和矩阵运算中，电流和磁链通常表示为向量，而磁场储能计算涉及向量之间的点积或矩阵乘法。为了进行这些运算，需要确保维度匹配，这就是为什么需要将电流向量进行转置。\n电机的机械运动方程 三相坐标变换 对数学模型进行降价与解耦变换。\nClark变换（静止坐标变换） Clark变换（Clarke Transform）是一种将三相交流信号转换为两相直交坐标系的数学变换，广泛应用于电机控制和电力电子领域。其主要目的是简化三相电流或电压的分析和控制，尤其是在进行控制算法设计时（如在空间矢量调制和PID控制中）。 Park变换（同步旋转坐标变换） Park变换（Park Transform）是一种用于将三相交流信号（通常是电流或电压）转换为旋转坐标系的数学变换。它是电机控制中非常重要的工具，特别是在控制电机的矢量控制（Field-Oriented Control, FOC）中，Park变换帮助将三相信号转换为直流信号，从而简化控制策略。 反Park变换 反Park变换（Inverse Park Transform）是Park变换的逆过程，用于将旋转坐标系中的直流信号（$d$ 和 $q$ 分量）转换回三相交流信号（通常是电流或电压）。反Park变换在电机控制中非常重要 ，因为它可以将控制算法输出的信号转换为实际电机所需的三相信号，以便控制电机的运行。\n","date":"2024-10-26T00:00:00Z","permalink":"https://a233a2.github.io/p/pmsm%E5%8E%9F%E7%90%86%E5%8A%A0%E6%8E%A7%E5%88%B6%E6%96%B9%E6%B3%95%E4%BB%A5%E5%8F%8A%E4%BB%BF%E7%9C%9F/","title":"PMSM原理加控制方法以及仿真"},{"content":"一些概念 范数 高斯函数 最小二乘法 最小二乘-矩阵形式推导 ","date":"2024-10-24T00:00:00Z","permalink":"https://a233a2.github.io/p/%E5%B7%A5%E7%A8%8B%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/","title":"工程数学基础"},{"content":"此Blog记录了本人按照DRCAN视频推荐的学习顺序来系统学习DRCAN发表的控制相关视频。博客作为笔记使用。\n1-状态空间表达 以一个质量块-弹簧-阻尼器系统来进行分析：\n状态空间表达是即为：系统输入输出状态变量的一个集合，用一阶微分方程的形式表达出来。 状态空间表达与传递函数之间的关系：包括转换方程，以及重要结论：|SI-A|矩阵的特征值就是传递函数的极点！\n2-状态空间方程的解 有点难以推导且认为推导过程不太重要\n3-相图-相轨迹 相轨迹是系统的状态随时间变化的轨迹。当时间变化时，系统的状态点在状态空间中移动，这条移动的轨迹就是相轨迹。\n对于一个阻尼摆，系统的能量会逐渐衰减，最终趋于静止。其相轨迹不会形成闭合的曲线，而是一个逐渐收缩的螺旋，最终收敛到平衡点（摆静止的位置）。这说明系统是稳定的，且有能量损失。\n可以通过分析导数正负来判别该点的稳定性，后面结论重要一些。\n特殊的一种鞍点。在此令了上述x与y的导来确定x的输出？这个有些复杂。应该是用到了线性代数的坐标变换 看不太懂。。看特征值直观点。 对于复数的，而实部为0的特征值。是一个椭圆，Fixed Point为Center。 特征值复数但是实部不为0的时候。 总结上述情况。\n3.5-连续系统的离散化 采样频率至少要为原系统频率的两倍，这样才能重建出原信号。否则可能出现混叠现象，不能复现原系统变化趋势。（2倍只是下限理论值，实际工程中选取5-10倍） Zero Order Hold （ZOH零阶保持器），使得控制量在一个控制周期内保持不变。\n采样周期要与数据处理控制时间相匹配。若数据读入处理需要50ms，则小于50ms的采样周期将变得没有意义。 Error ：G(T) = ∫(0,T) exp(Aτ) dτ·B 状态空间的解输出，在离散系统下的表达形式。离散系统下不关心t，而着重与每个周期。系统输入u在一个周期内可以看作一个常数（ZOH的作用）。所以可以提取出来。\n使用软件将连续系统转化为离散系统 指令c2d(sys,f)。\n4-相图-相轨迹动态系统分析Phase Portrait爱情故事 相轨迹\n5-系统的可控性 讲解了对于状态空间表达的秩判据的相关内容。秩判据的相关数学证明: 另外讲解了定义的可控性是何种意义上的可控性。 6-李雅普诺夫稳定性 讲解了李雅普诺夫稳定性的严禁数学定义。以及对于状态转移矩阵A矩阵特征值的几种形式来定义李雅普诺夫的集中稳定性。 针对非线性系统，区别于传统解微分方程，采用李雅普诺夫第二法进行解决，在此处进行了简单的介绍。 7-线性控制器设计 这部分便是之前现代控制理论方面的根据期望的特征值来确定系统的不同k增益的输入。 令u=kx，对期望的$\\lambda$列出闭环矩阵Acl，对Acl求特征值?（应该是 太久远了 有点遗忘） 列出以$\\lambda$为未知量的方程，结合期望$\\lambda$的特征值方程对应相等。求得k矩阵。 8-LQR控制（Liner Quadratic Regulator） 线性二次型调节器。是一种对控制系统的目标$\\lambda$进行确定的最优控制算法。 其设置了一种惩罚函数J，通过求得MinJ来确定系统最优的$\\lambda$。进而进行线性控制器的设计。 9-状态观测器设计（Luenberger为例） LQR控制等线性控制u=-kx的前提是状态x全部可测。而对于状态不可测的系统需要观测器Observer 也是之前现代控制理论的必做题类型。观测器建立了一个新的反馈系统目标是使得观测值与实际值相差的err为0。 观测器也就是 根据系统现有的输入和输出 来估计系统的状态。 另外根据之前的阻尼器-弹簧-质量块经典系统进行了观测器设计，设定两个特征值期望为-1 -1。 Simulink仿真 观测器状态空间是目标$\\lambda$=-1 -1求解出来的。 Z2状态不可测，直接运行时，估计值与真实值完全重合。 在Z2hat估计值的地方对z2估计值进行赋初值为1的操作时，可以认为z2开始时估计值与真实值有了偏差。 此时，系统的输出图像有了偏差，z1与z2估计值有关，所以两个图像全部出现了偏差。且能够在后续过程中完成跟随观测。 10-可观测性与分离原理 12-非线性理论基础 \u0026hellip;.介绍了正定 半正定 负定 半负定的各种函数。 此处在设计Lyapunov函数的时候使用到了物理上的能量概念，动能与重力势能相结合搞出来了一个真正的能量函数V(x)\n13-不变性原理 对Lyapunov的稳定性判定分了很多的类，抽时间再整理一下。\n14-非线性稳定性设计 设计如下的非线性系统。 将三种u的处理方式整合成三个子系统。 1 直接线性化处理。 2 李雅普诺夫直接法设计 3 李雅普诺夫直接法直接消除非ND项。 设定仿真时间10s，x初始值为10； 输出状态变量为右图所示，输入为左图所示。 1黄色线条 直接线性化处理。 2橙色线条 李雅普诺夫直接法设计 3蓝色线条 李雅普诺夫直接法直接消除非ND项。 可以看到直接线性化处理的方式简单粗暴，因为输入存在x的三次方所以导致开始时输入值非常大。这是难以实现的。 对于李雅普诺夫直接法设计的输入以及输出较为合理。 李雅普诺夫分析后直接消除非ND项的做法较直接线性化处理有一定优势，但是稳态效果不好。\n15-非线性反步法设计-Important 反步法设计可以说是非线性链式系统的通用设计方法。 如下图，输入可以直接控制X2的状态，但是输入无法直接影响状态X1。 对两个引入的状态进行稳定性分析。 Dr.Can设计的Simulink仿真模型。 对例题进行分析 16-非线性自适应控制器 自认为的自适应控制器简化设计步骤： 自适应控制器是处理a参数未知的情况。通过设计一个估计值，再引入估计误差。 估计误差的导数因为a参数缓慢变化，所以a的导数为0。但是不禁让人思考a变化迅速的时候呢？ 对估计误差与原本控制误差进行联合Lyapunov稳定行为分析。设计u使得李函数的导数为ND。 在之前认为a参数已知的反馈线性化的设计过程中，把a换为a的估计值，带入到u中。\n处理联合的李函数，通过设计a的估计使得难以负定的项为0。得到a估计的导的Hope值。 此时把a积分，再带回反馈系统线性化设计的u。设计完成。 （貌似这些设计的步骤都是通用的，都类似反步法的设计步骤）\n此时联合李函数是NSD的。不能说a估计和e趋近于0，只能说他们是稳定的。 需要引入Lyapunov-like lemma。证明一下。\n参考DrCan以及其他学员分享的Simulink设计，设计如下的系统。 Xd改为变化量，a改为变化量。在k等于20的情况下跟踪性能也还行。\nk太小不行。k小的时候x根本无法完成跟踪。k必须很大才能很好的跟踪。 但是k太大的话会导致u变得十分的抽象，显然是难以实现u的输出 不符合实际工程的运用。 下图为k为20的跟踪情况，感觉已经非常不错了！ 下图为k为20的输入u的情况。可以看到已经有点抽象了，幅度跨度很大。也可能是我这个系统的a变化幅度太大，以及目标值太过苛刻。不知道实际工程中的使用情况是如何的？ 课后题：对经典弹簧系统进行非线性自适应控制器的设计 自己做的有点错误 标准答案如下图片 17-非线性鲁棒控制器 鲁棒控制相关可以看山东科技大学的周克敏教授视频：https://space.bilibili.com/615075414\n17-1 滑膜控制器 这里滑模控制的形式就是使得 $$ u=ke+\\dot{x}_d+\\rho \\frac{\\left| e \\right|}{e} $$ 而e的项是一个类似符号函数sgn(e)的东西。\n而$\\rho$是一个大于fx的绝对值的一个函数。 将u的形式代回到e导中，画出e和e导的状态图相轨迹。可以看到一个面-滑模面，系统状态就在这个面上趋近于0。 部分摘自：滑膜控制的简单理解-知乎 上图右侧是证明过程，在此用到了一个数学手法，对微分方程的不等式的证明，引入了一个松弛变量来变为等式。最终通过微分方程的通解的方式解出李函数在经过放缩，得出李函数小于某值。 接着将李函数反带回这个不等式，直接解出e的状态是小于xx值的，最后得出这个状态e是指数渐进稳定的。这个证明手法确实巧妙。\n17-2 其他两种鲁棒控制 高增益/高频 在Drcan的视频中解释鲁棒控制的u通式都是 $$ u=ke+\\dot{x}d+u{aux} $$ 其中$u_{aux}$是辅助用的。针对不同的鲁棒控制，仅仅是$u_{aux}$而已不同。 下图给出了其他两种鲁棒控制的$u_{aux}$形式。另外给出了证明过程。都是与滑膜的证明过程相似的过程。可以好好学习一下。 可以简单的理解 高增益控制方式就是使用足够大的输入去抵消不确定性。 而高频的控制方式就是滑膜的一种变式，通过设置参数使得其相较于滑模控制更为平和。 以下是对三种控制方式进行建模分析。对滑膜控制分一个子系统，对其他两种分别不同的参数大小分别设置4个子系统如下图： 运行结果：\n首先是四个系统的误差消除情况如下图：\n接着是四个系统的输入情况： 分析： 滑膜：输入极为抽象，控制效果中规中矩。 高增益0.1：输入在开始时很大，很抽象，但后续很平滑，收敛速度也最快。 高增益1：都差不多。 高频0.1：都差不多。 高频1：都差不多，收敛效果最差。\n","date":"2024-10-23T00:00:00Z","image":"https://a233a2.github.io/p/drcan-learn-blog-advance/1-1_hu598429424656775076.jpg","permalink":"https://a233a2.github.io/p/drcan-learn-blog-advance/","title":"DRCAN-Learn-Blog-Advance"},{"content":"此Blog记录了本人按照DRCAN视频推荐的学习顺序来系统学习DRCAN发表的控制相关视频。博客作为笔记使用。\n卷积定理 卷积操作\n$$L[{f(t)*g(t)}]=F(s)​G(s)$$\n拉普拉斯变换\n$$L{ f(t) } = F(s) = \\int_0^{\\infty} f(t) e^{-st} , dt$$\n卷积定理（拉普拉斯域）\n卷积定理指出，在时间域中两个函数的卷积，在拉普拉斯变换后相当于它们的拉普拉斯变换的乘积。\n如果$f(t)$和$g(t)$的拉氏变换分别为$F(s)$和$G(s)$,那么： $$ L[{f(t) ∗g(t)}] =F( s ) G( s) $$\n这意味着在时间域中复杂的卷积操作可以通过拉普拉斯变换简化为频域中的简单乘法。 这在处理线性时不变系统时非常有用，特别是当我们有系统的输入和系统的脉冲响应时， 利用卷积定理可以将输入信号和系统的响应进行频域分析。\n数学证明：\n拉普拉斯变换 ","date":"2024-10-23T00:00:00Z","permalink":"https://a233a2.github.io/p/drcan-learn-blog-basic/","title":"DRCAN-Learn-Blog-Basic"},{"content":"此Blog记录了本人按照DRCAN视频推荐的学习顺序来系统学习DRCAN发表的控制相关视频。博客作为笔记使用。\nLQR 线性二次型调节器，在Advance教程中有提及到。\nMPC ","date":"2024-10-23T00:00:00Z","permalink":"https://a233a2.github.io/p/drcan-learn-blog-opt/","title":"DRCAN-Learn-Blog-OPT"},{"content":"XTdrone仿真环境搭建 使用了XTdrone推荐的自动配置，开发环境是Ubuntu 22.04\n下午时花了两个小时手动配置没配置好，弄这种大工程还是得新系统比较好一点。\n另外作者太牛逼了\nhttps://www.yuque.com/xtdrone/manual_cn/install_scripts\n后续使用引言 打算在其之上二次开发PX4的程序。XTdrone提供了风场生成的插件。但是如何在PX4原版代码上修改是一个大问题。 为了简化可以搭载机载电脑，然后运行ROS系统，在ROS系统上检测风场并进行稳态控制。这是一个方法。但是无疑会造成设备增多，复杂度增加。\n","date":"2024-10-22T00:00:00Z","image":"https://a233a2.github.io/p/xtdrone%E4%BB%BF%E7%9C%9F%E7%8E%AF%E5%A2%83/%E9%85%8D%E7%BD%AE%E5%A5%BD%E7%9A%84%E5%9B%BE_hu10794010256599903806.jpg","permalink":"https://a233a2.github.io/p/xtdrone%E4%BB%BF%E7%9C%9F%E7%8E%AF%E5%A2%83/","title":"XTdrone仿真环境"},{"content":"对PX4官网的Github文件进行解析： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 1.ci： 这个目录通常包含与持续集成（CI）相关的配置文件，例如Jenkins、Travis CI或GitHub Actions的配置。它负责自动化编译、测试、部署等任务。 2.clusterfuzzlite： 用于与ClusterFuzzLite相关的配置文件，这是一种自动化模糊测试框架，帮助发现代码中的安全漏洞。 3.devcontainer： 包含VSCode开发容器的配置，用于在隔离的容器环境中开发PX4代码。方便开发人员在一致的开发环境中工作。 4.github： 包含GitHub的配置文件，如GitHub Actions、Issue模板和Pull Request模板，用于自动化流程和优化项目管理。 5.vscode： 包含Visual Studio Code的配置文件，定义了编译、调试和代码检查的工作流，以便开发人员在VSCode中更方便地开发PX4代码。 6.Documentation： 包含项目的文档文件，帮助开发者和用户了解如何使用、配置和开发PX4飞控系统。通常包括用户指南、API文档、教程等。 7.ROMFS： ROMFS是只读文件系统，通常用于存储PX4固件中的静态数据，如参数文件、启动脚本等。 8.Tools： 这个目录包含各种开发工具和脚本，常用于构建、测试、仿真和部署PX4代码。比如，可能包含用于自动化工具链配置的脚本。 9.boards： 包含与各种硬件平台（如飞控板、传感器等）相关的定义和配置文件。每种硬件的特定启动配置和硬件抽象层都位于该目录中。 10.cmake： 包含CMake构建系统的配置文件，用于定义如何编译PX4代码。CMake是一个跨平台的构建工具，管理依赖项和生成编译文件。 11.integrationtests/python_src/px4_it： 包含集成测试相关的Python脚本，主要用于自动化测试PX4的不同模块和功能，以确保系统的稳定性和正确性。 12.launch： 包含与ROS或仿真环境中的启动文件相关的配置，通常是用于启动PX4在仿真器或真实硬件上的配置文件。 13.msg： 包含与PX4通信协议（如MAVLink）相关的消息定义文件，用于定义飞控系统与外部系统（如地面站、传感器等）之间的消息格式。 14.platforms： 包含与不同硬件平台相关的底层代码和配置，如NuttX的初始化文件、硬件抽象层等。 15.posix-configs： 包含POSIX系统（如Linux）上的配置文件，通常用于定义在仿真环境中运行PX4的配置。 //16.src： 源代码目录，包含PX4的主要功能模块的实现代码，如飞行控制算法、传感器处理、姿态估计等。 17.srv： 服务定义文件，通常用于ROS系统中的服务（services），用于系统内不同节点之间的通信和请求/响应模式的交互。 18.test： 包含测试代码和测试框架，用于对PX4功能进行单元测试和集成测试，确保各个模块功能的正确性和健壮性。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 19.test_data： 包含测试所需的测试数据或测试脚本，用于集成测试和回归测试，以验证代码改动是否影响系统行为。 20.validation： 包含验证代码、数据或测试的文件，确保PX4的各个部分在特定条件下的表现符合预期。 21.clang-tidy： Clang-Tidy是一个C++代码分析工具，这个文件包含其配置，用于代码的静态分析，发现潜在的错误和优化点。 22.editorconfig： EditorConfig配置文件，用于定义代码格式的规则，如缩进、换行符、字符编码等，确保不同开发者之间代码风格的一致性。 23.gitattributes、.gitignore： 用于Git的配置文件。.gitattributes用于定义文件的特定处理方式，.gitignore则列出需要被Git忽略的文件和目录。 24.CMakeLists.txt： 这是CMake项目的核心配置文件，定义了如何编译整个PX4项目，包括源文件的路径、依赖项、编译选项等。 25.CODE_OF_CONDUCT.md： 项目的行为准则，规定了开发者在贡献代码和参与社区时需要遵守的行为规范。 26.CONTRIBUTING.md： 为开发者提供的贡献指南，解释了如何参与项目开发、提交代码和报告问题等流程。 27.CTestConfig.cmake： CMake的测试配置文件，定义了如何运行项目的测试，并收集测试结果。 28.Jenkinsfile： Jenkins持续集成系统的配置文件，定义了在Jenkins上自动化构建和测试的流水线。 29.Kconfig： 用于配置系统的文件，通常用于嵌入式系统中，定义了各个硬件模块或软件模块的配置选项。 30.LICENSE： 项目的开源许可证文件，说明了PX4的使用和分发权限。 31.Makefile： 传统的编译配置文件，定义了如何使用Make工具构建项目。对于不使用CMake的部分或平台，Makefile提供了另一种编译方式。 32.README.md： 项目的概述和基本介绍，通常包括如何编译、安装和使用PX4飞控系统的基本信息。 33.SECURITY.md： 有关安全漏洞报告和处理流程的文档，指导开发者如何报告和解决项目中的安全问题。 34.package.xml： 通常用于ROS包，定义了包的元数据，如依赖项、版本号和维护者信息。 SRC文件解析 1 2 3 4 5 6 7 8 9 10 11 12 13 1. src/modules/mc_att_control： 这个目录包含与多旋翼无人机姿态控制相关的代码。姿态控制的核心就是通过PID控制器来调节无人机的滚转、俯仰和偏航角的稳定性。 mc_att_control_main.cpp 是姿态控制的主要代码文件。 2. src/modules/mc_pos_control： 这个目录包含与多旋翼无人机位置控制相关的代码。PID控制器在此负责无人机的三维位置和高度控制。 mc_pos_control_main.cpp 是位置控制的核心实现文件，包含位置控制的PID逻辑。 3. src/lib/controllib： 这个目录下包含PX4的控制库，其中定义了PID控制器的通用实现。这里的文件用于多个模块的控制需求。 pid.cpp 是PID控制器的核心实现，定义了如何计算误差、比例项、积分项和微分项。 4. src/modules/fw_att_control 和 src/modules/fw_pos_control： 如果你关注的是固定翼无人机的PID控制，可以查看这两个目录。它们分别负责固定翼无人机的姿态控制和位置控制。 5. 参数文件 (ROMFS)： PID控制器的参数通常在参数文件中定义，可以通过修改这些参数调整控制器的性能。可以在 ROMFS/px4fmu_common/init.d 目录中找到默认的参数文件，里面会定义PID控制器的增益值（如P、I、D系数）。 NuttxRTOS 这应该是个很复杂的单片机实时系统。\nMAVLink协议 QGC地面站会通过MAVLink协议将QGC针对飞机的配置参数发送给飞控系统，而飞控系统则将这些参数存储在存储设备中。 暂时用不太上。\nQGC地面站试飞 在QGC地面站对PX4飞控进行调试试飞，开始时抖动剧烈，随着将速度环PID参数特别是D项降低后抖动变小。但是只能在高度模式稳定飞行，在自稳以及特技等模式均不稳定。 后续准备加入GPS自动飞行来测试稳定性。\n高度（Altitude）模式试飞视频 QGC地面站通信无线数传配置 数传模块使用了LQ的无线串口模块。将SH1.25-6Pin接口与XH2.54杜邦线进行连接后，使用绝缘胶布进行绝缘处理。将SH1.25-6Pin接入飞控的TELEM1口进行配置。 地面站中将TELEM1的波特率输出改为115200（LQ无线串口模块的BAUD），在QCG设置中添加一个数据连接接口。即可完成数传的配置。但是可能因为数据传输较大，距离在5m左右传输已经是极限了。\n对原有飞行模式修改与添加新的功能 1、PX4中的飞行模式主要定义文件： Commander模块（src/modules/commander）：\n主要负责飞行模式的管理和状态机控制。\ncommander.cpp：这是Commander模块的主文件，包含了飞行模式的状态机逻辑。commander_state.cpp：管理飞行模式的状态定义。\nFlight Mode Manager模块（src/modules/mc_pos_control 和 src/modules/fw_pos_control_l1）：\n多旋翼飞行器（mc_pos_control） 和 **固定翼飞行器（fw_pos_control_l1）**的飞行模式控制。\n在这些模块中，具体的飞行控制算法实现了如何根据不同的飞行模式，进行姿态、位置或速度控制。\n飞行模式的状态机逻辑位于commander.cpp文件中。它根据用户输入、飞行器状态和环境条件来决定当前飞行模式。你需要熟悉这些状态之间的切换条件以及各模式的具体功能实现。\n定义新的飞行模式： 在commander_state.h文件中，添加新的飞行模式枚举。例如，如果你要创建一个自定义的“智能悬停模式”： VEHICLE_MODE_FLAG_SMART_HOVER 实现飞行模式逻辑：\n在commander.cpp文件中，添加或修改相应的飞行模式逻辑。\n你可以参考已有的飞行模式（如POSCTL或ALTCTL）的实现方式，将自定义逻辑嵌入其中。比如，你可以根据条件判断激活智能悬停模式： if (user_input == CUSTOM_SMART_HOVER_CONDITION) { vehicle_status_s = VEHICLE_MODE_FLAG_SMART_HOVER; } 实现控制算法：\n根据自定义飞行模式的功能需求，你可能需要在姿态控制模块（mc_att_control）或位置控制模块（mc_pos_control）中添加自定义的控制算法。 可以根据飞行器当前的状态、位置、高度等数据来设计智能悬停的控制算法，使其在特定条件下表现出不同的控制行为。 测试飞行模式\n在模拟环境（如SITL）中对修改后的飞行模式进行测试。 确保飞行模式在不同情况下能够正确切换和响应用户输入。\nPixhawk 2.4.8 的接线 TELEM1/2 GPS接口的定义为 VCC TX RX TX1 RX1 GND\nI2C接口的定义为 VCC SDA SCL GND\n添加光流以及GPS模块的试飞 光流室内定点飞行测试：\n室外光流定点以及更换大机架大电机的飞行 更换了1.2m的大机架。然后电机采用的好盈H6M 130Kv 植保机用大功率电机。电池12s。 PID参数只是调小了一点，其余与小飞机一致。大飞机天生稳定一些。参数不太好调，所以先将就用下。 GPS室外定点飞行测试： 暂无，GPS一直没调通。不知道什么问题。可能是口烧了？或者是模块有问题，但是换了两个模块了。\n下次排除问题可以试试把GPS口换为TELEM口再试一下。这样可以确定口烧没。\n","date":"2024-10-15T00:00:00Z","image":"https://a233a2.github.io/p/px4%E9%A3%9E%E8%A1%8C%E6%8E%A7%E5%88%B6%E5%99%A8%E9%85%8D%E7%BD%AE%E6%97%A5%E5%BF%97px4-1%E5%9F%BA%E7%A1%80/fengmian_hu12044621347677834083.png","permalink":"https://a233a2.github.io/p/px4%E9%A3%9E%E8%A1%8C%E6%8E%A7%E5%88%B6%E5%99%A8%E9%85%8D%E7%BD%AE%E6%97%A5%E5%BF%97px4-1%E5%9F%BA%E7%A1%80/","title":"PX4飞行控制器配置日志PX4-1基础"},{"content":"Hugo博客的个人git部署工作流 自动部署BAT文件 (Auto Push) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 @echo off ::获取当前脚本路径 cd /d %~dp0 ::自动提交 git init git add . git commit -m \u0026#34;Auto Push:%date:~10%,time:~0,8%\u0026#34; :: git commit -m git push origin main -f @echo 已完成 SET daoTime=60 :dao set /a daoTime=daoTime-1 ping -n 2 -w 500 127.1\u0026gt; cls echo 上传git完成，倒计时退出：%daoTime%秒 if%daoTime%==0 (exit0) else (goto dao) Git合并分支(多端协作使用) 每次进行写博客时，都需要进行pull操作。\n1 2 git reset --hard //在需要合并的本地有修改导致冲突时 使用此语句。 git pull origin main 解决Push以及Pull超时错误的问题 方法：将代理端口与Git端口设置为一致即可\n本机代理设置如下所示：\n之后将Git配置为一致的端口号以及地址：\n1 2 git config --global http.proxy http://127.0.0.1:7890 git config --global https.proxy http://127.0.0.1:7890 2024-11-14错误记录 引用gif文件时，出现编译错误：配置项被弃用以及主题模板中可能存在的无限递归问题 使用到的引用格式：! [ASD] (ASD.GIF) 更换HTML标签渲染后问题解决。\n1 \u0026lt;img src=\u0026#34;路径/文件名.gif\u0026#34; alt=\u0026#34;描述文字\u0026#34; width=\u0026#34;500\u0026#34; height=\u0026#34;auto\u0026#34;\u0026gt; 分析：可能是这个主题不支持GIF？？？\n解决网站域名转发时自动部署删除CNAME文件的问题 在网站域名转发时，在github.io这个工程仓库下创建了CNAME文件，但是每次部署网站都会自动的删除掉。这使得我的网站无法打开。\n最后将CNAME文件放到了网站文件夹目录下的static文件下。重新上传后CNAME文件便一直都在了。\n","date":"2024-10-14T00:00:00Z","permalink":"https://a233a2.github.io/p/hugo%E5%8D%9A%E5%AE%A2%E7%9A%84%E4%B8%AA%E4%BA%BAgit%E9%83%A8%E7%BD%B2%E5%B7%A5%E4%BD%9C%E6%B5%81/","title":"Hugo博客的个人git部署工作流"},{"content":"PX4在Linux环境下的编译（make） 使用VM17虚拟机以及Ubuntu20.04对PX4项目进行编译。\n参考了超维空间科技的文章:超维空间科技的文章 后续配置参考了Xtdrone仿真平台的一键配置，更为简单:Xtdrone仿真平台文档\nGazebo配合QGC地面站仿真 Linux-QGC的安装： QGC官网指导下进行配置，之后下载AppImage文件运行QGC地面站即可。 仿真中：\n新建飞行任务AntiWindTask 按照PX4官方指导文档新建自己的一个飞行任务 官方新建任务指导\n最终参考了1.14版本的指导文件，一开始看的main指导文件去配置了XTdrone自动配置的1.13的PX4工程，发现在moduls文件下根本没有飞行任务配置。。。接着去使用1.15的PX4工程，但是在CMakeList文件中有所不同，在每一个版本中都有不同之处。1.15版本也会有bug存在。\n最后使用1.14版本，参考了1.14的指导文档，依然是CmakeList那里不对，文档中的放置位置在官方代码1.14.4版本中根本就没有。\n1.14.4版本中最后无奈我放到了一个差不多的位置。如下： 但是在进行FMU-V2构建烧录代码时也会一直出现bug如下，但是很奇怪使用PX4-SITL构建仿真时便没有错误出现，1.15也是如此： 最后在github工程发表了issues，最终我更换了FMU-V3来构建，这个错误便消除了。最终成功执行了任务。在QGC地面站也可以正常识别。\nNewFlightTask分析： 在指导文件中，其让我们修改了MPC_POS_MOD这个参数，很确定的是此参数决定了飞机在手动-Position定点飞行模式时要执行的实际代码中的任务模式。在源工程中有4中，但只能选择一种。 这也在侧面看出PX4的代码很庞大，实际运行只有那么一点。但是要真正简化这个系统也是很麻烦且没必要。\n指导文件默认的效果是控制台输出一段文字。然后实际飞机并不会升高。\nManual-Position飞行模式分析 下面以Manual-Position飞行模式为例子对PX4原有的飞行模式进行分析，以便我们写出自己的飞行模式。 但是在飞行模式中，可以看出并没有PID相关的直接控制。在这些控制代码中，更多的是作为一种高级控制。分析摇杆输入等混合输入，来对SetPoint进行赋值，分发给更底层的PID控制机构。\n四旋翼数学模型推导 ","date":"2024-10-10T00:00:00Z","image":"https://a233a2.github.io/fengmian.png","permalink":"https://a233a2.github.io/p/px4%E5%9C%A8ubuntu%E4%B8%8B%E7%9A%84%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%E4%BB%A5%E5%8F%8A%E5%8F%AF%E8%A7%86%E5%8C%96%E4%BB%BF%E7%9C%9F-2/","title":"PX4在Ubuntu下的二次开发以及可视化仿真-2"},{"content":"PX4在Linux环境下的编译（make） 使用VM17虚拟机以及Ubuntu20.04对PX4项目进行编译。\n参考了超维空间科技的文章:超维空间科技的文章 后续配置参考了Xtdrone仿真平台的一键配置，更为简单:Xtdrone仿真平台文档\nGazebo配合QGC地面站仿真 Linux-QGC的安装： QGC官网指导下进行配置，之后下载AppImage文件运行QGC地面站即可。 仿真中：\n新建飞行任务AntiWindTask 按照PX4官方指导文档新建自己的一个飞行任务 官方新建任务指导\n最终参考了1.14版本的指导文件，一开始看的main指导文件去配置了XTdrone自动配置的1.13的PX4工程，发现在moduls文件下根本没有飞行任务配置。。。接着去使用1.15的PX4工程，但是在CMakeList文件中有所不同，在每一个版本中都有不同之处。1.15版本也会有bug存在。\n最后使用1.14版本，参考了1.14的指导文档，依然是CmakeList那里不对，文档中的放置位置在官方代码1.14.4版本中根本就没有。\n1.14.4版本中最后无奈我放到了一个差不多的位置。如下： 但是在进行FMU-V2构建烧录代码时也会一直出现bug如下，但是很奇怪使用PX4-SITL构建仿真时便没有错误出现，1.15也是如此： 最后在github工程发表了issues，最终我更换了FMU-V3来构建，这个错误便消除了。最终成功执行了任务。在QGC地面站也可以正常识别。\nNewFlightTask分析： 在指导文件中，其让我们修改了MPC_POS_MOD这个参数，很确定的是此参数决定了飞机在手动-Position定点飞行模式时要执行的实际代码中的任务模式。在源工程中有4中，但只能选择一种。 这也在侧面看出PX4的代码很庞大，实际运行只有那么一点。但是要真正简化这个系统也是很麻烦且没必要。\n指导文件默认的效果是控制台输出一段文字。然后实际飞机并不会升高。\nManual-Position飞行模式分析 下面以Manual-Position飞行模式为例子对PX4原有的飞行模式进行分析，以便我们写出自己的飞行模式。 但是在飞行模式中，可以看出并没有PID相关的直接控制。在这些控制代码中，更多的是作为一种高级控制。分析摇杆输入等混合输入，来对SetPoint进行赋值，分发给更底层的PID控制机构。\n四旋翼数学模型推导 ","date":"2024-10-10T00:00:00Z","image":"https://a233a2.github.io/p/px4%E5%9C%A8ubuntu%E4%B8%8B%E7%9A%84%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%E4%BB%A5%E5%8F%8A%E5%8F%AF%E8%A7%86%E5%8C%96%E4%BB%BF%E7%9C%9Fpx4-2%E8%BF%9B%E9%98%B6/px4+gazebo_hu9112348299629346263.png","permalink":"https://a233a2.github.io/p/px4%E5%9C%A8ubuntu%E4%B8%8B%E7%9A%84%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%E4%BB%A5%E5%8F%8A%E5%8F%AF%E8%A7%86%E5%8C%96%E4%BB%BF%E7%9C%9Fpx4-2%E8%BF%9B%E9%98%B6/","title":"PX4在Ubuntu下的二次开发以及可视化仿真PX4-2进阶"},{"content":"变频器设计基础 https://www.bilibili.com/video/BV1jg41117Mz/?spm_id_from=333.788\u0026vd_source=c07e49f2b08d68d3bb624651ee908d97\n变频器就是可以改变交流电频率的一种装置，用它对交流电进行调速，就可以使得电机实现无级调速。\n我国交流电工频为50Hz，通过变频器可以对交流电进行从0到几千甚至上万Hz之间任意调整。\n主要对异步电机进行调速。\n异步电机 直流电机结构复杂，维护保养困难，在电力拖动系统中，需要转速一定，调速性能要求不高的情况下用的都是交流电机。\n交流电机没换向器 结构简单，维护方便，成本低。但是调速性能较差xxx特别差。\n交流异步电机同步转速（旋转磁场转速）$n_1$ 表示\n$$ n\u0026lt;n_1=\\frac{60f}{p} $$\n其中 $f$ 为交流电频率, $p$ 为电机的极对数。 $n$ 为电机的实际转速。\n转差率$s$的定义为\n$$ s=\\frac{n_1-n}{n_1}\\ \\ \\ \\left( 0\u0026lt;s\u0026lt;=1 \\right) $$\n电机转速的变式：\n$$ n=(1-s)n_1=\\frac{60f}{p} $$\n要改变电机的转速就只能在 $f$ $p$ $s$ 这三个方面想办法。\n变频器就是通过改变频率 $f$ 来对电机进行调速的器件。\n异步电动机的VF控制（开环控制简单粗暴） 单独改变频率是不行的 还需要同时对电压进行改变。\nV/f控制就是保证输出电压跟频率成正比的控制，使电动机的磁通保持一定，避免弱磁和磁饱和现象的产生，多用于风机、泵类节能型变频器用压控振荡器。\n解释：\n电机运行时自感电动势 $E$ $$E\\propto f\\varPhi $$\n$\\varPhi$为电机的磁通。\n电源电压$U$和自感电动势$E$在额定负载时差不多一致。\n定子电路简化图如下： r与x为漏磁阻抗。其之间的关系为：\n$$U= E+I(r+jx)$$\n额定频率时，漏磁阻抗上的电压很小。所以电源电压$U$和自感电动势$E$在额定负载时差不多一致。则可以得到：\n$$U\\propto f\\varPhi $$\n$$\\varPhi\\propto U/f $$ 所以可以得到电机的磁通，与电机电压成正比，与频率成反比关系。使用变频器时，使得频率降低，电压不变的话。则磁通会升高。磁通的增加会导致xxx\n磁化曲线：电机磁通大小与励磁电流的关系曲线。\n磁通增加会导致磁通到达B区域，使得电流波形尖锐。所以只变频不变压的话，电机磁通会增加，电机铁芯出现深度饱和。励磁电流急剧增加，使得电机损耗增加，可能出现电机过热烧毁。\n所以在改变频率时，必须保证磁通不变，为一个恒定值。\n$$\\varPhi\\propto U/f $$ 即保持电压和频率的比值不变。同步降低与升高。得到如下基本的UF曲线**。 而别忘了！ U是代替E而出现的。 在额定频率也就是曲线右上角一部分下，漏磁阻抗所占分压很少，所以U可以很近似E。但是在此点一下，即轻载或者空载条件下，低频区域U便不能再代替E了。 （反电动势E在电源电压U中所占比例变小了）。这时还按照这个曲线控制电机就不行了。因为 $$U= E+I(r+jx)$$\n$I(r+jx)$所占比例高了。不能再近似处理了 E小了很多。而我们还按照 $$\\varPhi\\propto U/f $$ 这时磁通会变小 因为实际是 ： $$\\varPhi\\propto E/f $$ 因此低频时，电机的转矩会变小！！\n这时需要对低频情况下的UF曲线进行补偿得到下图补偿uf曲线：\n通过改变UF比值来控制电机的方法就叫做变频器的V/F控制。UF曲线是依据负载特性 事先选定好的。\n直白点说，V／F控制其实就是开环控制，在这种模式下，变频器按照给定指令输出一定幅值和频率的电压，至于电机到底是运行多少转速、什么状态变频器是不关心的。因为变频器此时没有对电机的状态进行反馈及控制。 而矢量控制则不同，一般我们都是采用带转速反馈的矢量控制模式，这是一种真正意义上的闭环控制方式。在这种控制模式下，变频器对电机的运行转速进行精确控制，它会根据转速指令的大小实时控制电机实际转速。 V／F控制一般用于要求不太高的场合，对于电机转速控制精度没有什么要求的应用。而矢量控制是一种通用性极强的控制模式，几乎没有什么缺点，凡是要求控制精度较高时，用矢量控制肯定是没什么问题的。另外，尤其是提升应用时，尤其推荐带转速反馈的矢量控制模式。\n异步电动机矢量控制 ","date":"2024-10-10T00:00:00Z","permalink":"https://a233a2.github.io/p/%E5%8F%98%E9%A2%91%E5%99%A8%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80/","title":"变频器设计基础"},{"content":"FreeRTOS FreeRTOS在嵌入式的开发中十分的重要，本人之前对于同一时间进行多种任务的做法普遍都是设置定时器中断程序。这样做或许能解决燃眉之急，但是在大型项目中便有一些捉襟见肘，尤其是使用这种方式对于MCU的任务调度十分的不明确，显得十分的乱。故对于FreeRTOS这种MCU操作系统的应用便显得尤为重要。 官方文档：https://freertos.org/zh-cn-cmn-s/Documentation/00-Overview\nFreeRTOS核心机制 优先级调度 高优先级的准备就绪后，直接抢占CPU。\nFCFS(先来先服务)\n同优先级，按照准备就绪的先后顺序执行。\n时间片轮询\n有相同优先级的两个任务，其中一个一直没被抢占，则运行时间达到一个时间片则主动让出CPU。\nps：低优先级的任务对时间的控制较为不精确。高优先级的任务可以做到时间精确控制。\nFreeRTOS延时函数 vTaskDelay(ms);\n当前任务暂时暂停xx ms，程序进入阻塞态，其中暂时时间内可以执行其他任务。\nHAL_Delay(ms);\nCPU暂时挂起xx ms，啥也不执行。类似裸机运行时的delay。\nFreeRTOS的部署 ","date":"2024-09-18T00:00:00Z","permalink":"https://a233a2.github.io/p/freertos%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","title":"FreeRTOS学习笔记"},{"content":"ADRC课程笔记 本人对ADRC控制有着深厚的研究兴趣。在讨论研究韩京清先生的ADRC知识之前，我想先给不太专业的自己补习一些经典与现代控制理论方向的相关知识。\n生理前馈系统 在生理学上，前馈控制的例子是在实际体力活动之前，自主神经系统对心跳的正常预期调节。前馈控制可以比作对已知线索的预期反应（预测编码）。心跳的反馈调节为机体提供了进一步对运动的适应性。 \u0026ndash;wiki百科\n在前馈系统中，控制变量的调整不是以目标和回授之间的误差为基础，它是以过程数学模型的知识和过程扰动的知识或测量为基础。\n所以对于数学模型的整体掌握是对系统扰动进行前馈消除的前提。\n正所谓要想系统稳得住，必须得有前馈引入。前馈控制在某些控制场合下是必须项。\n前馈控制 摘自《高志强: 自抗扰控制思想探究》 前馈控制是一种基于对扰动的预测进行补偿的控制方法。它通过测量可能影响系统输出的扰动变量，并根据扰动变量与系统输出之间的关系，计算出所需的控制量，在扰动对系统产生影响之前就进行调节，以抵消扰动的影响。\n在自动控制系统理论中学习过，由传递函数理论数学推导，前馈的引入可以完全的消除系统的扰动误差。现在这显然并不是这么的简单，这需要对系统数学模型有着十分精确的掌握。\n前馈控制在工业界用途广泛, 但是学术界对它很少关心, 认为是开环控制, 没有什么理论可言. 前馈的使用方式主要有两种: 一种是根据参考输入和对象模型的逆而得到的控制量, 不依赖对象的实时信息,暂且称之为A类前馈; 另外一种前馈, 是根据被控量之外的对象信息所产生的控制量, 即B类前馈。\n前馈控制提出的本意是要区别于上面提到的狭义的反馈控制, 表示控制量的一部分甚至全部都可以完全独立于被控量的量测. Black定义的反馈(feedback)本来就是针对前馈(feedforward)而言的, 表示信号流向反转, 由输出到输入. 这里信号的走向一正一反, 概念很清楚。\n可是当反馈这个通讯工程的概念被借用到控制工程时, 它的反义词前馈的含义便有了两种解释. 比如上面说的A类前馈明显是开环控制, 控制量完全独立于对象的实时信息. 可是B类前馈则不然, 它依赖的还是对象信息, 实际上是前面提到的广义反馈, 只不过反馈的不是输出量而已. B类前馈在文献中也被称为扰动前馈, 它是基于对象扰动信息的实时提取, 就像指南车. 可是同样是基于对象信息的提取, 指南车为什么会被称为开环控制呢？其实B类前馈属于广义反馈, 不应称其为前馈或开环控制. 鉴于前馈的概念和用法前后重叠, 为了概念的清晰, 建议今后可把B类前馈归入抗扰原理讨论; 把前馈狭义地定义为A类前馈.那么这样的前馈有什么意义呢？为什么它的用途这么广呢？主要原因是它降低了快速跟踪的成本。\n一个控制系统要使输出迅速跟踪给定值有两个途径: 1) 高带宽; 2) 前馈. 但是在工业上, 带宽就是成本.高带宽虽然能使跟踪速度提高, 但也带来很多问题:1) 对执行机构的品质要求提高; 2) 激励了对象的高频动态使控制问题复杂化; 3) 闭环系统的稳定裕度下降,对相位滞后和时间延迟更敏感; 4) 对传感器噪声更敏感, 等等.高带宽的成本在20世 50年代就有专门、详细的讨论, 比如文献[46], 但是至今没能在理论界引起重视, 乃至高增益控制器、观测器的文章比比皆是, 而能用上的却寥寥无几. 这反映了不考虑成本的研究, 在工程上是没有多少意义的。\n工程师们在实践中基于对系统物理特性的知识发现了前馈这个办法. 这种独立于反馈回路拟合出的控制量通常是结合参考输入, 以数据或图表形式表示的,常常在控制信号中占主要部分. 同时也使用PID反馈控制器, 发挥微调、纠错的作用. 因此, 工业上的PID控制器常常是与前馈控制结合使用的。\n以上总结的是控制论的基本原理, 是从事自动控制的人们在长期的工程实践中发现、挖掘出来的, 是控制论继续发展的基石. 要系统地、科学地建立和发展一套完整的理论体系, 就需要对基本原理进行提炼、抽象和升华, 使得工程控制的实践能够更加系统,并不断进入更高的层次, 从而“下学而上达”。\n状态观测器 扩张状态观测器 ","date":"2024-09-16T00:00:00Z","permalink":"https://a233a2.github.io/p/adrc%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/","title":"ADRC课程笔记"},{"content":"KiCad学习日记 导出Gerber文件-JLC打样 1 导出Gerber的设置： 从b站搬运：https://www.bilibili.com/read/cv22773523/?spm_id_from=333.976.0.0 （KiCAD设计使用立创免费打样的方法及KiCAD插件） 生成gerber文件\n生成钻孔文件\n生成的gerber文件最终结构如下：\n2 修改Gerber文件使得可在JLC打样 创建两个文件 1 2 from .give_me_free_PCB import GiveMeFreePCB # Note the relative import! GiveMeFreePCB().register() # Instantiate and register to Pcbnew 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 import pcbnew import os import shutil import zipfile import datetime # 工程目录下Gerber和钻孔文件的存放位置 path_out = \u0026#34;out\u0026#34; # 下单用的文件的位置 path_final = \u0026#34;out/final\u0026#34; # 用于检查文件是否为Gerber文件以判断是否进行替换操作 file_filter = (\u0026#39;.gbl\u0026#39;,\u0026#39;.gbs\u0026#39;,\u0026#39;.gbp\u0026#39;,\u0026#39;.gbo\u0026#39;,\u0026#39;.gm1\u0026#39;,\u0026#39;gm13\u0026#39;, \u0026#39;.gtl\u0026#39;,\u0026#39;.gts\u0026#39;,\u0026#39;.gtp\u0026#39;,\u0026#39;.gto\u0026#39;,\u0026#39;.drl\u0026#39;,\u0026#39;.G1\u0026#39;, \u0026#39;.G2\u0026#39;,\u0026#39;.gko\u0026#39;) jlc_header=\u0026#34;\u0026#34;\u0026#34;G04 Layer: BottomSilkscreenLayer* G04 EasyEDA v6.5.25, 2023-03-20 21:11:36* **********************************至少这一行要换成自己的************************************ G04 Gerber Generator version 0.2* G04 Scale: 100 percent, Rotated: No, Reflected: No * G04 Dimensions in millimeters * G04 leading zeros omitted , absolute positions ,3 integer and 6 decimal *\\n\u0026#34;\u0026#34;\u0026#34; # 两张对应表，分别根据结尾和文件名来判断该给什么生成的文件什么名称 replace_list_end = [(\u0026#39;.gbl\u0026#39;,\u0026#34;Gerber_BottomLayer.GBL\u0026#34;), (\u0026#39;.gko\u0026#39;,\u0026#34;Gerber_BoardOutlineLayer.GKO\u0026#34;), (\u0026#39;.gbp\u0026#39;,\u0026#34;Gerber_BottomPasteMaskLayer.GBP\u0026#34;), (\u0026#39;.gbo\u0026#39;,\u0026#34;Gerber_BottomSilkscreenLayer.GBO\u0026#34;), (\u0026#39;.gbs\u0026#39;,\u0026#34;Gerber_BottomSolderMaskLayer.GBS\u0026#34;), (\u0026#39;.gtl\u0026#39;,\u0026#34;Gerber_TopLayer.GTL\u0026#34;), (\u0026#39;.gtp\u0026#39;,\u0026#34;Gerber_TopPasteMaskLayer.GTP\u0026#34;), (\u0026#39;.gto\u0026#39;,\u0026#34;Gerber_TopSilkscreenLayer.GTO\u0026#34;), (\u0026#39;.gts\u0026#39;,\u0026#34;Gerber_TopSolderMaskLayer.GTS\u0026#34;), (\u0026#39;.gd1\u0026#39;,\u0026#34;Drill_Through.GD1\u0026#34;), (\u0026#39;.gm1\u0026#39;,\u0026#34;Gerber_MechanicalLayer1.GM1\u0026#34;), (\u0026#39;.gm13\u0026#39;,\u0026#34;Gerber_MechanicalLayer13.GM13\u0026#34;)] replace_list_contain = [(\u0026#39;_PCB-PTH\u0026#39;, \u0026#34;Drill_PTH_Through.DRL\u0026#34;), (\u0026#39;_PCB-NPTH\u0026#39;, \u0026#34;Drill_NPTH_Through.DRL\u0026#34;), (\u0026#39;-PTH\u0026#39;, \u0026#34;Drill_PTH_Through.DRL\u0026#34;), (\u0026#39;-NPTH\u0026#39;, \u0026#34;Drill_NPTH_Through.DRL\u0026#34;), (\u0026#39;_PCB-In1_Cu\u0026#39;, \u0026#34;Gerber_InnerLayer1.G1\u0026#34;), (\u0026#39;_PCB-In2_Cu\u0026#39;, \u0026#34;Gerber_InnerLayer2.G2\u0026#34;), (\u0026#39;_PCB-Edge_Cuts\u0026#39;, \u0026#34;Gerber_BoardOutlineLayer.GKO\u0026#34;)] def zipFolder(folder_path, output_path): \u0026#34;\u0026#34;\u0026#34; 压缩指定路径下的文件夹 :param folder_path: 要压缩的文件夹路径 :param output_path: 压缩文件的输出路径 \u0026#34;\u0026#34;\u0026#34; with zipfile.ZipFile(output_path, \u0026#34;w\u0026#34;, zipfile.ZIP_DEFLATED) as zip: for root, dirs, files in os.walk(folder_path): for file in files: file_path = os.path.join(root, file) zip.write(file_path, os.path.relpath(file_path, folder_path)) # 读取Gerber文件和钻孔文件，修改名称并给Gerber文件内容添加识别头后写入到输出文件夹 def fileTransform(filename, path_out): # 按行读取文件内容 lines = open(filename).readlines() # 检查文件类型并给新文件取好相应的名称，写入识别头和原来的文件内容 hit_flag = 0 for replace_couple in replace_list_end: if filename.endswith(replace_couple[0]): file_new = open(path_out + \u0026#39;/\u0026#39; + replace_couple[1], \u0026#39;w\u0026#39;) hit_flag = 1 break if hit_flag == 0: for replace_couple in replace_list_contain: if filename.find(replace_couple[0]) != -1: file_new = open(path_out + \u0026#39;/\u0026#39; + replace_couple[1], \u0026#39;w\u0026#39;) hit_flag = 1 break if hit_flag == 1: hit_flag = 0 file_new.write(jlc_header) for line in lines: file_new.write(line) file_new.close() def pathInit(path_out): # 检查下目录是否存在，没有就创建 folder_out = os.path.exists(path_out) if not folder_out: os.makedirs(path_out) print(\u0026#34;Folder %s created!\u0026#34; % path_out) else: print(\u0026#34;Folder \\\u0026#34;%s\\\u0026#34; already exists!\u0026#34; % path_out) # 清空目录 for files in os.listdir(path_out): path = os.path.join(path_out, files) try: shutil.rmtree(path) except OSError: os.remove(path) print(\u0026#34;Folder \\\u0026#34;%s\\\u0026#34; clean!\u0026#34; % path_out) class GiveMeFreePCB(pcbnew.ActionPlugin): def defaults(self): self.name = \u0026#34;Give me free PCB!\u0026#34; self.category = \u0026#34;A descriptive category name\u0026#34; self.description = \u0026#34;A description of the plugin\u0026#34; self.show_toolbar_button = True # Optional, defaults to False self.icon_file_name = os.path.join(os.path.dirname(__file__), \u0026#39;icon.png\u0026#39;) # Optional # 关于路径，写的是处理工程目录下out目录里的文件， def Run(self): # 获取当前工程路径 path_workdir = os.environ.get(\u0026#39;KIPRJMOD\u0026#39;) # 把工程根目录设为工作目录 os.chdir(path_workdir) path_out_abs = os.path.join(os.getcwd(), path_out) pathInit(os.path.join(path_workdir, path_final)) file_count = 0 path_files = os.listdir(os.path.join(os.getcwd(), path_out)) # 遍历out目录下的文件，识别类型并进行相应的处理 for p in path_files: if(os.path.isfile(os.path.join(path_out_abs, p))): if(p.endswith(file_filter)): print(\u0026#34;Gerber file %s found.\u0026#34; % p) fileTransform(os.path.join(path_out_abs, p), os.path.join(os.getcwd(), path_final)) file_count += 1 timestamp = datetime.datetime.now().strftime(\u0026#39;%Y%m%d%H%M%S\u0026#39;) board = pcbnew.GetBoard() project_name = os.path.splitext(os.path.basename(board.GetFileName()))[0] zipFolder(path_out_abs + \u0026#39;/\u0026#39; + \u0026#34;final\u0026#34;, path_out_abs + \u0026#39;/\u0026#39; + \u0026#34;out_\u0026#34; + project_name + \u0026#39;-\u0026#39; + timestamp + \u0026#34;.zip\u0026#34;) # 打开资源管理器 os.system(\u0026#34;explorer.exe %s\u0026#34; % path_out_abs) 对源文件进行替换，把标*的行之上换为自己的工程的。\n在Kicad的脚本控制台中输入如下：来引入脚本 任意选择其中一个地址放入两个.py文件。之后点击工具-外部插件-刷新插件。出现新的插件即表示成功，注意文件编码为UTF-8，不然插件刷新不出来 输出时候需要输出Gerber的时候在路径那里敲个./out，不然找不到文件。\n然后点击插件即可输出JLC支持的Gerber文件！\n","date":"2024-09-16T00:00:00Z","permalink":"https://a233a2.github.io/p/kicad%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/","title":"KiCad学习日记"},{"content":"YSYX学习日记 学习记录： 学习记录。\nUbuntu安装 测试赛\n","date":"2024-09-16T00:00:00Z","permalink":"https://a233a2.github.io/p/ysyx%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/","title":"YSYX学习日记"},{"content":"臭猫FOC驱动器设计日志 主控芯片：WCH-CH32V307VCT6\n预驱芯片：EG2133\nMOS：NEC6050\n下载芯片：CH549G\n电流检测：INA240A2 2024-9-15 期待已久的FOC驱动器终于开工设计！设计完成PCB以及原理图。第一次设计双路的FOC驱动器，也是第一次是设计功率地与普通的GND隔离。\n另外就是电流检测芯片选择的是TI的INA240A2，有点难以购买qaq0.0每个芯片的价格在3元左右，属实有点成本爆炸。下次准备学习更换更为便宜的INA199或者其他国产方案。\n2024-9-17 计划物料到货开始焊接\n这板子有一些bug，就是CH549G下载电路的供电有些问题。在使用DC-12v供电测试的时候，CH549G下载电路的供电不稳定。 另外在开环测试的时候供电也不稳定。不知道是不是程序问题。 接下来抽时间对驱动器进行软件开发\n方波驱动测试 在每个换相周期内，定子绕组中的电流被切换为高或低两个状态，形成矩形波。通常采用六步换向法，即每60度电角度换相一次，从而产生转矩。\n开环FOC驱动测试 开环运行即根据系统时间为索引，根据时间固定生成三相的正弦波。需要涉及Clark变换以及Park变换。 simpleFOC的开环速度代码如下 参考了：https://github.com/haotianh9/DengFOC_on_STM32 电压控制\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 static inline uint32_t LL_SYSTICK_IsActiveCounterFlag(void) { return ((SysTick-\u0026gt;CTRL \u0026amp; SysTick_CTRL_COUNTFLAG_Msk) == (SysTick_CTRL_COUNTFLAG_Msk)); } uint32_t getCurrentMicros(void) { /* Ensure COUNTFLAG is reset by reading SysTick control and status register */ LL_SYSTICK_IsActiveCounterFlag(); uint32_t m = HAL_GetTick(); const uint32_t tms = SysTick-\u0026gt;LOAD + 1; __IO uint32_t u = tms - SysTick-\u0026gt;VAL; if (LL_SYSTICK_IsActiveCounterFlag()) { m = HAL_GetTick(); u = tms - SysTick-\u0026gt;VAL; } return (m * 1000 + (u * 1000) / tms); } //【应该是获取运行时间的代码段。】 float _electricalAngle(float shaft_angle, int pole_pairs) { return (shaft_angle * pole_pairs); } float _normalizeAngle(float angle){ float a = fmod(angle, 2*M_PI); //取余运算可以用于归一化，列出特殊值例子算便知 return a \u0026gt;= 0 ? a : (a + 2*M_PI); //三目运算符。格式：condition ? expr1 : expr2 //其中，condition 是要求值的条件表达式，如果条件成立，则返回 expr1 的值，否则返回 expr2 的值。 //可以将三目运算符视为 if-else 语句的简化形式。 //fmod 函数的余数的符号与除数相同。因此，当 angle 的值为负数时，余数的符号将与 _2M_PI 的符号相反。 //也就是说，如果 angle 的值小于 0 且 _2M_PI 的值为正数，则 fmod(angle, _2M_PI) 的余数将为负数。 //例如，当 angle 的值为 -M_PI/2，_2M_PI 的值为 2M_PI 时，fmod(angle, _2M_PI) 将返回一个负数。 //在这种情况下，可以通过将负数的余数加上 _2M_PI 来将角度归一化到 [0, 2M_PI] 的范围内，以确保角度的值始终为正数。 } void setPwm(float Ua, float Ub, float Uc) { //\t// 限制上限 Ua = _constrain(Ua, 0.0f, voltage_limit); Ub = _constrain(Ub, 0.0f, voltage_limit); Uc = _constrain(Uc, 0.0f, voltage_limit); // 计算占空比 // 限制占空比从0到1 dc_a = _constrain(Ua / voltage_power_supply, 0.0f , 1.0f ); dc_b = _constrain(Ub / voltage_power_supply, 0.0f , 1.0f ); dc_c = _constrain(Uc / voltage_power_supply, 0.0f , 1.0f ); //写入PWM到PWM 0 1 2 通道 TIM1-\u0026gt;CCR1 = (uint32_t) roundf(dc_a*period); TIM1-\u0026gt;CCR2 = (uint32_t) roundf(dc_b*period); TIM1-\u0026gt;CCR3 = (uint32_t) roundf(dc_c*period); } void setPhaseVoltage(float Uq,float Ud, float angle_el) { angle_el = _normalizeAngle(angle_el + zero_electric_angle); // 帕克逆变换 Ualpha = -Uq*sin(angle_el); Ubeta = Uq*cos(angle_el); // 克拉克逆变换 Ua = Ualpha + voltage_power_supply/2; Ub = (sqrt(3)*Ubeta-Ualpha)/2 + voltage_power_supply/2; Uc = (-Ualpha-sqrt(3)*Ubeta)/2 + voltage_power_supply/2; setPwm(Ua,Ub,Uc); } //开环速度函数 float velocityOpenloop(float target_velocity){ //\tuint32_t now_us = getCurrentMicros(); //\tuint32_t now_us = HAL_GetTick(); // Provides a tick value in microseconds. //计算当前每个Loop的运行时间间隔 // float Ts = (now_us - open_loop_timestamp) * 1e-3f; float Ts=5E-3f; // 通过乘以时间间隔和目标速度来计算需要转动的机械角度，存储在 shaft_angle 变量中。 //在此之前，还需要对轴角度进行归一化，以确保其值在 0 到 2π 之间。 shaft_angle = _normalizeAngle(shaft_angle + target_velocity*Ts); //以目标速度为 10 rad/s 为例，如果时间间隔是 1 秒，则在每个循环中需要增加 10 * 1 = 10 弧度的角度变化量，才能使电机转动到目标速度。 //如果时间间隔是 0.1 秒，那么在每个循环中需要增加的角度变化量就是 10 * 0.1 = 1 弧度，才能实现相同的目标速度。 //因此，电机轴的转动角度取决于目标速度和时间间隔的乘积。 // Uq is not related to voltage limit float Uq = 5.5; setPhaseVoltage(Uq, 0, _electricalAngle(shaft_angle, pole_pairs)); // open_loop_timestamp = now_us; //用于计算下一个时间间隔 return Uq; } 波形图根据上述代码来生成的话有些错误。这导致电机不能正确转动。而发出固定的啸叫。\n时间改为us后，波形图更加混乱。\n将时间的获取改为定时器中断+全局变量后。首先设置1us生成波形图如下：\n调整为200us时波形图如下：\n按理说这样运行开环已经可以完美运行，但是接入电脑5v-usb供电的时候电机依然跳动+啸叫。\n接入正常12v电源供电时，板子直接没了反应。。可能是设计的电源出现了问题。将电压降低到5v后板子可以正常上电启动，但是无法正常运行，整体是一种上电运行后，电机转动力巨大，然后系统死机重启陷入了死循环。\n电源设计还是不太过关。。。而且设计的有些混乱。。计划下一板改进，但是这种工程耗费时间太大了，下次进行工程实现之前应该提前做好功课。\nAS5600磁编码器电机底板 2024-9-18 PCB刚刚到货，准备抽时间进行焊接。再一次把CM_FOC的串口通信部分焊接完成，方便查看波形等。 SH1.25的接口画错了，属实是大意了。飞线暂时解决了问题。 AS5600磁编码器数据读取 AS5600是12位的霍尔磁编码器，它的地址是0x36，只需要读取0x0C、0x0D这两个寄存器就可以读出角度的原始数据，再将其乘以360，再除以4096，就可以获得角度值。\n鸽了一段时间，等忙完就马上开始测试。在此之前还需要把电源修好、、、、悲\n","date":"2024-09-15T00:00:00Z","image":"https://a233a2.github.io/p/cm_foc%E9%A9%B1%E5%8A%A8%E5%99%A8/cm_foc_real2_hu6122318150598922774.png","permalink":"https://a233a2.github.io/p/cm_foc%E9%A9%B1%E5%8A%A8%E5%99%A8/","title":"CM_FOC驱动器"},{"content":" ","date":"2024-09-14T22:20:23+08:00","permalink":"https://a233a2.github.io/p/%E4%B8%AA%E4%BA%BA%E8%AE%B0/","title":"个人记"},{"content":"CH32平衡车开发板设计 主控芯片：CH32V307VCT6 电机驱动：TB6612方案 下载芯片：CH549G 开源链接：https://github.com/a233a2/CH32_DC_BalanceCar\nPID平衡部分计划使用两种方案进行对比 1 pid_1.c文件 即不通过控制角度来确定速度，通过将直立环PID的目标设为重力0点，来维持平衡，之后通过速度环调速。 2 pid.c文件 通过控制角度来确定速度，速度环输出目标速度下的应得角度，直立环与速度环串级，直立环负责达到对应角度。\n某些地方还并不完善，比如PID参数方面还不尽完美。在之后我将从算法方面对其进行优化。从数学角度找找这两种方案的不同之处。\n测试 新设备推送设置\n","date":"2024-07-15T00:00:00Z","image":"https://a233a2.github.io/p/ch32%E5%B9%B3%E8%A1%A1%E8%BD%A6%E5%BC%80%E5%8F%91%E6%9D%BF/mainboard_hu12999563082775535449.JPG","permalink":"https://a233a2.github.io/p/ch32%E5%B9%B3%E8%A1%A1%E8%BD%A6%E5%BC%80%E5%8F%91%E6%9D%BF/","title":"CH32平衡车开发板"}]