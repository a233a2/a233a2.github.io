<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>学术类别 on sunjiyi&#39;s Blogggg</title>
        <link>https://a233a2.github.io/categories/%E5%AD%A6%E6%9C%AF%E7%B1%BB%E5%88%AB/</link>
        <description>Recent content in 学术类别 on sunjiyi&#39;s Blogggg</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <copyright>Sunjiyi Make and Design</copyright>
        <lastBuildDate>Wed, 23 Oct 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://a233a2.github.io/categories/%E5%AD%A6%E6%9C%AF%E7%B1%BB%E5%88%AB/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>DRCAN-Learn-Blog-Advance</title>
        <link>https://a233a2.github.io/p/drcan-learn-blog-advance/</link>
        <pubDate>Wed, 23 Oct 2024 00:00:00 +0000</pubDate>
        
        <guid>https://a233a2.github.io/p/drcan-learn-blog-advance/</guid>
        <description>&lt;p&gt;此Blog记录了本人按照DRCAN视频推荐的学习顺序来系统学习DRCAN发表的控制相关视频。博客作为笔记使用。&lt;/p&gt;
&lt;h3 id=&#34;1-状态空间表达&#34;&gt;1-状态空间表达
&lt;/h3&gt;&lt;p&gt;以一个质量块-弹簧-阻尼器系统来进行分析：&lt;br&gt;
&lt;img src=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/1-1.jpg&#34;
	width=&#34;2182&#34;
	height=&#34;3086&#34;
	srcset=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/1-1_hu7229884839809532162.jpg 480w, https://a233a2.github.io/p/drcan-learn-blog-advance/1-1_hu1691059223504960444.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;1&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;70&#34;
		data-flex-basis=&#34;169px&#34;
	
&gt;   &lt;br&gt;
状态空间表达是即为：&lt;strong&gt;系统输入输出状态变量的一个集合，用一阶微分方程的形式表达出来。&lt;/strong&gt;
&lt;img src=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/1-2.png&#34;
	width=&#34;2182&#34;
	height=&#34;1753&#34;
	srcset=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/1-2_hu1484246055524713960.png 480w, https://a233a2.github.io/p/drcan-learn-blog-advance/1-2_hu12410177076624011512.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;2&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;124&#34;
		data-flex-basis=&#34;298px&#34;
	
&gt;
状态空间表达与传递函数之间的关系：包括转换方程，以及重要结论：&lt;strong&gt;|SI-A|矩阵的特征值就是传递函数的极点！&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;2-状态空间方程的解&#34;&gt;2-状态空间方程的解
&lt;/h3&gt;&lt;p&gt;有点难以推导且认为推导过程不太重要&lt;br&gt;
&lt;img src=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/21.png&#34;
	width=&#34;2182&#34;
	height=&#34;3086&#34;
	srcset=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/21_hu9857301536328584946.png 480w, https://a233a2.github.io/p/drcan-learn-blog-advance/21_hu17728875442273112032.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;2&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;70&#34;
		data-flex-basis=&#34;169px&#34;
	
&gt;&lt;br&gt;
&lt;img src=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/22.png&#34;
	width=&#34;2182&#34;
	height=&#34;3086&#34;
	srcset=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/22_hu7424707334767718386.png 480w, https://a233a2.github.io/p/drcan-learn-blog-advance/22_hu4360937834505168880.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;2&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;70&#34;
		data-flex-basis=&#34;169px&#34;
	
&gt;&lt;br&gt;
&lt;img src=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/23.png&#34;
	width=&#34;2182&#34;
	height=&#34;3086&#34;
	srcset=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/23_hu17122972239720574622.png 480w, https://a233a2.github.io/p/drcan-learn-blog-advance/23_hu13650029549609199388.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;2&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;70&#34;
		data-flex-basis=&#34;169px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;3-相图-相轨迹&#34;&gt;3-相图-相轨迹
&lt;/h3&gt;&lt;p&gt;相轨迹是系统的状态随时间变化的轨迹。当时间变化时，系统的状态点在状态空间中移动，这条移动的轨迹就是相轨迹。&lt;/p&gt;
&lt;p&gt;对于一个阻尼摆，系统的能量会逐渐衰减，最终趋于静止。其相轨迹不会形成闭合的曲线，而是一个逐渐收缩的螺旋，最终收敛到平衡点（摆静止的位置）。这说明系统是稳定的，且有能量损失。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/31.png&#34;
	width=&#34;2182&#34;
	height=&#34;3086&#34;
	srcset=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/31_hu425951968313780383.png 480w, https://a233a2.github.io/p/drcan-learn-blog-advance/31_hu16643900213948508456.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;2&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;70&#34;
		data-flex-basis=&#34;169px&#34;
	
&gt;&lt;br&gt;
可以通过分析导数正负来判别该点的稳定性，后面结论重要一些。&lt;br&gt;
&lt;img src=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/32.png&#34;
	width=&#34;2201&#34;
	height=&#34;1299&#34;
	srcset=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/32_hu1485192269137500098.png 480w, https://a233a2.github.io/p/drcan-learn-blog-advance/32_hu9250088313912901889.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;2&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;169&#34;
		data-flex-basis=&#34;406px&#34;
	
&gt;&lt;br&gt;
特殊的一种鞍点。在此令了上述x与y的导来确定x的输出？这个有些复杂。应该是用到了线性代数的坐标变换 看不太懂。。看特征值直观点。 &lt;br&gt;
&lt;img src=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/33.png&#34;
	width=&#34;2039&#34;
	height=&#34;973&#34;
	srcset=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/33_hu10825206731962301851.png 480w, https://a233a2.github.io/p/drcan-learn-blog-advance/33_hu10146504456115275453.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;2&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;209&#34;
		data-flex-basis=&#34;502px&#34;
	
&gt;&lt;br&gt;
对于复数的，而实部为0的特征值。是一个椭圆，Fixed Point为Center。 &lt;br&gt;
&lt;img src=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/34.png&#34;
	width=&#34;2176&#34;
	height=&#34;891&#34;
	srcset=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/34_hu6089759772534058434.png 480w, https://a233a2.github.io/p/drcan-learn-blog-advance/34_hu14925947017838707856.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;2&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;244&#34;
		data-flex-basis=&#34;586px&#34;
	
&gt;&lt;br&gt;
特征值复数但是实部不为0的时候。 &lt;br&gt;
&lt;img src=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/35.png&#34;
	width=&#34;2154&#34;
	height=&#34;1163&#34;
	srcset=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/35_hu16777777308420433622.png 480w, https://a233a2.github.io/p/drcan-learn-blog-advance/35_hu7477347720013798291.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;2&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;185&#34;
		data-flex-basis=&#34;444px&#34;
	
&gt;&lt;br&gt;
总结上述情况。&lt;/p&gt;
&lt;h3 id=&#34;35-连续系统的离散化&#34;&gt;3.5-连续系统的离散化
&lt;/h3&gt;&lt;p&gt;采样频率至少要为原系统频率的两倍，这样才能重建出原信号。否则可能出现混叠现象，不能复现原系统变化趋势。（2倍只是下限理论值，实际工程中选取5-10倍） &lt;br&gt;
Zero Order Hold （ZOH零阶保持器），使得控制量在一个控制周期内保持不变。&lt;/p&gt;
&lt;p&gt;采样周期要与数据处理控制时间相匹配。若数据读入处理需要50ms，则小于50ms的采样周期将变得没有意义。 &lt;br&gt;
&lt;img src=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/3.5-1.png&#34;
	width=&#34;1874&#34;
	height=&#34;1214&#34;
	srcset=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/3.5-1_hu3054599139696670051.png 480w, https://a233a2.github.io/p/drcan-learn-blog-advance/3.5-1_hu17887664043837265195.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;2&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;154&#34;
		data-flex-basis=&#34;370px&#34;
	
&gt;&lt;br&gt;
Error   ：G(T) = ∫(0,T) exp(Aτ) dτ·B
状态空间的解输出，在离散系统下的表达形式。离散系统下不关心t，而着重与每个周期。系统输入u在一个周期内可以看作一个常数（ZOH的作用）。所以可以提取出来。。&lt;/p&gt;
&lt;p&gt;使用软件将连续系统转化为离散系统 指令&lt;strong&gt;c2d(sys,f)&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;4-相图-相轨迹动态系统分析phase-portrait爱情故事&#34;&gt;4-相图-相轨迹动态系统分析Phase Portrait爱情故事
&lt;/h3&gt;&lt;p&gt;相轨迹&lt;/p&gt;
&lt;h3 id=&#34;5-系统的可控性&#34;&gt;5-系统的可控性
&lt;/h3&gt;&lt;p&gt;讲解了对于状态空间表达的秩判据的相关内容。秩判据的相关数学证明: &lt;br&gt;
另外讲解了定义的可控性是何种意义上的可控性。 &lt;br&gt;
&lt;img src=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/51.jpg&#34;
	width=&#34;2182&#34;
	height=&#34;2569&#34;
	srcset=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/51_hu14473934175636827000.jpg 480w, https://a233a2.github.io/p/drcan-learn-blog-advance/51_hu1429475142258959569.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;2&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;84&#34;
		data-flex-basis=&#34;203px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;6-李雅普诺夫稳定性&#34;&gt;6-李雅普诺夫稳定性
&lt;/h3&gt;&lt;p&gt;讲解了李雅普诺夫稳定性的严禁数学定义。以及对于状态转移矩阵A矩阵特征值的几种形式来定义李雅普诺夫的集中稳定性。 &lt;br&gt;
针对非线性系统，区别于传统解微分方程，采用李雅普诺夫第二法进行解决，在此处进行了简单的介绍。 &lt;br&gt;
&lt;img src=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/61.jpg&#34;
	width=&#34;2182&#34;
	height=&#34;3086&#34;
	srcset=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/61_hu5641696737157067.jpg 480w, https://a233a2.github.io/p/drcan-learn-blog-advance/61_hu2161642686435310383.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;2&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;70&#34;
		data-flex-basis=&#34;169px&#34;
	
&gt;&lt;br&gt;
&lt;img src=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/62.jpg&#34;
	width=&#34;2182&#34;
	height=&#34;1475&#34;
	srcset=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/62_hu8693756144219456126.jpg 480w, https://a233a2.github.io/p/drcan-learn-blog-advance/62_hu16010987264924604746.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;2&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;147&#34;
		data-flex-basis=&#34;355px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;7-线性控制器设计&#34;&gt;7-线性控制器设计
&lt;/h3&gt;&lt;p&gt;这部分便是之前现代控制理论方面的根据期望的特征值来确定系统的不同k增益的输入。
令u=kx，对期望的$\lambda$列出闭环矩阵Acl，对Acl求特征值?（应该是 太久远了 有点遗忘）
列出以$\lambda$为未知量的方程，结合期望$\lambda$的特征值方程对应相等。求得k矩阵。
&lt;img src=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/71.jpg&#34;
	width=&#34;2182&#34;
	height=&#34;3086&#34;
	srcset=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/71_hu12605214141889279940.jpg 480w, https://a233a2.github.io/p/drcan-learn-blog-advance/71_hu13337817652409191429.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;2&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;70&#34;
		data-flex-basis=&#34;169px&#34;
	
&gt; &lt;br&gt;
&lt;img src=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/72.jpg&#34;
	width=&#34;2182&#34;
	height=&#34;2716&#34;
	srcset=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/72_hu14034203957898177910.jpg 480w, https://a233a2.github.io/p/drcan-learn-blog-advance/72_hu13401945833860414619.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;2&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;80&#34;
		data-flex-basis=&#34;192px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;8-lqr控制liner-quadratic-regulator&#34;&gt;8-LQR控制（Liner Quadratic Regulator）
&lt;/h3&gt;&lt;p&gt;线性二次型调节器。是一种对控制系统的目标$\lambda$进行确定的最优控制算法。 &lt;br&gt;
其设置了一种惩罚函数J，通过求得MinJ来确定系统最优的$\lambda$。进而进行线性控制器的设计。
&lt;img src=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/81.jpg&#34;
	width=&#34;2182&#34;
	height=&#34;1475&#34;
	srcset=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/81_hu16155908660427802456.jpg 480w, https://a233a2.github.io/p/drcan-learn-blog-advance/81_hu303810490908243574.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;2&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;147&#34;
		data-flex-basis=&#34;355px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;9-状态观测器设计luenberger为例&#34;&gt;9-状态观测器设计（Luenberger为例）
&lt;/h3&gt;&lt;p&gt;LQR控制等线性控制u=-kx的前提是状态x全部可测。而对于状态不可测的系统需要观测器Observer &lt;br&gt;
也是之前现代控制理论的必做题类型。观测器建立了一个新的反馈系统目标是使得观测值与实际值相差的err为0.   &lt;br&gt;
观测器也就是 根据系统现有的输入和输出 来估计系统的状态。 &lt;br&gt;
&lt;img src=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/91.jpg&#34;
	width=&#34;2182&#34;
	height=&#34;3086&#34;
	srcset=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/91_hu17671702461150397579.jpg 480w, https://a233a2.github.io/p/drcan-learn-blog-advance/91_hu3864620464621549933.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;2&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;70&#34;
		data-flex-basis=&#34;169px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;另外根据之前的阻尼器-弹簧-质量块经典系统进行了观测器设计，设定两个特征值期望为-1 -1. &lt;br&gt;
&lt;img src=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/92.jpg&#34;
	width=&#34;2182&#34;
	height=&#34;2448&#34;
	srcset=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/92_hu1447313957454599147.jpg 480w, https://a233a2.github.io/p/drcan-learn-blog-advance/92_hu10687051141730272077.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;2&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;89&#34;
		data-flex-basis=&#34;213px&#34;
	
&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>DRCAN-Learn-Blog-Basic</title>
        <link>https://a233a2.github.io/p/drcan-learn-blog-basic/</link>
        <pubDate>Wed, 23 Oct 2024 00:00:00 +0000</pubDate>
        
        <guid>https://a233a2.github.io/p/drcan-learn-blog-basic/</guid>
        <description>&lt;p&gt;此Blog记录了本人按照DRCAN视频推荐的学习顺序来系统学习DRCAN发表的控制相关视频。博客作为笔记使用。&lt;/p&gt;
&lt;h3 id=&#34;卷积定理&#34;&gt;卷积定理
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;卷积操作&lt;br&gt;
$$L[{f(t)*g(t)}]=F(s)​G(s)$$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;拉普拉斯变换&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;$$L{ f(t) } = F(s) = \int_0^{\infty} f(t) e^{-st} , dt$$&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;卷积定理（拉普拉斯域）&lt;br&gt;
卷积定理指出，在时间域中两个函数的卷积，在拉普拉斯变换后相当于它们的拉普拉斯变换的乘积。&lt;br&gt;
如果$f(t)$和$g(t)$的拉氏变换分别为$F(s)$和$G(s)$,那么：&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;$$ L[{f(t) ∗g(t)}] =F( s ) G( s) $$&lt;/p&gt;
&lt;p&gt;这意味着在时间域中复杂的卷积操作可以通过拉普拉斯变换简化为频域中的简单乘法。
这在处理线性时不变系统时非常有用，特别是当我们&lt;strong&gt;有系统的输入和系统的脉冲响应时，
利用卷积定理可以将输入信号和系统的响应进行频域分析。&lt;/strong&gt;&lt;br&gt;
数学证明：&lt;br&gt;
&lt;img src=&#34;https://a233a2.github.io/p/drcan-learn-blog-basic/%E5%8D%B7%E7%A7%AF%E5%AE%9A%E7%90%86%E6%95%B0%E5%AD%A6%E8%AF%81%E6%98%8E.jpg&#34;
	width=&#34;1079&#34;
	height=&#34;1527&#34;
	srcset=&#34;https://a233a2.github.io/p/drcan-learn-blog-basic/%E5%8D%B7%E7%A7%AF%E5%AE%9A%E7%90%86%E6%95%B0%E5%AD%A6%E8%AF%81%E6%98%8E_hu12515043388887547171.jpg 480w, https://a233a2.github.io/p/drcan-learn-blog-basic/%E5%8D%B7%E7%A7%AF%E5%AE%9A%E7%90%86%E6%95%B0%E5%AD%A6%E8%AF%81%E6%98%8E_hu3113174287893646857.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;设置1&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;70&#34;
		data-flex-basis=&#34;169px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;拉普拉斯变换&#34;&gt;拉普拉斯变换
&lt;/h3&gt;</description>
        </item>
        <item>
        <title>DRCAN-Learn-Blog-OPT</title>
        <link>https://a233a2.github.io/p/drcan-learn-blog-opt/</link>
        <pubDate>Wed, 23 Oct 2024 00:00:00 +0000</pubDate>
        
        <guid>https://a233a2.github.io/p/drcan-learn-blog-opt/</guid>
        <description>&lt;p&gt;此Blog记录了本人按照DRCAN视频推荐的学习顺序来系统学习DRCAN发表的控制相关视频。博客作为笔记使用。&lt;/p&gt;
&lt;h3 id=&#34;lqr&#34;&gt;LQR
&lt;/h3&gt;&lt;h3 id=&#34;mpc&#34;&gt;MPC
&lt;/h3&gt;</description>
        </item>
        <item>
        <title>XTdrone仿真环境</title>
        <link>https://a233a2.github.io/p/xtdrone%E4%BB%BF%E7%9C%9F%E7%8E%AF%E5%A2%83/</link>
        <pubDate>Tue, 22 Oct 2024 00:00:00 +0000</pubDate>
        
        <guid>https://a233a2.github.io/p/xtdrone%E4%BB%BF%E7%9C%9F%E7%8E%AF%E5%A2%83/</guid>
        <description>&lt;h3 id=&#34;xtdrone仿真环境搭建&#34;&gt;XTdrone仿真环境搭建
&lt;/h3&gt;&lt;p&gt;使用了XTdrone推荐的自动配置，开发环境是Ubuntu 22.04&lt;br&gt;
下午时花了两个小时手动配置没配置好，弄这种大工程还是得新系统比较好一点。&lt;br&gt;
&lt;img src=&#34;https://a233a2.github.io/p/xtdrone%E4%BB%BF%E7%9C%9F%E7%8E%AF%E5%A2%83/%E9%85%8D%E7%BD%AE%E5%A5%BD%E7%9A%84%E5%9B%BE.jpg&#34;
	width=&#34;1920&#34;
	height=&#34;1080&#34;
	srcset=&#34;https://a233a2.github.io/p/xtdrone%E4%BB%BF%E7%9C%9F%E7%8E%AF%E5%A2%83/%E9%85%8D%E7%BD%AE%E5%A5%BD%E7%9A%84%E5%9B%BE_hu18099202995669554499.jpg 480w, https://a233a2.github.io/p/xtdrone%E4%BB%BF%E7%9C%9F%E7%8E%AF%E5%A2%83/%E9%85%8D%E7%BD%AE%E5%A5%BD%E7%9A%84%E5%9B%BE_hu2642333738181242516.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;111&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;177&#34;
		data-flex-basis=&#34;426px&#34;
	
&gt;&lt;br&gt;
另外作者太牛逼了&lt;br&gt;
&lt;a class=&#34;link&#34; href=&#34;https://www.yuque.com/xtdrone/manual_cn/install_scripts&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.yuque.com/xtdrone/manual_cn/install_scripts&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;后续使用引言&#34;&gt;后续使用引言
&lt;/h3&gt;&lt;p&gt;打算在其之上二次开发PX4的程序。XTdrone提供了风场生成的插件。但是如何在PX4原版代码上修改是一个大问题。  &lt;br&gt;
为了简化可以搭载机载电脑，然后运行ROS系统，在ROS系统上检测风场并进行稳态控制。这是一个方法。但是无疑会造成设备增多，复杂度增加。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>PX4二次开发以及仿真PX4-2</title>
        <link>https://a233a2.github.io/p/px4%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%E4%BB%A5%E5%8F%8A%E4%BB%BF%E7%9C%9Fpx4-2/</link>
        <pubDate>Thu, 10 Oct 2024 00:00:00 +0000</pubDate>
        
        <guid>https://a233a2.github.io/p/px4%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%E4%BB%A5%E5%8F%8A%E4%BB%BF%E7%9C%9Fpx4-2/</guid>
        <description>&lt;h3 id=&#34;px4在linux环境下的编译make&#34;&gt;PX4在Linux环境下的编译（make）
&lt;/h3&gt;&lt;p&gt;使用VM17虚拟机以及Ubuntu20.04对PX4项目进行编译。&lt;br&gt;
参考了超维空间科技的文章：https://blog.csdn.net/qq_38768959/article/details/106041494&lt;/p&gt;
&lt;h3 id=&#34;gazebo配合qgc地面站仿真&#34;&gt;Gazebo配合QGC地面站仿真
&lt;/h3&gt;&lt;h4 id=&#34;linux-qgc的安装&#34;&gt;Linux-QGC的安装：
&lt;/h4&gt;&lt;p&gt;QGC官网指导下进行配置，之后下载AppImage文件运行QGC地面站即可。 &lt;br&gt;
仿真中：&lt;br&gt;
&lt;img src=&#34;https://a233a2.github.io/p/px4%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%E4%BB%A5%E5%8F%8A%E4%BB%BF%E7%9C%9Fpx4-2/px4&amp;#43;gazebo.png&#34;
	width=&#34;2560&#34;
	height=&#34;1549&#34;
	srcset=&#34;https://a233a2.github.io/p/px4%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%E4%BB%A5%E5%8F%8A%E4%BB%BF%E7%9C%9Fpx4-2/px4&amp;#43;gazebo_hu16359290037193365331.png 480w, https://a233a2.github.io/p/px4%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%E4%BB%A5%E5%8F%8A%E4%BB%BF%E7%9C%9Fpx4-2/px4&amp;#43;gazebo_hu11163092954185164344.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;PX4工程文件1&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;165&#34;
		data-flex-basis=&#34;396px&#34;
	
&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>PX4飞行控制器开发日志PX4-1</title>
        <link>https://a233a2.github.io/p/px4%E9%A3%9E%E8%A1%8C%E6%8E%A7%E5%88%B6%E5%99%A8%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97px4-1/</link>
        <pubDate>Thu, 10 Oct 2024 00:00:00 +0000</pubDate>
        
        <guid>https://a233a2.github.io/p/px4%E9%A3%9E%E8%A1%8C%E6%8E%A7%E5%88%B6%E5%99%A8%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97px4-1/</guid>
        <description>&lt;p&gt;先对PX4官网的Github文件进行解析：
&lt;img src=&#34;https://a233a2.github.io/p/px4%E9%A3%9E%E8%A1%8C%E6%8E%A7%E5%88%B6%E5%99%A8%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97px4-1/px4_1.png&#34;
	width=&#34;991&#34;
	height=&#34;875&#34;
	srcset=&#34;https://a233a2.github.io/p/px4%E9%A3%9E%E8%A1%8C%E6%8E%A7%E5%88%B6%E5%99%A8%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97px4-1/px4_1_hu10673573407330660024.png 480w, https://a233a2.github.io/p/px4%E9%A3%9E%E8%A1%8C%E6%8E%A7%E5%88%B6%E5%99%A8%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97px4-1/px4_1_hu2873010366182178476.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;PX4工程文件1&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;113&#34;
		data-flex-basis=&#34;271px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;1.ci：
这个目录通常包含与持续集成（CI）相关的配置文件，例如Jenkins、Travis CI或GitHub Actions的配置。它负责自动化编译、测试、部署等任务。&lt;/p&gt;
&lt;p&gt;2.clusterfuzzlite：
用于与ClusterFuzzLite相关的配置文件，这是一种自动化模糊测试框架，帮助发现代码中的安全漏洞。&lt;/p&gt;
&lt;p&gt;3.devcontainer：
包含VSCode开发容器的配置，用于在隔离的容器环境中开发PX4代码。方便开发人员在一致的开发环境中工作。&lt;/p&gt;
&lt;p&gt;4.github：
包含GitHub的配置文件，如GitHub Actions、Issue模板和Pull Request模板，用于自动化流程和优化项目管理。&lt;/p&gt;
&lt;p&gt;5.vscode：
包含Visual Studio Code的配置文件，定义了编译、调试和代码检查的工作流，以便开发人员在VSCode中更方便地开发PX4代码。&lt;/p&gt;
&lt;p&gt;6.Documentation：
包含项目的文档文件，帮助开发者和用户了解如何使用、配置和开发PX4飞控系统。通常包括用户指南、API文档、教程等。&lt;/p&gt;
&lt;p&gt;7.ROMFS：
ROMFS是只读文件系统，通常用于存储PX4固件中的静态数据，如参数文件、启动脚本等。&lt;/p&gt;
&lt;p&gt;8.Tools：
这个目录包含各种开发工具和脚本，常用于构建、测试、仿真和部署PX4代码。比如，可能包含用于自动化工具链配置的脚本。&lt;/p&gt;
&lt;p&gt;9.boards：
包含与各种硬件平台（如飞控板、传感器等）相关的定义和配置文件。每种硬件的特定启动配置和硬件抽象层都位于该目录中。&lt;/p&gt;
&lt;p&gt;10.cmake：
包含CMake构建系统的配置文件，用于定义如何编译PX4代码。CMake是一个跨平台的构建工具，管理依赖项和生成编译文件。&lt;/p&gt;
&lt;p&gt;11.integrationtests/python_src/px4_it：
包含集成测试相关的Python脚本，主要用于自动化测试PX4的不同模块和功能，以确保系统的稳定性和正确性。&lt;/p&gt;
&lt;p&gt;12.launch：
包含与ROS或仿真环境中的启动文件相关的配置，通常是用于启动PX4在仿真器或真实硬件上的配置文件。&lt;/p&gt;
&lt;p&gt;13.msg：
包含与PX4通信协议（如MAVLink）相关的消息定义文件，用于定义飞控系统与外部系统（如地面站、传感器等）之间的消息格式。&lt;/p&gt;
&lt;p&gt;14.platforms：
包含与不同硬件平台相关的底层代码和配置，如NuttX的初始化文件、硬件抽象层等。&lt;/p&gt;
&lt;p&gt;15.posix-configs：
包含POSIX系统（如Linux）上的配置文件，通常用于定义在仿真环境中运行PX4的配置。&lt;/p&gt;
&lt;p&gt;//16.src：
源代码目录，包含PX4的主要功能模块的实现代码，如飞行控制算法、传感器处理、姿态估计等。&lt;/p&gt;
&lt;p&gt;17.srv：
服务定义文件，通常用于ROS系统中的服务（services），用于系统内不同节点之间的通信和请求/响应模式的交互。&lt;/p&gt;
&lt;p&gt;18.test：
包含测试代码和测试框架，用于对PX4功能进行单元测试和集成测试，确保各个模块功能的正确性和健壮性。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://a233a2.github.io/p/px4%E9%A3%9E%E8%A1%8C%E6%8E%A7%E5%88%B6%E5%99%A8%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97px4-1/px4_2.png&#34;
	width=&#34;997&#34;
	height=&#34;816&#34;
	srcset=&#34;https://a233a2.github.io/p/px4%E9%A3%9E%E8%A1%8C%E6%8E%A7%E5%88%B6%E5%99%A8%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97px4-1/px4_2_hu5588688417697814020.png 480w, https://a233a2.github.io/p/px4%E9%A3%9E%E8%A1%8C%E6%8E%A7%E5%88%B6%E5%99%A8%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97px4-1/px4_2_hu15962098568375647639.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;PX4工程文件2&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;122&#34;
		data-flex-basis=&#34;293px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;19.test_data：
包含测试所需的测试数据或测试脚本，用于集成测试和回归测试，以验证代码改动是否影响系统行为。&lt;/p&gt;
&lt;p&gt;20.validation：
包含验证代码、数据或测试的文件，确保PX4的各个部分在特定条件下的表现符合预期。&lt;/p&gt;
&lt;p&gt;21.clang-tidy：
Clang-Tidy是一个C++代码分析工具，这个文件包含其配置，用于代码的静态分析，发现潜在的错误和优化点。&lt;/p&gt;
&lt;p&gt;22.editorconfig：
EditorConfig配置文件，用于定义代码格式的规则，如缩进、换行符、字符编码等，确保不同开发者之间代码风格的一致性。&lt;/p&gt;
&lt;p&gt;23.gitattributes、.gitignore：
用于Git的配置文件。.gitattributes用于定义文件的特定处理方式，.gitignore则列出需要被Git忽略的文件和目录。&lt;/p&gt;
&lt;p&gt;24.CMakeLists.txt：
这是CMake项目的核心配置文件，定义了如何编译整个PX4项目，包括源文件的路径、依赖项、编译选项等。&lt;/p&gt;
&lt;p&gt;25.CODE_OF_CONDUCT.md：
项目的行为准则，规定了开发者在贡献代码和参与社区时需要遵守的行为规范。&lt;/p&gt;
&lt;p&gt;26.CONTRIBUTING.md：
为开发者提供的贡献指南，解释了如何参与项目开发、提交代码和报告问题等流程。&lt;/p&gt;
&lt;p&gt;27.CTestConfig.cmake：
CMake的测试配置文件，定义了如何运行项目的测试，并收集测试结果。&lt;/p&gt;
&lt;p&gt;28.Jenkinsfile：
Jenkins持续集成系统的配置文件，定义了在Jenkins上自动化构建和测试的流水线。&lt;/p&gt;
&lt;p&gt;29.Kconfig：
用于配置系统的文件，通常用于嵌入式系统中，定义了各个硬件模块或软件模块的配置选项。&lt;/p&gt;
&lt;p&gt;30.LICENSE：
项目的开源许可证文件，说明了PX4的使用和分发权限。&lt;/p&gt;
&lt;p&gt;31.Makefile：
传统的编译配置文件，定义了如何使用Make工具构建项目。对于不使用CMake的部分或平台，Makefile提供了另一种编译方式。&lt;/p&gt;
&lt;p&gt;32.README.md：
项目的概述和基本介绍，通常包括如何编译、安装和使用PX4飞控系统的基本信息。&lt;/p&gt;
&lt;p&gt;33.SECURITY.md：
有关安全漏洞报告和处理流程的文档，指导开发者如何报告和解决项目中的安全问题。&lt;/p&gt;
&lt;p&gt;34.package.xml：
通常用于ROS包，定义了包的元数据，如依赖项、版本号和维护者信息。&lt;/p&gt;
&lt;h3 id=&#34;src文件解析&#34;&gt;SRC文件解析
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;src/modules/mc_att_control：
这个目录包含与多旋翼无人机姿态控制相关的代码。姿态控制的核心就是通过PID控制器来调节无人机的滚转、俯仰和偏航角的稳定性。
mc_att_control_main.cpp 是姿态控制的主要代码文件。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;src/modules/mc_pos_control：
这个目录包含与多旋翼无人机位置控制相关的代码。PID控制器在此负责无人机的三维位置和高度控制。
mc_pos_control_main.cpp 是位置控制的核心实现文件，包含位置控制的PID逻辑。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;src/lib/controllib：
这个目录下包含PX4的控制库，其中定义了PID控制器的通用实现。这里的文件用于多个模块的控制需求。
pid.cpp 是PID控制器的核心实现，定义了如何计算误差、比例项、积分项和微分项。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;src/modules/fw_att_control 和 src/modules/fw_pos_control：
如果你关注的是固定翼无人机的PID控制，可以查看这两个目录。它们分别负责固定翼无人机的姿态控制和位置控制。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;参数文件 (ROMFS)：
PID控制器的参数通常在参数文件中定义，可以通过修改这些参数调整控制器的性能。可以在 ROMFS/px4fmu_common/init.d 目录中找到默认的参数文件，里面会定义PID控制器的增益值（如P、I、D系数）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;nuttxrtos&#34;&gt;NuttxRTOS
&lt;/h3&gt;&lt;p&gt;这应该是个很复杂的单片机实时系统。&lt;/p&gt;
&lt;h3 id=&#34;mavlink协议&#34;&gt;MAVLink协议
&lt;/h3&gt;&lt;p&gt;QGC地面站会通过MAVLink协议将QGC针对飞机的配置参数发送给飞控系统，而飞控系统则将这些参数存储在存储设备中。
暂时用不太上。&lt;/p&gt;
&lt;h3 id=&#34;qgc地面站试飞&#34;&gt;QGC地面站试飞
&lt;/h3&gt;&lt;p&gt;在QGC地面站对PX4飞控进行调试试飞，开始时抖动剧烈，随着将速度环PID参数特别是D项降低后抖动变小。但是只能在高度模式稳定飞行，在自稳以及特技等模式均不稳定。
后续准备加入GPS自动飞行来测试稳定性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;高度（Altitude）模式试飞视频&lt;/strong&gt;
&lt;video src=&#34;试飞.mp4&#34;  poster=&#34;试飞图.png&#34; width=&#34;848px&#34; height=&#34;480px&#34;   controls=&#34;controls&#34;&gt;&lt;/video&gt;&lt;/p&gt;
&lt;h4 id=&#34;qgc地面站通信无线数传配置&#34;&gt;QGC地面站通信无线数传配置
&lt;/h4&gt;&lt;p&gt;数传模块使用了LQ的无线串口模块。将SH1.25-6Pin接口与XH2.54杜邦线进行连接后，使用绝缘胶布进行绝缘处理。将SH1.25-6Pin接入飞控的TELEM1口进行配置。
地面站中将TELEM1的波特率输出改为115200（LQ无线串口模块的BAUD），在QCG设置中添加一个数据连接接口。即可完成数传的配置。但是可能因为数据传输较大，距离在5m左右传输已经是极限了。&lt;/p&gt;
&lt;h3 id=&#34;对原有飞行模式修改与添加新的功能&#34;&gt;对原有飞行模式修改与添加新的功能
&lt;/h3&gt;&lt;h4 id=&#34;1px4中的飞行模式主要定义文件&#34;&gt;1、PX4中的飞行模式主要定义文件：
&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;Commander模块（src/modules/commander）：&lt;/strong&gt;&lt;br&gt;
主要负责飞行模式的管理和状态机控制。&lt;br&gt;
commander.cpp：这是Commander模块的主文件，包含了飞行模式的&lt;strong&gt;状态机&lt;/strong&gt;逻辑。commander_state.cpp：管理飞行模式的状态定义。&lt;br&gt;
&lt;strong&gt;Flight Mode Manager模块（src/modules/mc_pos_control 和 src/modules/fw_pos_control_l1）：&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;多旋翼飞行器（mc_pos_control）&lt;/strong&gt; 和 **固定翼飞行器（fw_pos_control_l1）**的飞行模式控制。&lt;br&gt;
在这些模块中，具体的飞行控制算法实现了如何根据不同的飞行模式，进行姿态、位置或速度控制。&lt;/p&gt;
&lt;p&gt;飞行模式的状态机逻辑位于commander.cpp文件中。它根据用户输入、飞行器状态和环境条件来决定当前飞行模式。你需要熟悉这些状态之间的切换条件以及各模式的具体功能实现。&lt;/p&gt;
&lt;h3 id=&#34;定义新的飞行模式&#34;&gt;定义新的飞行模式：
&lt;/h3&gt;&lt;p&gt;在commander_state.h文件中，添加新的飞行模式枚举。例如，如果你要创建一个自定义的“智能悬停模式”：
VEHICLE_MODE_FLAG_SMART_HOVER
&lt;strong&gt;实现飞行模式逻辑：&lt;/strong&gt;&lt;br&gt;
在commander.cpp文件中，添加或修改相应的飞行模式逻辑。&lt;br&gt;
你可以参考已有的飞行模式（如POSCTL或ALTCTL）的实现方式，将自定义逻辑嵌入其中。比如，你可以根据条件判断激活智能悬停模式： &lt;br&gt;
&lt;code&gt;    if (user_input == CUSTOM_SMART_HOVER_CONDITION) {   vehicle_status_s = VEHICLE_MODE_FLAG_SMART_HOVER;   }     &lt;/code&gt; &lt;br&gt;
&lt;strong&gt;实现控制算法：&lt;/strong&gt;&lt;br&gt;
根据自定义飞行模式的功能需求，你可能需要在姿态控制模块（mc_att_control）或位置控制模块（mc_pos_control）中添加自定义的控制算法。
可以根据飞行器当前的状态、位置、高度等数据来设计智能悬停的控制算法，使其在特定条件下表现出不同的控制行为。 &lt;br&gt;
&lt;strong&gt;测试飞行模式&lt;/strong&gt;&lt;br&gt;
在模拟环境（如SITL）中对修改后的飞行模式进行测试。   确保飞行模式在不同情况下能够正确切换和响应用户输入。&lt;/p&gt;
&lt;h3 id=&#34;pixhawk-248-的接线&#34;&gt;Pixhawk 2.4.8 的接线
&lt;/h3&gt;&lt;p&gt;TELEM1/2 GPS接口的定义为 VCC TX RX TX1 RX1 GND&lt;br&gt;
I2C接口的定义为 VCC SDA SCL GND&lt;/p&gt;
&lt;h3 id=&#34;添加光流以及gps模块的试飞&#34;&gt;添加光流以及GPS模块的试飞
&lt;/h3&gt;&lt;p&gt;光流室内定点飞行测试：&lt;br&gt;
&lt;video src=&#34;试飞2.mp4&#34;  poster=&#34;试飞图.png&#34; width=&#34;848px&#34; height=&#34;480px&#34;   controls=&#34;controls&#34;&gt;&lt;/video&gt;&lt;/p&gt;
&lt;h3 id=&#34;室外光流定点以及更换大机架大电机的飞行&#34;&gt;室外光流定点以及更换大机架大电机的飞行
&lt;/h3&gt;&lt;p&gt;更换了1.2m的大机架。然后电机采用的好盈H6M 130Kv 植保机用大功率电机。电池12s。 &lt;br&gt;
PID参数只是调小了一点，其余与小飞机一致。大飞机天生稳定一些。参数不太好调，所以先将就用下。  &lt;br&gt;
&lt;video src=&#34;试飞3.mp4&#34;  poster=&#34;试飞图.png&#34; width=&#34;848px&#34; height=&#34;480px&#34;   controls=&#34;controls&#34;&gt;&lt;/video&gt;&lt;/p&gt;
&lt;h3 id=&#34;gps室外定点飞行测试&#34;&gt;GPS室外定点飞行测试：
&lt;/h3&gt;&lt;p&gt;暂无，GPS一直没调通。不知道什么问题。可能是口烧了？或者是模块有问题，但是换了两个模块了。&lt;br&gt;
下次排除问题可以试试把GPS口换为TELEM口再试一下。这样可以确定口烧没。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>ADRC课程笔记</title>
        <link>https://a233a2.github.io/p/adrc%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/</link>
        <pubDate>Mon, 16 Sep 2024 00:00:00 +0000</pubDate>
        
        <guid>https://a233a2.github.io/p/adrc%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/</guid>
        <description>&lt;h3 id=&#34;adrc课程笔记&#34;&gt;ADRC课程笔记
&lt;/h3&gt;&lt;p&gt;本人对ADRC控制有着深厚的研究兴趣。在讨论研究韩京清先生的ADRC知识之前，我想先给不太专业的自己补习一些经典与现代控制理论方向的相关知识。&lt;/p&gt;
&lt;h4 id=&#34;生理前馈系统&#34;&gt;生理前馈系统
&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;在生理学上，前馈控制的例子是在实际体力活动之前，自主神经系统对心跳的正常预期调节。前馈控制可以比作对已知线索的预期反应（预测编码）。心跳的反馈调节为机体提供了进一步对运动的适应性。  &amp;ndash;wiki百科&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在前馈系统中，控制变量的调整不是以目标和回授之间的误差为基础，它是以过程&lt;strong&gt;数学模型&lt;/strong&gt;的知识和&lt;strong&gt;过程扰动&lt;/strong&gt;的知识或测量为基础。&lt;/p&gt;
&lt;p&gt;所以对于数学模型的整体掌握是对系统扰动进行前馈消除的前提。&lt;/p&gt;
&lt;p&gt;正所谓要想系统稳得住，必须得有前馈引入。前馈控制在某些控制场合下是必须项。&lt;/p&gt;
&lt;h3 id=&#34;前馈控制&#34;&gt;前馈控制
&lt;/h3&gt;&lt;h6 id=&#34;摘自高志强-自抗扰控制思想探究&#34;&gt;摘自《高志强: 自抗扰控制思想探究》
&lt;/h6&gt;&lt;p&gt;前馈控制是一种&lt;strong&gt;基于对扰动的预测&lt;/strong&gt;进行补偿的控制方法。它通过&lt;strong&gt;测量&lt;/strong&gt;可能影响系统输出的扰动变量，并根据扰动变量与系统输出之间的关系，计算出所需的控制量，在&lt;strong&gt;扰动对系统产生影响之前&lt;/strong&gt;就进行调节，以抵消扰动的影响。&lt;br&gt;
在自动控制系统理论中学习过，由传递函数理论数学推导，前馈的引入可以完全的消除系统的扰动误差。现在这显然并不是这么的简单，这需要对系统数学模型有着十分精确的掌握。&lt;br&gt;
前馈控制在工业界用途广泛, 但是学术界对它很少关心, 认为是开环控制, 没有什么理论可言. 前馈的使用方式主要有两种: 一种是&lt;strong&gt;根据参考输入和对象模型的逆&lt;/strong&gt;而得到的控制量, 不依赖对象的实时信息,暂且称之为A类前馈; 另外一种前馈, 是&lt;strong&gt;根据被控量之外的对象信息&lt;/strong&gt;所产生的控制量, 即B类前馈。&lt;br&gt;
前馈控制提出的本意是要区别于上面提到的狭义的反馈控制, 表示控制量的一部分甚至全部都可以完全独立于被控量的量测. Black定义的反馈(feedback)本来就是针对前馈(feedforward)而言的, 表示信号流向反转, 由输出到输入. 这里信号的走向一正一反, 概念很清楚。&lt;br&gt;
可是当反馈这个通讯工程的概念被借用到控制工程时, 它的反义词前馈的含义便有了两种解释. 比如上面说的A类前馈明显是开环控制, 控制量完全独立于对象的实时信息. 可是B类前馈则不然, 它依赖的还是对象信息, 实际上是前面提到的广义反馈, 只不过反馈的不是输出量而已. B类前馈在文献中也被称为扰动前馈, 它是基于对象扰动信息的实时提取, 就像指南车. 可是同样是基于对象信息的提取, 指南车为什么会被称为开环控制呢？其实B类前馈属于广义反馈, 不应称其为前馈或开环控制. 鉴于前馈的概念和用法前后重叠, 为了概念的清晰, 建议今后可把B类前馈归入抗扰原理讨论; 把前馈狭义地定义为A类前馈.那么这样的前馈有什么意义呢？为什么它的用途这么广呢？主要原因是它降低了快速跟踪的成本。&lt;br&gt;
一个控制系统要使输出迅速跟踪给定值有两个途径: 1) 高带宽; 2) 前馈. 但是在工业上, 带宽就是成本.高带宽虽然能使跟踪速度提高, 但也带来很多问题:1) 对执行机构的品质要求提高; 2) 激励了对象的高频动态使控制问题复杂化; 3) 闭环系统的稳定裕度下降,对相位滞后和时间延迟更敏感; 4) 对传感器噪声更敏感, 等等.高带宽的成本在20世 50年代就有专门、详细的讨论, 比如文献[46], 但是至今没能在理论界引起重视, 乃至高增益控制器、观测器的文章比比皆是, 而能用上的却寥寥无几. 这反映了不考虑成本的研究, 在工程上是没有多少意义的。&lt;br&gt;
工程师们在实践中基于对系统物理特性的知识发现了前馈这个办法. 这种独立于反馈回路拟合出的控制量通常是结合参考输入, 以数据或图表形式表示的,常常在控制信号中占主要部分. 同时也使用PID反馈控制器, 发挥微调、纠错的作用. 因此, 工业上的PID控制器常常是与前馈控制结合使用的。&lt;br&gt;
以上总结的是控制论的基本原理, 是从事自动控制的人们在长期的工程实践中发现、挖掘出来的, 是控制论继续发展的基石. 要系统地、科学地建立和发展一套完整的理论体系, 就需要对基本原理进行提炼、抽象和升华, 使得工程控制的实践能够更加系统,并不断进入更高的层次, 从而“下学而上达”。&lt;/p&gt;
&lt;h3 id=&#34;状态观测器&#34;&gt;状态观测器
&lt;/h3&gt;&lt;h3 id=&#34;扩张状态观测器&#34;&gt;扩张状态观测器
&lt;/h3&gt;</description>
        </item>
        <item>
        <title>YSYX学习日记</title>
        <link>https://a233a2.github.io/p/ysyx%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/</link>
        <pubDate>Mon, 16 Sep 2024 00:00:00 +0000</pubDate>
        
        <guid>https://a233a2.github.io/p/ysyx%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/</guid>
        <description>&lt;h3 id=&#34;ysyx学习日记&#34;&gt;YSYX学习日记
&lt;/h3&gt;&lt;p&gt;学习记录： &lt;a class=&#34;link&#34; href=&#34;https://docs.qq.com/sheet/DQ0lRY2tNb2VIZWVB?newPad=1&amp;amp;newPadType=clone&amp;amp;tab=BB08J4&amp;amp;_t=1728471922939&amp;amp;u=555637143d844e0f8b3d1a7c9c34bebf&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;学习记录&lt;/a&gt;。&lt;/p&gt;
&lt;h4 id=&#34;ubuntu安装&#34;&gt;Ubuntu安装
&lt;/h4&gt;&lt;p&gt;测试赛&lt;/p&gt;
</description>
        </item>
        <item>
        <title>分数阶数学控制</title>
        <link>https://a233a2.github.io/p/%E5%88%86%E6%95%B0%E9%98%B6%E6%95%B0%E5%AD%A6%E6%8E%A7%E5%88%B6/</link>
        <pubDate>Mon, 16 Sep 2024 00:00:00 +0000</pubDate>
        
        <guid>https://a233a2.github.io/p/%E5%88%86%E6%95%B0%E9%98%B6%E6%95%B0%E5%AD%A6%E6%8E%A7%E5%88%B6/</guid>
        <description>&lt;h3 id=&#34;分数阶数学控制&#34;&gt;分数阶数学控制
&lt;/h3&gt;&lt;p&gt;ARDC课程上得到了有关于在分数阶下控制的相关知识，得知其是因为传统的整数阶控制存在一定的信息丢失。使得控制精度在某些场合不尽理想，所以近现代诞生出分数阶控制的相关理论研究。&lt;br&gt;
巧合的是，分数阶微分的英文缩写居然是FOC！(Fractional Calculus)&lt;br&gt;
测试&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
