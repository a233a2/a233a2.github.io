<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>学术类别 on sunjiyi&#39;s Blogggg</title>
        <link>https://a233a2.github.io/categories/%E5%AD%A6%E6%9C%AF%E7%B1%BB%E5%88%AB/</link>
        <description>Recent content in 学术类别 on sunjiyi&#39;s Blogggg</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <copyright>Sunjiyi Make and Design</copyright>
        <lastBuildDate>Fri, 08 Nov 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://a233a2.github.io/categories/%E5%AD%A6%E6%9C%AF%E7%B1%BB%E5%88%AB/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>算法挖坑填坑</title>
        <link>https://a233a2.github.io/p/%E7%AE%97%E6%B3%95%E6%8C%96%E5%9D%91%E5%A1%AB%E5%9D%91/</link>
        <pubDate>Fri, 08 Nov 2024 00:00:00 +0000</pubDate>
        
        <guid>https://a233a2.github.io/p/%E7%AE%97%E6%B3%95%E6%8C%96%E5%9D%91%E5%A1%AB%E5%9D%91/</guid>
        <description>&lt;h3 id=&#34;卡尔曼滤波算法&#34;&gt;卡尔曼滤波算法
&lt;/h3&gt;&lt;h3 id=&#34;扩展卡尔曼滤波算法ekf&#34;&gt;扩展卡尔曼滤波算法（EKF）
&lt;/h3&gt;&lt;h3 id=&#34;傅里叶变换&#34;&gt;傅里叶变换
&lt;/h3&gt;&lt;h3 id=&#34;快速傅里叶变换法&#34;&gt;快速傅里叶变换法
&lt;/h3&gt;&lt;h3 id=&#34;反步法&#34;&gt;反步法
&lt;/h3&gt;&lt;h3 id=&#34;滑膜算法&#34;&gt;滑膜算法
&lt;/h3&gt;&lt;h3 id=&#34;模糊pid算法&#34;&gt;模糊PID算法
&lt;/h3&gt;</description>
        </item>
        <item>
        <title>工程数学基础</title>
        <link>https://a233a2.github.io/p/%E5%B7%A5%E7%A8%8B%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/</link>
        <pubDate>Thu, 24 Oct 2024 00:00:00 +0000</pubDate>
        
        <guid>https://a233a2.github.io/p/%E5%B7%A5%E7%A8%8B%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/</guid>
        <description>&lt;h2 id=&#34;一些概念&#34;&gt;一些概念
&lt;/h2&gt;&lt;h3 id=&#34;范数&#34;&gt;范数
&lt;/h3&gt;&lt;h3 id=&#34;高斯函数&#34;&gt;高斯函数
&lt;/h3&gt;&lt;h3 id=&#34;最小二乘法&#34;&gt;最小二乘法
&lt;/h3&gt;&lt;h3 id=&#34;最小二乘-矩阵形式推导&#34;&gt;最小二乘-矩阵形式推导
&lt;/h3&gt;</description>
        </item>
        <item>
        <title>DRCAN-Learn-Blog-Advance</title>
        <link>https://a233a2.github.io/p/drcan-learn-blog-advance/</link>
        <pubDate>Wed, 23 Oct 2024 00:00:00 +0000</pubDate>
        
        <guid>https://a233a2.github.io/p/drcan-learn-blog-advance/</guid>
        <description>&lt;img src="https://a233a2.github.io/p/drcan-learn-blog-advance/1-1.jpg" alt="Featured image of post DRCAN-Learn-Blog-Advance" /&gt;&lt;p&gt;此Blog记录了本人按照DRCAN视频推荐的学习顺序来系统学习DRCAN发表的控制相关视频。博客作为笔记使用。&lt;/p&gt;
&lt;h3 id=&#34;1-状态空间表达&#34;&gt;1-状态空间表达
&lt;/h3&gt;&lt;p&gt;以一个质量块-弹簧-阻尼器系统来进行分析：&lt;br&gt;
&lt;img src=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/1-1.jpg&#34;
	width=&#34;2182&#34;
	height=&#34;3086&#34;
	srcset=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/1-1_hu7229884839809532162.jpg 480w, https://a233a2.github.io/p/drcan-learn-blog-advance/1-1_hu1691059223504960444.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;1&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;70&#34;
		data-flex-basis=&#34;169px&#34;
	
&gt;   &lt;br&gt;
状态空间表达是即为：&lt;strong&gt;系统输入输出状态变量的一个集合，用一阶微分方程的形式表达出来。&lt;/strong&gt;
&lt;img src=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/1-2.png&#34;
	width=&#34;2182&#34;
	height=&#34;1753&#34;
	srcset=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/1-2_hu1484246055524713960.png 480w, https://a233a2.github.io/p/drcan-learn-blog-advance/1-2_hu12410177076624011512.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;2&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;124&#34;
		data-flex-basis=&#34;298px&#34;
	
&gt;
状态空间表达与传递函数之间的关系：包括转换方程，以及重要结论：&lt;strong&gt;|SI-A|矩阵的特征值就是传递函数的极点！&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;2-状态空间方程的解&#34;&gt;2-状态空间方程的解
&lt;/h3&gt;&lt;p&gt;有点难以推导且认为推导过程不太重要&lt;br&gt;
&lt;img src=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/21.png&#34;
	width=&#34;2182&#34;
	height=&#34;3086&#34;
	srcset=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/21_hu9857301536328584946.png 480w, https://a233a2.github.io/p/drcan-learn-blog-advance/21_hu17728875442273112032.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;2&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;70&#34;
		data-flex-basis=&#34;169px&#34;
	
&gt;&lt;br&gt;
&lt;img src=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/22.png&#34;
	width=&#34;2182&#34;
	height=&#34;3086&#34;
	srcset=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/22_hu7424707334767718386.png 480w, https://a233a2.github.io/p/drcan-learn-blog-advance/22_hu4360937834505168880.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;2&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;70&#34;
		data-flex-basis=&#34;169px&#34;
	
&gt;&lt;br&gt;
&lt;img src=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/23.png&#34;
	width=&#34;2182&#34;
	height=&#34;3086&#34;
	srcset=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/23_hu17122972239720574622.png 480w, https://a233a2.github.io/p/drcan-learn-blog-advance/23_hu13650029549609199388.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;2&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;70&#34;
		data-flex-basis=&#34;169px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;3-相图-相轨迹&#34;&gt;3-相图-相轨迹
&lt;/h3&gt;&lt;p&gt;相轨迹是系统的状态随时间变化的轨迹。当时间变化时，系统的状态点在状态空间中移动，这条移动的轨迹就是相轨迹。&lt;/p&gt;
&lt;p&gt;对于一个阻尼摆，系统的能量会逐渐衰减，最终趋于静止。其相轨迹不会形成闭合的曲线，而是一个逐渐收缩的螺旋，最终收敛到平衡点（摆静止的位置）。这说明系统是稳定的，且有能量损失。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/31.png&#34;
	width=&#34;2182&#34;
	height=&#34;3086&#34;
	srcset=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/31_hu425951968313780383.png 480w, https://a233a2.github.io/p/drcan-learn-blog-advance/31_hu16643900213948508456.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;2&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;70&#34;
		data-flex-basis=&#34;169px&#34;
	
&gt;&lt;br&gt;
可以通过分析导数正负来判别该点的稳定性，后面结论重要一些。&lt;br&gt;
&lt;img src=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/32.png&#34;
	width=&#34;2201&#34;
	height=&#34;1299&#34;
	srcset=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/32_hu1485192269137500098.png 480w, https://a233a2.github.io/p/drcan-learn-blog-advance/32_hu9250088313912901889.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;2&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;169&#34;
		data-flex-basis=&#34;406px&#34;
	
&gt;&lt;br&gt;
特殊的一种鞍点。在此令了上述x与y的导来确定x的输出？这个有些复杂。应该是用到了线性代数的坐标变换 看不太懂。。看特征值直观点。 &lt;br&gt;
&lt;img src=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/33.png&#34;
	width=&#34;2039&#34;
	height=&#34;973&#34;
	srcset=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/33_hu10825206731962301851.png 480w, https://a233a2.github.io/p/drcan-learn-blog-advance/33_hu10146504456115275453.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;2&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;209&#34;
		data-flex-basis=&#34;502px&#34;
	
&gt;&lt;br&gt;
对于复数的，而实部为0的特征值。是一个椭圆，Fixed Point为Center。 &lt;br&gt;
&lt;img src=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/34.png&#34;
	width=&#34;2176&#34;
	height=&#34;891&#34;
	srcset=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/34_hu6089759772534058434.png 480w, https://a233a2.github.io/p/drcan-learn-blog-advance/34_hu14925947017838707856.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;2&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;244&#34;
		data-flex-basis=&#34;586px&#34;
	
&gt;&lt;br&gt;
特征值复数但是实部不为0的时候。 &lt;br&gt;
&lt;img src=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/35.png&#34;
	width=&#34;2154&#34;
	height=&#34;1163&#34;
	srcset=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/35_hu16777777308420433622.png 480w, https://a233a2.github.io/p/drcan-learn-blog-advance/35_hu7477347720013798291.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;2&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;185&#34;
		data-flex-basis=&#34;444px&#34;
	
&gt;&lt;br&gt;
总结上述情况。&lt;/p&gt;
&lt;h3 id=&#34;35-连续系统的离散化&#34;&gt;3.5-连续系统的离散化
&lt;/h3&gt;&lt;p&gt;采样频率至少要为原系统频率的两倍，这样才能重建出原信号。否则可能出现混叠现象，不能复现原系统变化趋势。（2倍只是下限理论值，实际工程中选取5-10倍） &lt;br&gt;
Zero Order Hold （ZOH零阶保持器），使得控制量在一个控制周期内保持不变。&lt;/p&gt;
&lt;p&gt;采样周期要与数据处理控制时间相匹配。若数据读入处理需要50ms，则小于50ms的采样周期将变得没有意义。 &lt;br&gt;
&lt;img src=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/3.5-1.png&#34;
	width=&#34;1874&#34;
	height=&#34;1214&#34;
	srcset=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/3.5-1_hu3054599139696670051.png 480w, https://a233a2.github.io/p/drcan-learn-blog-advance/3.5-1_hu17887664043837265195.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;2&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;154&#34;
		data-flex-basis=&#34;370px&#34;
	
&gt;&lt;br&gt;
Error   ：G(T) = ∫(0,T) exp(Aτ) dτ·B
状态空间的解输出，在离散系统下的表达形式。离散系统下不关心t，而着重与每个周期。系统输入u在一个周期内可以看作一个常数（ZOH的作用）。所以可以提取出来。。&lt;/p&gt;
&lt;p&gt;使用软件将连续系统转化为离散系统 指令&lt;strong&gt;c2d(sys,f)&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;4-相图-相轨迹动态系统分析phase-portrait爱情故事&#34;&gt;4-相图-相轨迹动态系统分析Phase Portrait爱情故事
&lt;/h3&gt;&lt;p&gt;相轨迹&lt;/p&gt;
&lt;h3 id=&#34;5-系统的可控性&#34;&gt;5-系统的可控性
&lt;/h3&gt;&lt;p&gt;讲解了对于状态空间表达的秩判据的相关内容。秩判据的相关数学证明: &lt;br&gt;
另外讲解了定义的可控性是何种意义上的可控性。 &lt;br&gt;
&lt;img src=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/51.jpg&#34;
	width=&#34;2182&#34;
	height=&#34;2569&#34;
	srcset=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/51_hu14473934175636827000.jpg 480w, https://a233a2.github.io/p/drcan-learn-blog-advance/51_hu1429475142258959569.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;2&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;84&#34;
		data-flex-basis=&#34;203px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;6-李雅普诺夫稳定性&#34;&gt;6-李雅普诺夫稳定性
&lt;/h3&gt;&lt;p&gt;讲解了李雅普诺夫稳定性的严禁数学定义。以及对于状态转移矩阵A矩阵特征值的几种形式来定义李雅普诺夫的集中稳定性。 &lt;br&gt;
针对非线性系统，区别于传统解微分方程，采用李雅普诺夫第二法进行解决，在此处进行了简单的介绍。 &lt;br&gt;
&lt;img src=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/61.jpg&#34;
	width=&#34;2182&#34;
	height=&#34;3086&#34;
	srcset=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/61_hu5641696737157067.jpg 480w, https://a233a2.github.io/p/drcan-learn-blog-advance/61_hu2161642686435310383.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;2&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;70&#34;
		data-flex-basis=&#34;169px&#34;
	
&gt;&lt;br&gt;
&lt;img src=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/62.jpg&#34;
	width=&#34;2182&#34;
	height=&#34;1475&#34;
	srcset=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/62_hu8693756144219456126.jpg 480w, https://a233a2.github.io/p/drcan-learn-blog-advance/62_hu16010987264924604746.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;2&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;147&#34;
		data-flex-basis=&#34;355px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;7-线性控制器设计&#34;&gt;7-线性控制器设计
&lt;/h3&gt;&lt;p&gt;这部分便是之前现代控制理论方面的根据期望的特征值来确定系统的不同k增益的输入。
令u=kx，对期望的$\lambda$列出闭环矩阵Acl，对Acl求特征值?（应该是 太久远了 有点遗忘）
列出以$\lambda$为未知量的方程，结合期望$\lambda$的特征值方程对应相等。求得k矩阵。
&lt;img src=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/71.jpg&#34;
	width=&#34;2182&#34;
	height=&#34;3086&#34;
	srcset=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/71_hu12605214141889279940.jpg 480w, https://a233a2.github.io/p/drcan-learn-blog-advance/71_hu13337817652409191429.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;2&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;70&#34;
		data-flex-basis=&#34;169px&#34;
	
&gt; &lt;br&gt;
&lt;img src=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/72.jpg&#34;
	width=&#34;2182&#34;
	height=&#34;2716&#34;
	srcset=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/72_hu14034203957898177910.jpg 480w, https://a233a2.github.io/p/drcan-learn-blog-advance/72_hu13401945833860414619.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;2&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;80&#34;
		data-flex-basis=&#34;192px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;8-lqr控制liner-quadratic-regulator&#34;&gt;8-LQR控制（Liner Quadratic Regulator）
&lt;/h3&gt;&lt;p&gt;线性二次型调节器。是一种对控制系统的目标$\lambda$进行确定的最优控制算法。 &lt;br&gt;
其设置了一种惩罚函数J，通过求得MinJ来确定系统最优的$\lambda$。进而进行线性控制器的设计。
&lt;img src=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/81.jpg&#34;
	width=&#34;2182&#34;
	height=&#34;1475&#34;
	srcset=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/81_hu16155908660427802456.jpg 480w, https://a233a2.github.io/p/drcan-learn-blog-advance/81_hu303810490908243574.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;2&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;147&#34;
		data-flex-basis=&#34;355px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;9-状态观测器设计luenberger为例&#34;&gt;9-状态观测器设计（Luenberger为例）
&lt;/h3&gt;&lt;p&gt;LQR控制等线性控制u=-kx的前提是状态x全部可测。而对于状态不可测的系统需要观测器Observer &lt;br&gt;
也是之前现代控制理论的必做题类型。观测器建立了一个新的反馈系统目标是使得观测值与实际值相差的err为0。      &lt;br&gt;
观测器也就是 根据系统现有的输入和输出 来估计系统的状态。 &lt;br&gt;
&lt;img src=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/91.jpg&#34;
	width=&#34;2182&#34;
	height=&#34;3086&#34;
	srcset=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/91_hu17671702461150397579.jpg 480w, https://a233a2.github.io/p/drcan-learn-blog-advance/91_hu3864620464621549933.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;2&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;70&#34;
		data-flex-basis=&#34;169px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;另外根据之前的阻尼器-弹簧-质量块经典系统进行了观测器设计，设定两个特征值期望为-1 -1。 &lt;br&gt;
&lt;img src=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/92.jpg&#34;
	width=&#34;2182&#34;
	height=&#34;2448&#34;
	srcset=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/92_hu1447313957454599147.jpg 480w, https://a233a2.github.io/p/drcan-learn-blog-advance/92_hu10687051141730272077.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;2&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;89&#34;
		data-flex-basis=&#34;213px&#34;
	
&gt; &lt;br&gt;
Simulink仿真 &lt;br&gt;
&lt;img src=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/93.jpg&#34;
	width=&#34;1644&#34;
	height=&#34;1102&#34;
	srcset=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/93_hu10858130551705957268.jpg 480w, https://a233a2.github.io/p/drcan-learn-blog-advance/93_hu7284049849754470848.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;2&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;149&#34;
		data-flex-basis=&#34;358px&#34;
	
&gt; &lt;br&gt;
观测器状态空间是目标$\lambda$=-1 -1求解出来的。
Z2状态不可测，直接运行时，估计值与真实值完全重合。
在Z2hat估计值的地方对z2估计值进行赋初值为1的操作时，可以认为z2开始时估计值与真实值有了偏差。 &lt;br&gt;
此时，系统的输出图像有了偏差，z1与z2估计值有关，所以两个图像全部出现了偏差。且能够在后续过程中完成跟随观测。
&lt;img src=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/94.jpg&#34;
	width=&#34;1543&#34;
	height=&#34;786&#34;
	srcset=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/94_hu10379666068161534470.jpg 480w, https://a233a2.github.io/p/drcan-learn-blog-advance/94_hu6326178576858594335.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;2&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;196&#34;
		data-flex-basis=&#34;471px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;10-可观测性与分离原理&#34;&gt;10-可观测性与分离原理
&lt;/h3&gt;</description>
        </item>
        <item>
        <title>DRCAN-Learn-Blog-Basic</title>
        <link>https://a233a2.github.io/p/drcan-learn-blog-basic/</link>
        <pubDate>Wed, 23 Oct 2024 00:00:00 +0000</pubDate>
        
        <guid>https://a233a2.github.io/p/drcan-learn-blog-basic/</guid>
        <description>&lt;p&gt;此Blog记录了本人按照DRCAN视频推荐的学习顺序来系统学习DRCAN发表的控制相关视频。博客作为笔记使用。&lt;/p&gt;
&lt;h3 id=&#34;卷积定理&#34;&gt;卷积定理
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;卷积操作&lt;br&gt;
$$L[{f(t)*g(t)}]=F(s)​G(s)$$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;拉普拉斯变换&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;$$L{ f(t) } = F(s) = \int_0^{\infty} f(t) e^{-st} , dt$$&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;卷积定理（拉普拉斯域）&lt;br&gt;
卷积定理指出，在时间域中两个函数的卷积，在拉普拉斯变换后相当于它们的拉普拉斯变换的乘积。&lt;br&gt;
如果$f(t)$和$g(t)$的拉氏变换分别为$F(s)$和$G(s)$,那么：&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;$$ L[{f(t) ∗g(t)}] =F( s ) G( s) $$&lt;/p&gt;
&lt;p&gt;这意味着在时间域中复杂的卷积操作可以通过拉普拉斯变换简化为频域中的简单乘法。
这在处理线性时不变系统时非常有用，特别是当我们&lt;strong&gt;有系统的输入和系统的脉冲响应时，
利用卷积定理可以将输入信号和系统的响应进行频域分析。&lt;/strong&gt;&lt;br&gt;
数学证明：&lt;br&gt;
&lt;img src=&#34;https://a233a2.github.io/p/drcan-learn-blog-basic/%E5%8D%B7%E7%A7%AF%E5%AE%9A%E7%90%86%E6%95%B0%E5%AD%A6%E8%AF%81%E6%98%8E.jpg&#34;
	width=&#34;1079&#34;
	height=&#34;1527&#34;
	srcset=&#34;https://a233a2.github.io/p/drcan-learn-blog-basic/%E5%8D%B7%E7%A7%AF%E5%AE%9A%E7%90%86%E6%95%B0%E5%AD%A6%E8%AF%81%E6%98%8E_hu12515043388887547171.jpg 480w, https://a233a2.github.io/p/drcan-learn-blog-basic/%E5%8D%B7%E7%A7%AF%E5%AE%9A%E7%90%86%E6%95%B0%E5%AD%A6%E8%AF%81%E6%98%8E_hu3113174287893646857.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;设置1&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;70&#34;
		data-flex-basis=&#34;169px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;拉普拉斯变换&#34;&gt;拉普拉斯变换
&lt;/h3&gt;</description>
        </item>
        <item>
        <title>DRCAN-Learn-Blog-OPT</title>
        <link>https://a233a2.github.io/p/drcan-learn-blog-opt/</link>
        <pubDate>Wed, 23 Oct 2024 00:00:00 +0000</pubDate>
        
        <guid>https://a233a2.github.io/p/drcan-learn-blog-opt/</guid>
        <description>&lt;p&gt;此Blog记录了本人按照DRCAN视频推荐的学习顺序来系统学习DRCAN发表的控制相关视频。博客作为笔记使用。&lt;/p&gt;
&lt;h3 id=&#34;lqr&#34;&gt;LQR
&lt;/h3&gt;&lt;p&gt;线性二次型调节器，在Advance教程中有提及到。&lt;/p&gt;
&lt;h3 id=&#34;mpc&#34;&gt;MPC
&lt;/h3&gt;</description>
        </item>
        <item>
        <title>XTdrone仿真环境</title>
        <link>https://a233a2.github.io/p/xtdrone%E4%BB%BF%E7%9C%9F%E7%8E%AF%E5%A2%83/</link>
        <pubDate>Tue, 22 Oct 2024 00:00:00 +0000</pubDate>
        
        <guid>https://a233a2.github.io/p/xtdrone%E4%BB%BF%E7%9C%9F%E7%8E%AF%E5%A2%83/</guid>
        <description>&lt;img src="https://a233a2.github.io/p/xtdrone%E4%BB%BF%E7%9C%9F%E7%8E%AF%E5%A2%83/%E9%85%8D%E7%BD%AE%E5%A5%BD%E7%9A%84%E5%9B%BE.jpg" alt="Featured image of post XTdrone仿真环境" /&gt;&lt;h3 id=&#34;xtdrone仿真环境搭建&#34;&gt;XTdrone仿真环境搭建
&lt;/h3&gt;&lt;p&gt;使用了XTdrone推荐的自动配置，开发环境是Ubuntu 22.04&lt;br&gt;
下午时花了两个小时手动配置没配置好，弄这种大工程还是得新系统比较好一点。&lt;br&gt;
&lt;img src=&#34;https://a233a2.github.io/p/xtdrone%E4%BB%BF%E7%9C%9F%E7%8E%AF%E5%A2%83/%E9%85%8D%E7%BD%AE%E5%A5%BD%E7%9A%84%E5%9B%BE.jpg&#34;
	width=&#34;1920&#34;
	height=&#34;1080&#34;
	srcset=&#34;https://a233a2.github.io/p/xtdrone%E4%BB%BF%E7%9C%9F%E7%8E%AF%E5%A2%83/%E9%85%8D%E7%BD%AE%E5%A5%BD%E7%9A%84%E5%9B%BE_hu18099202995669554499.jpg 480w, https://a233a2.github.io/p/xtdrone%E4%BB%BF%E7%9C%9F%E7%8E%AF%E5%A2%83/%E9%85%8D%E7%BD%AE%E5%A5%BD%E7%9A%84%E5%9B%BE_hu2642333738181242516.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;111&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;177&#34;
		data-flex-basis=&#34;426px&#34;
	
&gt;&lt;br&gt;
另外作者太牛逼了&lt;br&gt;
&lt;a class=&#34;link&#34; href=&#34;https://www.yuque.com/xtdrone/manual_cn/install_scripts&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.yuque.com/xtdrone/manual_cn/install_scripts&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;后续使用引言&#34;&gt;后续使用引言
&lt;/h3&gt;&lt;p&gt;打算在其之上二次开发PX4的程序。XTdrone提供了风场生成的插件。但是如何在PX4原版代码上修改是一个大问题。  &lt;br&gt;
为了简化可以搭载机载电脑，然后运行ROS系统，在ROS系统上检测风场并进行稳态控制。这是一个方法。但是无疑会造成设备增多，复杂度增加。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>PX4二次开发以及仿真PX4-2</title>
        <link>https://a233a2.github.io/p/px4%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%E4%BB%A5%E5%8F%8A%E4%BB%BF%E7%9C%9Fpx4-2/</link>
        <pubDate>Thu, 10 Oct 2024 00:00:00 +0000</pubDate>
        
        <guid>https://a233a2.github.io/p/px4%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%E4%BB%A5%E5%8F%8A%E4%BB%BF%E7%9C%9Fpx4-2/</guid>
        <description>&lt;img src="https://a233a2.github.io/p/px4%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%E4%BB%A5%E5%8F%8A%E4%BB%BF%E7%9C%9Fpx4-2/fengmian.png" alt="Featured image of post PX4二次开发以及仿真PX4-2" /&gt;&lt;h3 id=&#34;px4在linux环境下的编译make&#34;&gt;PX4在Linux环境下的编译（make）
&lt;/h3&gt;&lt;p&gt;使用VM17虚拟机以及Ubuntu20.04对PX4项目进行编译。&lt;br&gt;
参考了超维空间科技的文章:&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/qq_38768959/article/details/106041494&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;超维空间科技的文章&lt;/a&gt; &lt;br&gt;
后续配置参考了Xtdrone仿真平台的一键配置，更为简单:&lt;a class=&#34;link&#34; href=&#34;https://www.yuque.com/xtdrone/manual_cn&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Xtdrone仿真平台文档&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;gazebo配合qgc地面站仿真&#34;&gt;Gazebo配合QGC地面站仿真
&lt;/h3&gt;&lt;h4 id=&#34;linux-qgc的安装&#34;&gt;Linux-QGC的安装：
&lt;/h4&gt;&lt;p&gt;QGC官网指导下进行配置，之后下载AppImage文件运行QGC地面站即可。 &lt;br&gt;
仿真中：&lt;br&gt;
&lt;img src=&#34;https://a233a2.github.io/p/px4%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%E4%BB%A5%E5%8F%8A%E4%BB%BF%E7%9C%9Fpx4-2/px4&amp;#43;gazebo.png&#34;
	width=&#34;2560&#34;
	height=&#34;1549&#34;
	srcset=&#34;https://a233a2.github.io/p/px4%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%E4%BB%A5%E5%8F%8A%E4%BB%BF%E7%9C%9Fpx4-2/px4&amp;#43;gazebo_hu16359290037193365331.png 480w, https://a233a2.github.io/p/px4%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%E4%BB%A5%E5%8F%8A%E4%BB%BF%E7%9C%9Fpx4-2/px4&amp;#43;gazebo_hu11163092954185164344.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;PX4工程文件1&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;165&#34;
		data-flex-basis=&#34;396px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;新建飞行任务antiwindtask&#34;&gt;新建飞行任务AntiWindTask
&lt;/h3&gt;&lt;p&gt;按照PX4官方指导文档新建自己的一个飞行任务 &lt;a class=&#34;link&#34; href=&#34;https://docs.px4.io/v1.14/en/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;官方新建任务指导&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最终参考了1.14版本的指导文件，一开始看的main指导文件去配置了XTdrone自动配置的1.13的PX4工程，发现在moduls文件下根本没有飞行任务配置。。。接着去使用1.15的PX4工程，但是在CMakeList文件中有所不同，在每一个版本中都有不同之处。1.15版本也会有bug存在。&lt;br&gt;
最后使用1.14版本，参考了1.14的指导文档，依然是CmakeList那里不对，文档中的放置位置在官方代码1.14.4版本中根本就没有。&lt;/p&gt;
&lt;p&gt;1.14.4版本中最后无奈我放到了一个差不多的位置。如下： &lt;br&gt;
&lt;img src=&#34;https://a233a2.github.io/p/px4%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%E4%BB%A5%E5%8F%8A%E4%BB%BF%E7%9C%9Fpx4-2/1.png&#34;
	width=&#34;595&#34;
	height=&#34;182&#34;
	srcset=&#34;https://a233a2.github.io/p/px4%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%E4%BB%A5%E5%8F%8A%E4%BB%BF%E7%9C%9Fpx4-2/1_hu18098538440630685739.png 480w, https://a233a2.github.io/p/px4%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%E4%BB%A5%E5%8F%8A%E4%BB%BF%E7%9C%9Fpx4-2/1_hu7742442885986621283.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;Error&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;326&#34;
		data-flex-basis=&#34;784px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;但是在进行FMU-V2构建烧录代码时也会一直出现bug如下，但是很奇怪使用PX4-SITL构建仿真时便没有错误出现，1.15也是如此： &lt;br&gt;
&lt;img src=&#34;https://a233a2.github.io/p/px4%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%E4%BB%A5%E5%8F%8A%E4%BB%BF%E7%9C%9Fpx4-2/2.png&#34;
	width=&#34;751&#34;
	height=&#34;507&#34;
	srcset=&#34;https://a233a2.github.io/p/px4%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%E4%BB%A5%E5%8F%8A%E4%BB%BF%E7%9C%9Fpx4-2/2_hu10717576958982321655.png 480w, https://a233a2.github.io/p/px4%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%E4%BB%A5%E5%8F%8A%E4%BB%BF%E7%9C%9Fpx4-2/2_hu8964904137106437533.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;1&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;148&#34;
		data-flex-basis=&#34;355px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;最后在github工程发表了issues，最终我更换了FMU-V3来构建，这个错误便消除了。最终成功执行了任务。在QGC地面站也可以正常识别。&lt;br&gt;
&lt;img src=&#34;https://a233a2.github.io/p/px4%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%E4%BB%A5%E5%8F%8A%E4%BB%BF%E7%9C%9Fpx4-2/AntiWind.png&#34;
	width=&#34;1117&#34;
	height=&#34;579&#34;
	srcset=&#34;https://a233a2.github.io/p/px4%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%E4%BB%A5%E5%8F%8A%E4%BB%BF%E7%9C%9Fpx4-2/AntiWind_hu8455000950526164640.png 480w, https://a233a2.github.io/p/px4%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%E4%BB%A5%E5%8F%8A%E4%BB%BF%E7%9C%9Fpx4-2/AntiWind_hu2756004170727178923.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;AntiWind&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;192&#34;
		data-flex-basis=&#34;463px&#34;
	
&gt;&lt;/p&gt;
&lt;h4 id=&#34;newflighttask分析&#34;&gt;NewFlightTask分析：
&lt;/h4&gt;&lt;p&gt;在指导文件中，其让我们修改了MPC_POS_MOD这个参数，很确定的是此参数决定了飞机在手动-Position定点飞行模式时要执行的实际代码中的任务模式。在源工程中有4中，但只能选择一种。 &lt;br&gt;
这也在侧面看出PX4的代码很庞大，实际运行只有那么一点。但是要真正简化这个系统也是很麻烦且没必要。&lt;br&gt;
指导文件默认的效果是控制台输出一段文字。然后实际飞机并不会升高。&lt;br&gt;
&lt;img src=&#34;https://a233a2.github.io/p/px4%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%E4%BB%A5%E5%8F%8A%E4%BB%BF%E7%9C%9Fpx4-2/%E9%A3%9E%E8%A1%8C%E6%A8%A1%E5%BC%8F%E6%9C%80%E5%88%9D%E4%BB%BF%E7%9C%9F%E6%95%88%E6%9E%9C.png&#34;
	width=&#34;1553&#34;
	height=&#34;977&#34;
	srcset=&#34;https://a233a2.github.io/p/px4%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%E4%BB%A5%E5%8F%8A%E4%BB%BF%E7%9C%9Fpx4-2/%E9%A3%9E%E8%A1%8C%E6%A8%A1%E5%BC%8F%E6%9C%80%E5%88%9D%E4%BB%BF%E7%9C%9F%E6%95%88%E6%9E%9C_hu16148123657284509088.png 480w, https://a233a2.github.io/p/px4%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%E4%BB%A5%E5%8F%8A%E4%BB%BF%E7%9C%9Fpx4-2/%E9%A3%9E%E8%A1%8C%E6%A8%A1%E5%BC%8F%E6%9C%80%E5%88%9D%E4%BB%BF%E7%9C%9F%E6%95%88%E6%9E%9C_hu15306114322350412902.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;飞行模式最初仿真效果&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;158&#34;
		data-flex-basis=&#34;381px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;manual-position飞行模式分析&#34;&gt;Manual-Position飞行模式分析
&lt;/h3&gt;&lt;p&gt;下面以Manual-Position飞行模式为例子对PX4原有的飞行模式进行分析，以便我们写出自己的飞行模式。 &lt;br&gt;
但是在飞行模式中，可以看出并没有PID相关的直接控制。在这些控制代码中，更多的是作为一种高级控制。分析摇杆输入等混合输入，来对SetPoint进行赋值，分发给更底层的PID控制机构。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>ADRC课程笔记</title>
        <link>https://a233a2.github.io/p/adrc%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/</link>
        <pubDate>Mon, 16 Sep 2024 00:00:00 +0000</pubDate>
        
        <guid>https://a233a2.github.io/p/adrc%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/</guid>
        <description>&lt;h3 id=&#34;adrc课程笔记&#34;&gt;ADRC课程笔记
&lt;/h3&gt;&lt;p&gt;本人对ADRC控制有着深厚的研究兴趣。在讨论研究韩京清先生的ADRC知识之前，我想先给不太专业的自己补习一些经典与现代控制理论方向的相关知识。&lt;/p&gt;
&lt;h4 id=&#34;生理前馈系统&#34;&gt;生理前馈系统
&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;在生理学上，前馈控制的例子是在实际体力活动之前，自主神经系统对心跳的正常预期调节。前馈控制可以比作对已知线索的预期反应（预测编码）。心跳的反馈调节为机体提供了进一步对运动的适应性。  &amp;ndash;wiki百科&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在前馈系统中，控制变量的调整不是以目标和回授之间的误差为基础，它是以过程&lt;strong&gt;数学模型&lt;/strong&gt;的知识和&lt;strong&gt;过程扰动&lt;/strong&gt;的知识或测量为基础。&lt;/p&gt;
&lt;p&gt;所以对于数学模型的整体掌握是对系统扰动进行前馈消除的前提。&lt;/p&gt;
&lt;p&gt;正所谓要想系统稳得住，必须得有前馈引入。前馈控制在某些控制场合下是必须项。&lt;/p&gt;
&lt;h3 id=&#34;前馈控制&#34;&gt;前馈控制
&lt;/h3&gt;&lt;h6 id=&#34;摘自高志强-自抗扰控制思想探究&#34;&gt;摘自《高志强: 自抗扰控制思想探究》
&lt;/h6&gt;&lt;p&gt;前馈控制是一种&lt;strong&gt;基于对扰动的预测&lt;/strong&gt;进行补偿的控制方法。它通过&lt;strong&gt;测量&lt;/strong&gt;可能影响系统输出的扰动变量，并根据扰动变量与系统输出之间的关系，计算出所需的控制量，在&lt;strong&gt;扰动对系统产生影响之前&lt;/strong&gt;就进行调节，以抵消扰动的影响。&lt;br&gt;
在自动控制系统理论中学习过，由传递函数理论数学推导，前馈的引入可以完全的消除系统的扰动误差。现在这显然并不是这么的简单，这需要对系统数学模型有着十分精确的掌握。&lt;br&gt;
前馈控制在工业界用途广泛, 但是学术界对它很少关心, 认为是开环控制, 没有什么理论可言. 前馈的使用方式主要有两种: 一种是&lt;strong&gt;根据参考输入和对象模型的逆&lt;/strong&gt;而得到的控制量, 不依赖对象的实时信息,暂且称之为A类前馈; 另外一种前馈, 是&lt;strong&gt;根据被控量之外的对象信息&lt;/strong&gt;所产生的控制量, 即B类前馈。&lt;br&gt;
前馈控制提出的本意是要区别于上面提到的狭义的反馈控制, 表示控制量的一部分甚至全部都可以完全独立于被控量的量测. Black定义的反馈(feedback)本来就是针对前馈(feedforward)而言的, 表示信号流向反转, 由输出到输入. 这里信号的走向一正一反, 概念很清楚。&lt;br&gt;
可是当反馈这个通讯工程的概念被借用到控制工程时, 它的反义词前馈的含义便有了两种解释. 比如上面说的A类前馈明显是开环控制, 控制量完全独立于对象的实时信息. 可是B类前馈则不然, 它依赖的还是对象信息, 实际上是前面提到的广义反馈, 只不过反馈的不是输出量而已. B类前馈在文献中也被称为扰动前馈, 它是基于对象扰动信息的实时提取, 就像指南车. 可是同样是基于对象信息的提取, 指南车为什么会被称为开环控制呢？其实B类前馈属于广义反馈, 不应称其为前馈或开环控制. 鉴于前馈的概念和用法前后重叠, 为了概念的清晰, 建议今后可把B类前馈归入抗扰原理讨论; 把前馈狭义地定义为A类前馈.那么这样的前馈有什么意义呢？为什么它的用途这么广呢？主要原因是它降低了快速跟踪的成本。&lt;br&gt;
一个控制系统要使输出迅速跟踪给定值有两个途径: 1) 高带宽; 2) 前馈. 但是在工业上, 带宽就是成本.高带宽虽然能使跟踪速度提高, 但也带来很多问题:1) 对执行机构的品质要求提高; 2) 激励了对象的高频动态使控制问题复杂化; 3) 闭环系统的稳定裕度下降,对相位滞后和时间延迟更敏感; 4) 对传感器噪声更敏感, 等等.高带宽的成本在20世 50年代就有专门、详细的讨论, 比如文献[46], 但是至今没能在理论界引起重视, 乃至高增益控制器、观测器的文章比比皆是, 而能用上的却寥寥无几. 这反映了不考虑成本的研究, 在工程上是没有多少意义的。&lt;br&gt;
工程师们在实践中基于对系统物理特性的知识发现了前馈这个办法. 这种独立于反馈回路拟合出的控制量通常是结合参考输入, 以数据或图表形式表示的,常常在控制信号中占主要部分. 同时也使用PID反馈控制器, 发挥微调、纠错的作用. 因此, 工业上的PID控制器常常是与前馈控制结合使用的。&lt;br&gt;
以上总结的是控制论的基本原理, 是从事自动控制的人们在长期的工程实践中发现、挖掘出来的, 是控制论继续发展的基石. 要系统地、科学地建立和发展一套完整的理论体系, 就需要对基本原理进行提炼、抽象和升华, 使得工程控制的实践能够更加系统,并不断进入更高的层次, 从而“下学而上达”。&lt;/p&gt;
&lt;h3 id=&#34;状态观测器&#34;&gt;状态观测器
&lt;/h3&gt;&lt;h3 id=&#34;扩张状态观测器&#34;&gt;扩张状态观测器
&lt;/h3&gt;</description>
        </item>
        <item>
        <title>YSYX学习日记</title>
        <link>https://a233a2.github.io/p/ysyx%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/</link>
        <pubDate>Mon, 16 Sep 2024 00:00:00 +0000</pubDate>
        
        <guid>https://a233a2.github.io/p/ysyx%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/</guid>
        <description>&lt;h3 id=&#34;ysyx学习日记&#34;&gt;YSYX学习日记
&lt;/h3&gt;&lt;p&gt;学习记录： &lt;a class=&#34;link&#34; href=&#34;https://docs.qq.com/sheet/DQ0lRY2tNb2VIZWVB?newPad=1&amp;amp;newPadType=clone&amp;amp;tab=BB08J4&amp;amp;_t=1728471922939&amp;amp;u=555637143d844e0f8b3d1a7c9c34bebf&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;学习记录&lt;/a&gt;。&lt;/p&gt;
&lt;h4 id=&#34;ubuntu安装&#34;&gt;Ubuntu安装
&lt;/h4&gt;&lt;p&gt;测试赛&lt;/p&gt;
</description>
        </item>
        <item>
        <title>分数阶数学控制</title>
        <link>https://a233a2.github.io/p/%E5%88%86%E6%95%B0%E9%98%B6%E6%95%B0%E5%AD%A6%E6%8E%A7%E5%88%B6/</link>
        <pubDate>Mon, 16 Sep 2024 00:00:00 +0000</pubDate>
        
        <guid>https://a233a2.github.io/p/%E5%88%86%E6%95%B0%E9%98%B6%E6%95%B0%E5%AD%A6%E6%8E%A7%E5%88%B6/</guid>
        <description>&lt;h3 id=&#34;分数阶数学控制&#34;&gt;分数阶数学控制
&lt;/h3&gt;&lt;p&gt;ARDC课程上得到了有关于在分数阶下控制的相关知识，得知其是因为传统的整数阶控制存在一定的信息丢失。使得控制精度在某些场合不尽理想，所以近现代诞生出分数阶控制的相关理论研究。&lt;br&gt;
巧合的是，分数阶微分的英文缩写居然是FOC！(Fractional Calculus)&lt;br&gt;
测试&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
