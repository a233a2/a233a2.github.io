<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>学术类别 on sunjiyi&#39;s Blogggg</title>
        <link>https://a233a2.github.io/categories/%E5%AD%A6%E6%9C%AF%E7%B1%BB%E5%88%AB/</link>
        <description>Recent content in 学术类别 on sunjiyi&#39;s Blogggg</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <copyright>Sunjiyi Make and Design</copyright>
        <lastBuildDate>Tue, 19 Nov 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://a233a2.github.io/categories/%E5%AD%A6%E6%9C%AF%E7%B1%BB%E5%88%AB/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>Simulink-PX4仿真</title>
        <link>https://a233a2.github.io/p/simulink-px4%E4%BB%BF%E7%9C%9F/</link>
        <pubDate>Tue, 19 Nov 2024 00:00:00 +0000</pubDate>
        
        <guid>https://a233a2.github.io/p/simulink-px4%E4%BB%BF%E7%9C%9F/</guid>
        <description>&lt;img src="https://a233a2.github.io/p/simulink-px4%E4%BB%BF%E7%9C%9F/fengmian.png" alt="Featured image of post Simulink-PX4仿真" /&gt;&lt;h3 id=&#34;px4-simulink联合环境配置&#34;&gt;PX4-Simulink联合环境配置
&lt;/h3&gt;&lt;p&gt;参考如下教学： &lt;br&gt;
&lt;a class=&#34;link&#34; href=&#34;https://www.bilibili.com/video/BV18P4y1T7UH&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;PX4与Simulink联合仿真-入门篇&lt;/a&gt;        &lt;br&gt;
&lt;a class=&#34;link&#34; href=&#34;https://www.bilibili.com/video/BV13S4y1P7QK&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;PX4与Simulink联合仿真-进阶篇&lt;/a&gt;  &lt;br&gt;
&lt;a class=&#34;link&#34; href=&#34;https://www.bilibili.com/video/BV1sj42197TH&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;使用Pixhawk2.4.8基于Simulink进行入门级飞控算法自主开发的操作&lt;/a&gt;  &lt;br&gt;
&lt;a class=&#34;link&#34; href=&#34;https://www.bilibili.com/video/BV1nm4y1475s&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;基于Simulink的PX4飞控算法的开发实践（1.硬件支持包配置）&lt;/a&gt;  &lt;br&gt;
&lt;a class=&#34;link&#34; href=&#34;https://www.bilibili.com/video/BV1gF411T7st&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;基于Simulink的ROS2下PX4无人机控制框架-入门篇&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;PX4版本：适配matlab 2022b的v1.12.3 &lt;br&gt;
Matlab版本：2022b &lt;br&gt;
windows：Windows11家庭版&lt;/p&gt;
&lt;h3 id=&#34;开发环境的配置&#34;&gt;开发环境的配置
&lt;/h3&gt;&lt;p&gt;遇到的错误：在编译时一直提示找不到.px4文件的错误如下图： &lt;br&gt;
&lt;img src=&#34;https://a233a2.github.io/p/simulink-px4%E4%BB%BF%E7%9C%9F/%E9%94%99%E8%AF%AF1%E6%89%BE%E4%B8%8D%E5%88%B0.px4%E6%96%87%E4%BB%B6-1.jpg&#34;
	width=&#34;852&#34;
	height=&#34;639&#34;
	srcset=&#34;https://a233a2.github.io/p/simulink-px4%E4%BB%BF%E7%9C%9F/%E9%94%99%E8%AF%AF1%E6%89%BE%E4%B8%8D%E5%88%B0.px4%E6%96%87%E4%BB%B6-1_hu2102160675909218636.jpg 480w, https://a233a2.github.io/p/simulink-px4%E4%BB%BF%E7%9C%9F/%E9%94%99%E8%AF%AF1%E6%89%BE%E4%B8%8D%E5%88%B0.px4%E6%96%87%E4%BB%B6-1_hu10570373229207981760.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;错误1找不到px4文件&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;133&#34;
		data-flex-basis=&#34;320px&#34;
	
&gt; &lt;br&gt;
&lt;img src=&#34;https://a233a2.github.io/p/simulink-px4%E4%BB%BF%E7%9C%9F/%E9%94%99%E8%AF%AF1%E6%89%BE%E4%B8%8D%E5%88%B0.px4%E6%96%87%E4%BB%B6-2.jpg&#34;
	width=&#34;1345&#34;
	height=&#34;854&#34;
	srcset=&#34;https://a233a2.github.io/p/simulink-px4%E4%BB%BF%E7%9C%9F/%E9%94%99%E8%AF%AF1%E6%89%BE%E4%B8%8D%E5%88%B0.px4%E6%96%87%E4%BB%B6-2_hu2972160481222992229.jpg 480w, https://a233a2.github.io/p/simulink-px4%E4%BB%BF%E7%9C%9F/%E9%94%99%E8%AF%AF1%E6%89%BE%E4%B8%8D%E5%88%B0.px4%E6%96%87%E4%BB%B6-2_hu7119989339237306091.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;错误1找不到px4文件&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;157&#34;
		data-flex-basis=&#34;377px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;四旋翼数学模型的推导&#34;&gt;四旋翼数学模型的推导
&lt;/h3&gt;</description>
        </item>
        <item>
        <title>神经网络基础</title>
        <link>https://a233a2.github.io/p/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/</link>
        <pubDate>Wed, 13 Nov 2024 00:00:00 +0000</pubDate>
        
        <guid>https://a233a2.github.io/p/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/</guid>
        <description>&lt;h2 id=&#34;基础&#34;&gt;基础
&lt;/h2&gt;&lt;h3 id=&#34;两层神经网络分析为例&#34;&gt;两层神经网络分析为例
&lt;/h3&gt;&lt;p&gt;摘自zhihu：&lt;a class=&#34;link&#34; href=&#34;https://zhuanlan.zhihu.com/p/65472471&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;神经网络15分钟入门！足够通俗易懂了吧&lt;/a&gt;    &lt;br&gt;
&lt;img src=&#34;https://a233a2.github.io/p/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E4%B8%A4%E5%B1%82%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%85%B8%E5%9E%8B%E7%BB%93%E6%9E%84.png&#34;
	width=&#34;891&#34;
	height=&#34;562&#34;
	srcset=&#34;https://a233a2.github.io/p/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E4%B8%A4%E5%B1%82%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%85%B8%E5%9E%8B%E7%BB%93%E6%9E%84_hu5277222655574983243.png 480w, https://a233a2.github.io/p/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E4%B8%A4%E5%B1%82%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%85%B8%E5%9E%8B%E7%BB%93%E6%9E%84_hu1044721732596226.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;两层神经网络典型结构&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;158&#34;
		data-flex-basis=&#34;380px&#34;
	
&gt; &lt;br&gt;
任务描述：在坐标系中，给出一个坐标系，使用神经网络进行分类象限。&lt;/p&gt;
&lt;h4 id=&#34;输入层&#34;&gt;输入层
&lt;/h4&gt;&lt;p&gt;在我们的例子中，输入层是坐标值，例如（1,1），这是一个包含两个元素的数组，
也可以看作是一个1&lt;em&gt;2的矩阵。输入层的元素维度与输入量的特征息息相关，如果输
入的是一张32&lt;/em&gt;32像素的灰度图像，那么输入层的维度就是32*32。&lt;/p&gt;
&lt;h4 id=&#34;输入层到隐藏层&#34;&gt;输入层到隐藏层
&lt;/h4&gt;&lt;p&gt;连接输入层和隐藏层的是W1和b1。由X计算得到H十分简单，就是矩阵运算： &lt;br&gt;
$$ H=X&lt;em&gt;W1+b1 $$ &lt;br&gt;
如上图中所示，在设定隐藏层为50维（也可以理解成50个神经元）之后，矩阵H的大小为（1&lt;/em&gt;50）的矩阵。&lt;/p&gt;
&lt;h4 id=&#34;隐藏层到输出层&#34;&gt;隐藏层到输出层
&lt;/h4&gt;&lt;p&gt;连接隐藏层和输出层的是W2和b2。同样是通过矩阵运算进行的： &lt;br&gt;
$$ Y=H*W2+b2 $$ &lt;br&gt;
通过上述两个线性方程的计算，我们就能得到最终的输出Y了，但是如果你还对线性代数的计算有印象的话，应该会知道：一系列线性方程的运算最终都可以用一个线性方程表示。也就是说，上述两个式子联立后可以用一个线性方程表达。对于两次神经网络是这样，就算网络深度加到100层，也依然是这样。这样的话神经网络就失去了意义。&lt;/p&gt;
&lt;h4 id=&#34;激活层&#34;&gt;激活层
&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;神经网络中的激活层（Activation Layer）主要负责为网络中的每一层神经元引入非线性因素。没有激活函数，神经网络就只能执行线性变换，而线性变换无法表达复杂的模式和特征。因此，激活函数是神经网络能够处理非线性问题、进行更复杂计算的关键。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;简而言之，激活层是为矩阵运算的结果添加非线性的。常用的激活函数有三种，分别是阶跃函数、Sigmoid和ReLU。  &lt;br&gt;
&lt;img src=&#34;https://a233a2.github.io/p/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E6%BF%80%E6%B4%BB%E5%B1%82%E5%87%BD%E6%95%B0%E5%9B%BE.png&#34;
	width=&#34;854&#34;
	height=&#34;321&#34;
	srcset=&#34;https://a233a2.github.io/p/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E6%BF%80%E6%B4%BB%E5%B1%82%E5%87%BD%E6%95%B0%E5%9B%BE_hu13585017930976706445.png 480w, https://a233a2.github.io/p/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E6%BF%80%E6%B4%BB%E5%B1%82%E5%87%BD%E6%95%B0%E5%9B%BE_hu12689560312530861627.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;激活层函数图&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;266&#34;
		data-flex-basis=&#34;638px&#34;
	
&gt; &lt;br&gt;
其中，阶跃函数输出值是跳变的，且只有二值，较少使用；Sigmoid函数在当x的绝对值较大时，曲线的斜率变化很小（梯度消失），并且计算较复杂；ReLU是当前较为常用的激活函数。  &lt;br&gt;
激活函数具体是怎么计算的呢？ &lt;br&gt;
假如经过公式H=X*W1+b1计算得到的H值为：(1,-2,3,-4,7&amp;hellip;)，那么经过阶跃函数激活层后就会变为(1,0,1,0,1&amp;hellip;)，经过ReLU激活层之后会变为(1,0,3,0,7&amp;hellip;)。 &lt;br&gt;
需要注意的是，&lt;strong&gt;每个隐藏层计算（矩阵线性运算）之后，都需要加一层激活层，要不然该层线性计算是没有意义的。&lt;/strong&gt;   &lt;br&gt;
神经网络之所以能够处理复杂的任务，正是因为非线性激活函数的存在。激活函数将线性变换的输出“扭曲”成非线性，从而让网络能够捕捉数据中的非线性关系，例如在图像、语音、文本等复杂场景中。&lt;/p&gt;
&lt;h4 id=&#34;输出的正规化&#34;&gt;输出的正规化
&lt;/h4&gt;&lt;p&gt;现在我们的输出Y的值可能会是(3,1,0.1,0.5)这样的矩阵，诚然我们可以找到里边的最大值“3”，从而找到对应的分类为I，但是这并不直观。我们想让最终的输出为概率，也就是说可以生成像(90%,5%,2%,3%)这样的结果，这样做不仅可以找到最大概率的分类，而且可以知道各个分类计算的概率值。&lt;/p&gt;
&lt;h5 id=&#34;softmax正规化&#34;&gt;Softmax正规化
&lt;/h5&gt;&lt;p&gt;$$ S_i=\frac{e^i}{\sum{_je^j}} $$ &lt;br&gt;
简单来说分三步进行：（1）以e为底对所有元素求指数幂；（2）将所有指数幂求和；（3）分别将这些指数幂与该和做商。这样求出的结果中，所有元素的和一定为1，而每个元素可以代表概率值。  &lt;br&gt;
我们将使用这个计算公式做输出结果正规化处理的层叫做“Softmax”层。此时的神经网络将变成如上图所示：&lt;/p&gt;
&lt;h4 id=&#34;衡量输出的好坏&#34;&gt;衡量输出的好坏
&lt;/h4&gt;&lt;p&gt;通过Softmax层之后，我们得到了I，II，III和IV这四个类别分别对应的概率，但是要注意，这是神经网络计算得到的概率值结果，而非真实的情况。&lt;/p&gt;
&lt;p&gt;比如，Softmax输出的结果是(90%,5%,3%,2%)，真实的结果是(100%,0,0,0)。虽然输出的结果可以正确分类，但是与真实结果之间是有差距的，一个优秀的网络对结果的预测要无限接近于100%，为此，我们需要将Softmax输出结果的好坏程度做一个“量化”。  &lt;br&gt;
一种直观的解决方法，是用1减去Softmax输出的概率，比如1-90%=0.1。不过更为常用且巧妙的方法是，求对数的负数。   &lt;br&gt;
还是用90%举例，对数的负数就是：-log0.9=0.046  &lt;br&gt;
&lt;strong&gt;可以想见，概率越接近100%，该计算结果值越接近于0，说明结果越准确，该输出叫做“交叉熵损失（Cross Entropy Error）”。&lt;/strong&gt;     &lt;br&gt;
我们训练神经网络的目的，就是尽可能地减少这个“交叉熵损失”。  &lt;br&gt;
&lt;img src=&#34;https://a233a2.github.io/p/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E4%B8%A4%E5%B1%82%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%85%B8%E5%9E%8B%E7%BB%93%E6%9E%84.png&#34;
	width=&#34;891&#34;
	height=&#34;562&#34;
	srcset=&#34;https://a233a2.github.io/p/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E4%B8%A4%E5%B1%82%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%85%B8%E5%9E%8B%E7%BB%93%E6%9E%84_hu5277222655574983243.png 480w, https://a233a2.github.io/p/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E4%B8%A4%E5%B1%82%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%85%B8%E5%9E%8B%E7%BB%93%E6%9E%84_hu1044721732596226.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;两层神经网络典型结构&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;158&#34;
		data-flex-basis=&#34;380px&#34;
	
&gt;&lt;/p&gt;
&lt;h4 id=&#34;反向传播与参数优化&#34;&gt;反向传播与参数优化
&lt;/h4&gt;&lt;p&gt;上边的1~4节，讲述了神经网络的正向传播过程。一句话复习一下：神经网络的传播都是形如Y=WX+b的矩阵运算；为了给矩阵运算加入非线性，需要在隐藏层中加入激活层；输出层结果需要经过Softmax层处理为概率值，并通过交叉熵损失来量化当前网络的优劣。 &lt;br&gt;
算出交叉熵损失后，就要开始反向传播了。其实反向传播就是一个参数优化的过程，优化对象就是网络中的所有W和b（因为其他所有参数都是确定的）。 &lt;br&gt;
神经网络的神奇之处，就在于它可以自动做W和b的优化，在深度学习中，参数的数量有时会上亿，不过其优化的原理和我们这个两层神经网络是一样的。&lt;/p&gt;
&lt;h4 id=&#34;迭代&#34;&gt;迭代
&lt;/h4&gt;&lt;p&gt;神经网络需要反复迭代。 &lt;br&gt;
如上述例子中，第一次计算得到的概率是90%，交叉熵损失值是0.046；将该损失值反向传播，使W1,b1,W2,b2做相应微调；再做第二次运算，此时的概率可能就会提高到92%，相应地，损失值也会下降，然后再反向传播损失值，微调参数W1,b1,W2,b2。依次类推，损失值越来越小，直到我们满意为止。 &lt;br&gt;
此时我们就得到了理想的W1,b1,W2,b2。 &lt;br&gt;
此时如果将任意一组坐标作为输入，利用图4或图5的流程，就能得到分类结果。&lt;/p&gt;
&lt;h2 id=&#34;各类型神经网络&#34;&gt;各类型神经网络
&lt;/h2&gt;&lt;h3 id=&#34;cnn卷积神经网络30分钟入门&#34;&gt;CNN卷积神经网络30分钟入门
&lt;/h3&gt;&lt;p&gt;摘自：&lt;a class=&#34;link&#34; href=&#34;https://zhuanlan.zhihu.com/p/635438713&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;【深度学习-第2篇】CNN卷积神经网络30分钟入门！足够通俗易懂了吧（图解）&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&#34;从前馈神经网络到cnn&#34;&gt;从前馈神经网络到CNN
&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;前馈神经网络（Feedforward Neural Networks）&lt;strong&gt;是最基础的神经网络模型，也被称为&lt;/strong&gt;多层感知机（MLP）。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;它由多个神经元组成，每个神经元与前一层的所有神经元相连，形成一个“全连接”的结构。每个神经元会对其输入数据进行线性变换（通过权重矩阵），然后通过一个非线性函数（如ReLU或Sigmoid）进行激活。这就是前馈神经网络的基本操作。 &lt;br&gt;
&lt;img src=&#34;https://a233a2.github.io/p/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E4%B8%A4%E5%B1%82%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%85%B8%E5%9E%8B%E7%BB%93%E6%9E%84.png&#34;
	width=&#34;891&#34;
	height=&#34;562&#34;
	srcset=&#34;https://a233a2.github.io/p/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E4%B8%A4%E5%B1%82%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%85%B8%E5%9E%8B%E7%BB%93%E6%9E%84_hu5277222655574983243.png 480w, https://a233a2.github.io/p/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E4%B8%A4%E5%B1%82%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%85%B8%E5%9E%8B%E7%BB%93%E6%9E%84_hu1044721732596226.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;前馈神经网络结构示意&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;158&#34;
		data-flex-basis=&#34;380px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;卷积神经网络（Convolutional Neural Network, 简称CNN）开始。很大程度上，是由于CNN的基本组成部分与前馈神经网络有很紧密的关联，甚至可以说，CNN就是一种特殊的前馈神经网络。 &lt;br&gt;
这两者的主要区别在于，CNN在前馈神经网络的基础上加入了&lt;strong&gt;卷积层&lt;/strong&gt;和&lt;strong&gt;池化层&lt;/strong&gt;（下边会讲到），以便&lt;strong&gt;更好地处理图像等具有空间结构的数据。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;现在画图说明一下。对于前馈神经网络，我们可以将简化后的网络结构如下图表示： &lt;br&gt;
&lt;img src=&#34;https://a233a2.github.io/p/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E5%89%8D%E9%A6%88%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%AE%80%E5%8C%96.png&#34;
	width=&#34;617&#34;
	height=&#34;445&#34;
	srcset=&#34;https://a233a2.github.io/p/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E5%89%8D%E9%A6%88%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%AE%80%E5%8C%96_hu9534132991121884414.png 480w, https://a233a2.github.io/p/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E5%89%8D%E9%A6%88%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%AE%80%E5%8C%96_hu12127138679068705312.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;前馈神经网络的简易表示&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;138&#34;
		data-flex-basis=&#34;332px&#34;
	
&gt;    &lt;br&gt;
当然，【全连接层-ReLU】可以有多个，此时网络结构可以表示为： &lt;br&gt;
&lt;img src=&#34;https://a233a2.github.io/p/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E5%A4%9A%E5%85%A8%E9%93%BE%E6%8E%A5%E5%B1%82%E7%9A%84%E5%89%8D%E9%A6%88%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C.png&#34;
	width=&#34;880&#34;
	height=&#34;574&#34;
	srcset=&#34;https://a233a2.github.io/p/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E5%A4%9A%E5%85%A8%E9%93%BE%E6%8E%A5%E5%B1%82%E7%9A%84%E5%89%8D%E9%A6%88%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C_hu17755815143800048140.png 480w, https://a233a2.github.io/p/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E5%A4%9A%E5%85%A8%E9%93%BE%E6%8E%A5%E5%B1%82%E7%9A%84%E5%89%8D%E9%A6%88%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C_hu4776322760612417449.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;多全链接层的前馈神经网络&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;153&#34;
		data-flex-basis=&#34;367px&#34;
	
&gt;    &lt;br&gt;
简单地说，CNN就是在此基础上，将全连接层换成卷积层，并在ReLU层之后加入池化层（非必须），那么一个基本的CNN结构就可以表示成这样： &lt;br&gt;
&lt;img src=&#34;https://a233a2.github.io/p/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/N%E5%B1%82%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C.png&#34;
	width=&#34;879&#34;
	height=&#34;557&#34;
	srcset=&#34;https://a233a2.github.io/p/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/N%E5%B1%82%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C_hu14598001535105996045.png 480w, https://a233a2.github.io/p/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/N%E5%B1%82%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C_hu11187312952505986625.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;N层卷积神经网络&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;157&#34;
		data-flex-basis=&#34;378px&#34;
	
&gt;&lt;/p&gt;
&lt;h4 id=&#34;卷积层&#34;&gt;卷积层
&lt;/h4&gt;&lt;p&gt;使用卷积是为了更好的处理图像等信息。若使用全连接前馈神经网络来处理图像，会使得参数太多、不利于表达空间上的结构。另外难以反应平移不变性。CNN由于权重共享，可以无论特征在何处出现都能被检测到，从而提供了一种平移不变性。另外难以表征抽象层级。CNN通过多个卷积层和池化层的叠加，可以从低级的边缘和纹理特征逐渐抽取出高级的语义特征。这个特性使得CNN非常适合于处理图像等需要多层抽象表示的数据。  &lt;br&gt;
卷积的过程，其实是一种滤波的过程，所以卷积核（Convolution Kernel）还有一个别名叫做Filter，也就是滤波器。     &lt;br&gt;
&lt;strong&gt;当一组数像滑窗一样滑过另外一组数时，将对应的数据相乘并求和得到一组新的数，这个过程必然和卷积有着莫大的关系。&lt;/strong&gt; &lt;br&gt;
其中权重系数都为1/3，也就是均值滤波的过程。变换不同的权重系数，滤波器将展现出不同的滤波特性。所以我们又可以得到一个结论：当权重系数（卷积核）的参数改变时，它可以提取的特征类型也会改变。所以训练卷积神经网络时，实质上训练的是卷积核的参数。  &lt;br&gt;
&lt;img src=&#34;https://a233a2.github.io/p/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E5%8D%B7%E7%A7%AF%E6%A0%B8%E8%BF%90%E7%AE%97%E8%BF%87%E7%A8%8B-%E4%BA%8C%E7%BB%B4png.png&#34;
	width=&#34;607&#34;
	height=&#34;440&#34;
	srcset=&#34;https://a233a2.github.io/p/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E5%8D%B7%E7%A7%AF%E6%A0%B8%E8%BF%90%E7%AE%97%E8%BF%87%E7%A8%8B-%E4%BA%8C%E7%BB%B4png_hu3303549474147394459.png 480w, https://a233a2.github.io/p/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E5%8D%B7%E7%A7%AF%E6%A0%B8%E8%BF%90%E7%AE%97%E8%BF%87%E7%A8%8B-%E4%BA%8C%E7%BB%B4png_hu7281252247270003854.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;卷积核运算过程-二维&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;137&#34;
		data-flex-basis=&#34;331px&#34;
	
&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;1.定义一个卷积核：卷积核是一个小的矩阵（例如3x3或5x5），包含一些数字。这个卷积核的作用是在图像中识别特定类型的特征，例如边缘、线条等，也可能是难以描述的抽象特征。
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;2.卷积核滑过图像：卷积操作开始时，卷积核会被放置在图像的左上角。然后，它会按照一定的步长（stride）在图像上滑动，可以是从左到右，也可以是从上到下。步长定义了卷积核每次移动的距离。
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;3.计算点积：在卷积核每个位置，都会计算卷积核和图像对应部分的点积。这就是将卷积核中的每个元素与图像中对应位置的像素值相乘，然后将所有乘积相加。
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;4.生成新的特征图：每次计算的点积结果被用来构建一个新的图像，也称为特征图或卷积图。
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;5.重复以上过程：通常在一个 CNN 中，我们会有多个不同的卷积核同时进行卷积操作。这意味着我们会得到多个特征图，每个特征图捕捉了原始图像中的不同特征。
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h4 id=&#34;relu在cnn中的位置&#34;&gt;ReLU在CNN中的位置
&lt;/h4&gt;&lt;p&gt;卷积层和全连接一样，也是一种线性变换，无论进行多少次这样的操作，都只能获得输入数据的线性组合。如果没有非线性的激活函数，那么即使是多层的神经网络，在理论上也可以被一个单层的神经网络所表达，这极大地限制了网络的表达能力。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;ReLU函数是一个非线性函数，只保留正数元素，将负数元素设置为0。这种简单的修正线性单元具有许多优点，例如，它能够缓解梯度消失问题，计算速度快，同时ReLU的输出是稀疏的，这有助于模型的正则化。ReLU的响应函数图像如下： &lt;br&gt;
&lt;img src=&#34;https://a233a2.github.io/p/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/RELU.png&#34;
	width=&#34;390&#34;
	height=&#34;305&#34;
	srcset=&#34;https://a233a2.github.io/p/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/RELU_hu4507551843322250478.png 480w, https://a233a2.github.io/p/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/RELU_hu15126746602982748460.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;RELU&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;127&#34;
		data-flex-basis=&#34;306px&#34;
	
&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;化繁为简的池化层&#34;&gt;化繁为简的池化层
&lt;/h4&gt;&lt;p&gt;ReLU激活层之后就是池化层。 &lt;br&gt;
池化层的主要作用是对非线性激活后的结果进行降采样，以减少参数的数量，避免过拟合，并提高模型的处理速度。 &lt;br&gt;
池化层主要采用最大池化（Max Pooling）、平均池化（Average Pooling）等方式，对特征图进行操作。以最常见的最大池化为例，我们选择一个窗口（比如 2x2）在特征图上滑动，每次选取窗口中的最大值作为输出，这就是最大池化的工作方式： &lt;br&gt;
&lt;img src=&#34;https://a233a2.github.io/p/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E6%B1%A0%E5%8C%96%E5%B1%82.png&#34;
	width=&#34;516&#34;
	height=&#34;300&#34;
	srcset=&#34;https://a233a2.github.io/p/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E6%B1%A0%E5%8C%96%E5%B1%82_hu1649860995526684222.png 480w, https://a233a2.github.io/p/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E6%B1%A0%E5%8C%96%E5%B1%82_hu6459201957639587312.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;池化层&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;172&#34;
		data-flex-basis=&#34;412px&#34;
	
&gt;&lt;br&gt;
大致可以看出，经过池化计算后的图像，基本就是左侧特征图的“低像素版”结果。也就是说池化运算能够保留最强烈的特征，并大大降低数据体量。&lt;/p&gt;
&lt;p&gt;到现在，“卷积层→ReLU→池化层”这样一个CNN网络中的基本组成单元的基础概念就讲完了。但是需要注意，卷积层、ReLU和池化层的组合是一种常见模式，但不是唯一的方式。比如池化层作为降低网络复杂程度的计算环节，在算力硬件条件越来越好的当下，有些时候是可以减少采用次数的，也就是池化层可以在部分层设置、部分层不设置。 &lt;br&gt;
&lt;img src=&#34;CNN全部.gif&#34; alt=&#34;动画演示&#34; width=&#34;500&#34; height=&#34;auto&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;关于输出层&#34;&gt;关于输出层
&lt;/h4&gt;&lt;p&gt;在卷积神经网络中，最后一层（或者说最后一部分）通常被称为输出层。这个层的作用是将之前所有层的信息集合起来，产生最终的预测结果。&lt;/p&gt;
&lt;p&gt;对于CNN进行分类任务时，输出部分的网络结构通常是一个或多个全连接层，然后连接Softmax。&lt;/p&gt;
&lt;p&gt;当然，如果想要从卷积层过渡到全连接层，你需要对卷积层的输出进行“展平”处理，简而言之就是将二维数据逐行串起来，变成一维数据。&lt;/p&gt;
&lt;p&gt;由于此时数据经过多层卷积和池化操作，数据量已大大减少，所以全连接层设计的参数就不会有那么多了。&lt;/p&gt;
&lt;h4 id=&#34;由基础模块搭建摩天大楼&#34;&gt;由基础模块搭建摩天大楼
&lt;/h4&gt;&lt;p&gt;在实际应用中，CNN网络往往是由多个卷积层构成，后续再缀接卷积层，则就是将上一层的输出作为后续的输入，然后重复“输入层→卷积层→ReLU→池化层”这个过程，当然池化层是非必须的。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>算法挖坑填坑</title>
        <link>https://a233a2.github.io/p/%E7%AE%97%E6%B3%95%E6%8C%96%E5%9D%91%E5%A1%AB%E5%9D%91/</link>
        <pubDate>Fri, 08 Nov 2024 00:00:00 +0000</pubDate>
        
        <guid>https://a233a2.github.io/p/%E7%AE%97%E6%B3%95%E6%8C%96%E5%9D%91%E5%A1%AB%E5%9D%91/</guid>
        <description>&lt;h3 id=&#34;反步法&#34;&gt;反步法
&lt;/h3&gt;&lt;p&gt;本质上也是利用&lt;strong&gt;李雅普诺夫第二方法&lt;/strong&gt;对系统的控制器进行状态反馈设计。通过对系统的每一个状态方程依次进行迭代设计，最终串联成一个控制方案。 &lt;br&gt;
反步法(Backsteping method)又称为后推法，是一种由前往后递推的设计方法，该方法所对应的系统是通过串联形成的非线性系统，最初由科克托维奇(Kokotovic)于1991年提出，该方法的提出最初是用于线性系统，随着研究的深入发现它针对非线性系统也有很好的控制。    &lt;br&gt;
它的设计思想是将复杂的系统分解成若干个不超过原系统阶数的子系统，然后根据Lyapunov稳定性定理，针对每个子系统设计出中间的虚拟控制量，一直“反推”至整个系统，从而设计出系统的总控制律。&lt;/p&gt;
&lt;h4 id=&#34;简单的二阶非线性系统&#34;&gt;简单的二阶非线性系统
&lt;/h4&gt;&lt;p&gt;对于一个简单的二阶非线性系统：   &lt;br&gt;
控制目标：使系统控制到原点处。（如果要控制在别的地方，先进行方程的坐标变换到原点即可）&lt;/p&gt;
&lt;p&gt;对于二阶系统的反步法，我们对两个方程分别分两步设计进行：
第一步，对第一个方程，将$x_2$看作输入。设计一个反馈控制率$x_2=\phi \left( x_1 \right)$ ，使得第一个方程稳定； &lt;br&gt;
第二步，对第二个方程，将$u$看做输入，设计一个反馈控制率，使得第二个方程也稳定；&lt;br&gt;
最后，得到的最终反馈控制率$u$，可以使得整个系统稳定。&lt;/p&gt;
&lt;h3 id=&#34;卡尔曼滤波算法&#34;&gt;卡尔曼滤波算法
&lt;/h3&gt;&lt;h3 id=&#34;扩展卡尔曼滤波算法ekf&#34;&gt;扩展卡尔曼滤波算法（EKF）
&lt;/h3&gt;&lt;h3 id=&#34;傅里叶变换&#34;&gt;傅里叶变换
&lt;/h3&gt;&lt;h3 id=&#34;快速傅里叶变换法&#34;&gt;快速傅里叶变换法
&lt;/h3&gt;&lt;h3 id=&#34;滑膜算法&#34;&gt;滑膜算法
&lt;/h3&gt;&lt;h3 id=&#34;模糊pid算法&#34;&gt;模糊PID算法
&lt;/h3&gt;</description>
        </item>
        <item>
        <title>工程数学基础</title>
        <link>https://a233a2.github.io/p/%E5%B7%A5%E7%A8%8B%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/</link>
        <pubDate>Thu, 24 Oct 2024 00:00:00 +0000</pubDate>
        
        <guid>https://a233a2.github.io/p/%E5%B7%A5%E7%A8%8B%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/</guid>
        <description>&lt;h2 id=&#34;一些概念&#34;&gt;一些概念
&lt;/h2&gt;&lt;h3 id=&#34;范数&#34;&gt;范数
&lt;/h3&gt;&lt;h3 id=&#34;高斯函数&#34;&gt;高斯函数
&lt;/h3&gt;&lt;h3 id=&#34;最小二乘法&#34;&gt;最小二乘法
&lt;/h3&gt;&lt;h3 id=&#34;最小二乘-矩阵形式推导&#34;&gt;最小二乘-矩阵形式推导
&lt;/h3&gt;</description>
        </item>
        <item>
        <title>DRCAN-Learn-Blog-Advance</title>
        <link>https://a233a2.github.io/p/drcan-learn-blog-advance/</link>
        <pubDate>Wed, 23 Oct 2024 00:00:00 +0000</pubDate>
        
        <guid>https://a233a2.github.io/p/drcan-learn-blog-advance/</guid>
        <description>&lt;img src="https://a233a2.github.io/p/drcan-learn-blog-advance/1-1.jpg" alt="Featured image of post DRCAN-Learn-Blog-Advance" /&gt;&lt;p&gt;此Blog记录了本人按照DRCAN视频推荐的学习顺序来系统学习DRCAN发表的控制相关视频。博客作为笔记使用。&lt;/p&gt;
&lt;h3 id=&#34;1-状态空间表达&#34;&gt;1-状态空间表达
&lt;/h3&gt;&lt;p&gt;以一个质量块-弹簧-阻尼器系统来进行分析：&lt;br&gt;
&lt;img src=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/1-1.jpg&#34;
	width=&#34;2182&#34;
	height=&#34;3086&#34;
	srcset=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/1-1_hu7229884839809532162.jpg 480w, https://a233a2.github.io/p/drcan-learn-blog-advance/1-1_hu1691059223504960444.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;1&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;70&#34;
		data-flex-basis=&#34;169px&#34;
	
&gt;   &lt;br&gt;
状态空间表达是即为：&lt;strong&gt;系统输入输出状态变量的一个集合，用一阶微分方程的形式表达出来。&lt;/strong&gt;
&lt;img src=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/1-2.png&#34;
	width=&#34;2182&#34;
	height=&#34;1753&#34;
	srcset=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/1-2_hu1484246055524713960.png 480w, https://a233a2.github.io/p/drcan-learn-blog-advance/1-2_hu12410177076624011512.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;2&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;124&#34;
		data-flex-basis=&#34;298px&#34;
	
&gt;
状态空间表达与传递函数之间的关系：包括转换方程，以及重要结论：&lt;strong&gt;|SI-A|矩阵的特征值就是传递函数的极点！&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;2-状态空间方程的解&#34;&gt;2-状态空间方程的解
&lt;/h3&gt;&lt;p&gt;有点难以推导且认为推导过程不太重要&lt;br&gt;
&lt;img src=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/21.png&#34;
	width=&#34;2182&#34;
	height=&#34;3086&#34;
	srcset=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/21_hu9857301536328584946.png 480w, https://a233a2.github.io/p/drcan-learn-blog-advance/21_hu17728875442273112032.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;2&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;70&#34;
		data-flex-basis=&#34;169px&#34;
	
&gt;&lt;br&gt;
&lt;img src=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/22.png&#34;
	width=&#34;2182&#34;
	height=&#34;3086&#34;
	srcset=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/22_hu7424707334767718386.png 480w, https://a233a2.github.io/p/drcan-learn-blog-advance/22_hu4360937834505168880.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;2&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;70&#34;
		data-flex-basis=&#34;169px&#34;
	
&gt;&lt;br&gt;
&lt;img src=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/23.png&#34;
	width=&#34;2182&#34;
	height=&#34;3086&#34;
	srcset=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/23_hu17122972239720574622.png 480w, https://a233a2.github.io/p/drcan-learn-blog-advance/23_hu13650029549609199388.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;2&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;70&#34;
		data-flex-basis=&#34;169px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;3-相图-相轨迹&#34;&gt;3-相图-相轨迹
&lt;/h3&gt;&lt;p&gt;相轨迹是系统的状态随时间变化的轨迹。当时间变化时，系统的状态点在状态空间中移动，这条移动的轨迹就是相轨迹。&lt;/p&gt;
&lt;p&gt;对于一个阻尼摆，系统的能量会逐渐衰减，最终趋于静止。其相轨迹不会形成闭合的曲线，而是一个逐渐收缩的螺旋，最终收敛到平衡点（摆静止的位置）。这说明系统是稳定的，且有能量损失。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/31.png&#34;
	width=&#34;2182&#34;
	height=&#34;3086&#34;
	srcset=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/31_hu425951968313780383.png 480w, https://a233a2.github.io/p/drcan-learn-blog-advance/31_hu16643900213948508456.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;2&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;70&#34;
		data-flex-basis=&#34;169px&#34;
	
&gt;&lt;br&gt;
可以通过分析导数正负来判别该点的稳定性，后面结论重要一些。&lt;br&gt;
&lt;img src=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/32.png&#34;
	width=&#34;2201&#34;
	height=&#34;1299&#34;
	srcset=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/32_hu1485192269137500098.png 480w, https://a233a2.github.io/p/drcan-learn-blog-advance/32_hu9250088313912901889.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;2&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;169&#34;
		data-flex-basis=&#34;406px&#34;
	
&gt;&lt;br&gt;
特殊的一种鞍点。在此令了上述x与y的导来确定x的输出？这个有些复杂。应该是用到了线性代数的坐标变换 看不太懂。。看特征值直观点。 &lt;br&gt;
&lt;img src=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/33.png&#34;
	width=&#34;2039&#34;
	height=&#34;973&#34;
	srcset=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/33_hu10825206731962301851.png 480w, https://a233a2.github.io/p/drcan-learn-blog-advance/33_hu10146504456115275453.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;2&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;209&#34;
		data-flex-basis=&#34;502px&#34;
	
&gt;&lt;br&gt;
对于复数的，而实部为0的特征值。是一个椭圆，Fixed Point为Center。 &lt;br&gt;
&lt;img src=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/34.png&#34;
	width=&#34;2176&#34;
	height=&#34;891&#34;
	srcset=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/34_hu6089759772534058434.png 480w, https://a233a2.github.io/p/drcan-learn-blog-advance/34_hu14925947017838707856.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;2&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;244&#34;
		data-flex-basis=&#34;586px&#34;
	
&gt;&lt;br&gt;
特征值复数但是实部不为0的时候。 &lt;br&gt;
&lt;img src=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/35.png&#34;
	width=&#34;2154&#34;
	height=&#34;1163&#34;
	srcset=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/35_hu16777777308420433622.png 480w, https://a233a2.github.io/p/drcan-learn-blog-advance/35_hu7477347720013798291.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;2&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;185&#34;
		data-flex-basis=&#34;444px&#34;
	
&gt;&lt;br&gt;
总结上述情况。&lt;/p&gt;
&lt;h3 id=&#34;35-连续系统的离散化&#34;&gt;3.5-连续系统的离散化
&lt;/h3&gt;&lt;p&gt;采样频率至少要为原系统频率的两倍，这样才能重建出原信号。否则可能出现混叠现象，不能复现原系统变化趋势。（2倍只是下限理论值，实际工程中选取5-10倍） &lt;br&gt;
Zero Order Hold （ZOH零阶保持器），使得控制量在一个控制周期内保持不变。&lt;/p&gt;
&lt;p&gt;采样周期要与数据处理控制时间相匹配。若数据读入处理需要50ms，则小于50ms的采样周期将变得没有意义。 &lt;br&gt;
&lt;img src=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/3.5-1.png&#34;
	width=&#34;1874&#34;
	height=&#34;1214&#34;
	srcset=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/3.5-1_hu3054599139696670051.png 480w, https://a233a2.github.io/p/drcan-learn-blog-advance/3.5-1_hu17887664043837265195.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;2&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;154&#34;
		data-flex-basis=&#34;370px&#34;
	
&gt;&lt;br&gt;
Error   ：G(T) = ∫(0,T) exp(Aτ) dτ·B
状态空间的解输出，在离散系统下的表达形式。离散系统下不关心t，而着重与每个周期。系统输入u在一个周期内可以看作一个常数（ZOH的作用）。所以可以提取出来。&lt;/p&gt;
&lt;p&gt;使用软件将连续系统转化为离散系统 指令&lt;strong&gt;c2d(sys,f)&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;4-相图-相轨迹动态系统分析phase-portrait爱情故事&#34;&gt;4-相图-相轨迹动态系统分析Phase Portrait爱情故事
&lt;/h3&gt;&lt;p&gt;相轨迹&lt;/p&gt;
&lt;h3 id=&#34;5-系统的可控性&#34;&gt;5-系统的可控性
&lt;/h3&gt;&lt;p&gt;讲解了对于状态空间表达的秩判据的相关内容。秩判据的相关数学证明: &lt;br&gt;
另外讲解了定义的可控性是何种意义上的可控性。 &lt;br&gt;
&lt;img src=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/51.jpg&#34;
	width=&#34;2182&#34;
	height=&#34;2569&#34;
	srcset=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/51_hu14473934175636827000.jpg 480w, https://a233a2.github.io/p/drcan-learn-blog-advance/51_hu1429475142258959569.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;2&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;84&#34;
		data-flex-basis=&#34;203px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;6-李雅普诺夫稳定性&#34;&gt;6-李雅普诺夫稳定性
&lt;/h3&gt;&lt;p&gt;讲解了李雅普诺夫稳定性的严禁数学定义。以及对于状态转移矩阵A矩阵特征值的几种形式来定义李雅普诺夫的集中稳定性。 &lt;br&gt;
针对非线性系统，区别于传统解微分方程，采用李雅普诺夫第二法进行解决，在此处进行了简单的介绍。 &lt;br&gt;
&lt;img src=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/61.jpg&#34;
	width=&#34;2182&#34;
	height=&#34;3086&#34;
	srcset=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/61_hu5641696737157067.jpg 480w, https://a233a2.github.io/p/drcan-learn-blog-advance/61_hu2161642686435310383.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;2&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;70&#34;
		data-flex-basis=&#34;169px&#34;
	
&gt;&lt;br&gt;
&lt;img src=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/62.jpg&#34;
	width=&#34;2182&#34;
	height=&#34;1475&#34;
	srcset=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/62_hu8693756144219456126.jpg 480w, https://a233a2.github.io/p/drcan-learn-blog-advance/62_hu16010987264924604746.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;2&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;147&#34;
		data-flex-basis=&#34;355px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;7-线性控制器设计&#34;&gt;7-线性控制器设计
&lt;/h3&gt;&lt;p&gt;这部分便是之前现代控制理论方面的根据期望的特征值来确定系统的不同k增益的输入。
令u=kx，对期望的$\lambda$列出闭环矩阵Acl，对Acl求特征值?（应该是 太久远了 有点遗忘）
列出以$\lambda$为未知量的方程，结合期望$\lambda$的特征值方程对应相等。求得k矩阵。
&lt;img src=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/71.jpg&#34;
	width=&#34;2182&#34;
	height=&#34;3086&#34;
	srcset=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/71_hu12605214141889279940.jpg 480w, https://a233a2.github.io/p/drcan-learn-blog-advance/71_hu13337817652409191429.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;2&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;70&#34;
		data-flex-basis=&#34;169px&#34;
	
&gt; &lt;br&gt;
&lt;img src=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/72.jpg&#34;
	width=&#34;2182&#34;
	height=&#34;2716&#34;
	srcset=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/72_hu14034203957898177910.jpg 480w, https://a233a2.github.io/p/drcan-learn-blog-advance/72_hu13401945833860414619.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;2&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;80&#34;
		data-flex-basis=&#34;192px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;8-lqr控制liner-quadratic-regulator&#34;&gt;8-LQR控制（Liner Quadratic Regulator）
&lt;/h3&gt;&lt;p&gt;线性二次型调节器。是一种对控制系统的目标$\lambda$进行确定的最优控制算法。 &lt;br&gt;
其设置了一种惩罚函数J，通过求得MinJ来确定系统最优的$\lambda$。进而进行线性控制器的设计。
&lt;img src=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/81.jpg&#34;
	width=&#34;2182&#34;
	height=&#34;1475&#34;
	srcset=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/81_hu16155908660427802456.jpg 480w, https://a233a2.github.io/p/drcan-learn-blog-advance/81_hu303810490908243574.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;2&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;147&#34;
		data-flex-basis=&#34;355px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;9-状态观测器设计luenberger为例&#34;&gt;9-状态观测器设计（Luenberger为例）
&lt;/h3&gt;&lt;p&gt;LQR控制等线性控制u=-kx的前提是状态x全部可测。而对于状态不可测的系统需要观测器Observer &lt;br&gt;
也是之前现代控制理论的必做题类型。观测器建立了一个新的反馈系统目标是使得观测值与实际值相差的err为0。      &lt;br&gt;
观测器也就是 根据系统现有的输入和输出 来估计系统的状态。 &lt;br&gt;
&lt;img src=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/91.jpg&#34;
	width=&#34;2182&#34;
	height=&#34;3086&#34;
	srcset=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/91_hu17671702461150397579.jpg 480w, https://a233a2.github.io/p/drcan-learn-blog-advance/91_hu3864620464621549933.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;2&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;70&#34;
		data-flex-basis=&#34;169px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;另外根据之前的阻尼器-弹簧-质量块经典系统进行了观测器设计，设定两个特征值期望为-1 -1。 &lt;br&gt;
&lt;img src=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/92.jpg&#34;
	width=&#34;2182&#34;
	height=&#34;2448&#34;
	srcset=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/92_hu1447313957454599147.jpg 480w, https://a233a2.github.io/p/drcan-learn-blog-advance/92_hu10687051141730272077.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;2&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;89&#34;
		data-flex-basis=&#34;213px&#34;
	
&gt; &lt;br&gt;
Simulink仿真 &lt;br&gt;
&lt;img src=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/93.jpg&#34;
	width=&#34;1644&#34;
	height=&#34;1102&#34;
	srcset=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/93_hu10858130551705957268.jpg 480w, https://a233a2.github.io/p/drcan-learn-blog-advance/93_hu7284049849754470848.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;2&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;149&#34;
		data-flex-basis=&#34;358px&#34;
	
&gt; &lt;br&gt;
观测器状态空间是目标$\lambda$=-1 -1求解出来的。
Z2状态不可测，直接运行时，估计值与真实值完全重合。
在Z2hat估计值的地方对z2估计值进行赋初值为1的操作时，可以认为z2开始时估计值与真实值有了偏差。 &lt;br&gt;
此时，系统的输出图像有了偏差，z1与z2估计值有关，所以两个图像全部出现了偏差。且能够在后续过程中完成跟随观测。
&lt;img src=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/94.jpg&#34;
	width=&#34;1543&#34;
	height=&#34;786&#34;
	srcset=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/94_hu10379666068161534470.jpg 480w, https://a233a2.github.io/p/drcan-learn-blog-advance/94_hu6326178576858594335.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;2&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;196&#34;
		data-flex-basis=&#34;471px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;10-可观测性与分离原理&#34;&gt;10-可观测性与分离原理
&lt;/h3&gt;&lt;p&gt;&lt;img src=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/10.1.jpg&#34;
	width=&#34;2182&#34;
	height=&#34;3086&#34;
	srcset=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/10.1_hu11389514122240884104.jpg 480w, https://a233a2.github.io/p/drcan-learn-blog-advance/10.1_hu7757880031523196896.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;2&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;70&#34;
		data-flex-basis=&#34;169px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/10.2.jpg&#34;
	width=&#34;2182&#34;
	height=&#34;1039&#34;
	srcset=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/10.2_hu10640356901182428119.jpg 480w, https://a233a2.github.io/p/drcan-learn-blog-advance/10.2_hu1059086410672742270.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;2&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;210&#34;
		data-flex-basis=&#34;504px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;12-非线性理论基础&#34;&gt;12-非线性理论基础
&lt;/h3&gt;&lt;p&gt;&lt;img src=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/12.1.jpg&#34;
	width=&#34;2182&#34;
	height=&#34;2658&#34;
	srcset=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/12.1_hu18315314502710110412.jpg 480w, https://a233a2.github.io/p/drcan-learn-blog-advance/12.1_hu15574820486102920819.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;2&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;82&#34;
		data-flex-basis=&#34;197px&#34;
	
&gt;&lt;br&gt;
&amp;hellip;.介绍了正定 半正定 负定 半负定的各种函数。 &lt;br&gt;
&lt;img src=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/12.2.jpg&#34;
	width=&#34;2182&#34;
	height=&#34;3086&#34;
	srcset=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/12.2_hu5828067736462640113.jpg 480w, https://a233a2.github.io/p/drcan-learn-blog-advance/12.2_hu4104943686041735830.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;2&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;70&#34;
		data-flex-basis=&#34;169px&#34;
	
&gt;&lt;br&gt;
此处在设计Lyapunov函数的时候使用到了物理上的能量概念，动能与重力势能相结合搞出来了一个真正的能量函数V(x)&lt;/p&gt;
&lt;h3 id=&#34;13-不变性原理&#34;&gt;13-不变性原理
&lt;/h3&gt;&lt;p&gt;&lt;img src=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/13.1.jpg&#34;
	width=&#34;2182&#34;
	height=&#34;3086&#34;
	srcset=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/13.1_hu11392919047860221812.jpg 480w, https://a233a2.github.io/p/drcan-learn-blog-advance/13.1_hu9436036872624217216.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;2&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;70&#34;
		data-flex-basis=&#34;169px&#34;
	
&gt;&lt;br&gt;
对Lyapunov的稳定性判定分了很多的类，抽时间再整理一下。&lt;/p&gt;
&lt;h3 id=&#34;14-非线性稳定性设计&#34;&gt;14-非线性稳定性设计
&lt;/h3&gt;&lt;p&gt;&lt;img src=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/14.1.jpg&#34;
	width=&#34;2182&#34;
	height=&#34;3086&#34;
	srcset=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/14.1_hu7550965999035877927.jpg 480w, https://a233a2.github.io/p/drcan-learn-blog-advance/14.1_hu14867590210017360200.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;2&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;70&#34;
		data-flex-basis=&#34;169px&#34;
	
&gt;&lt;br&gt;
设计如下的非线性系统。 &lt;br&gt;
&lt;img src=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/14.2.jpg&#34;
	width=&#34;606&#34;
	height=&#34;463&#34;
	srcset=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/14.2_hu1399004960012830589.jpg 480w, https://a233a2.github.io/p/drcan-learn-blog-advance/14.2_hu2155581303139813249.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;2&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;130&#34;
		data-flex-basis=&#34;314px&#34;
	
&gt;&lt;br&gt;
将三种u的处理方式整合成三个子系统。 &lt;br&gt;
1 直接线性化处理。 2 李雅普诺夫直接法设计  3 李雅普诺夫直接法直接消除非ND项。 &lt;br&gt;
&lt;img src=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/14.3.jpg&#34;
	width=&#34;521&#34;
	height=&#34;518&#34;
	srcset=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/14.3_hu1171698137704150032.jpg 480w, https://a233a2.github.io/p/drcan-learn-blog-advance/14.3_hu14012392669276592536.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;2&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;100&#34;
		data-flex-basis=&#34;241px&#34;
	
&gt;&lt;br&gt;
设定仿真时间10s，x初始值为10； &lt;br&gt;
输出状态变量为右图所示，输入为左图所示。 &lt;br&gt;
1黄色线条 直接线性化处理。 2橙色线条 李雅普诺夫直接法设计  3蓝色线条 李雅普诺夫直接法直接消除非ND项。
&lt;img src=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/14.4.jpg&#34;
	width=&#34;1399&#34;
	height=&#34;639&#34;
	srcset=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/14.4_hu8779065921020863191.jpg 480w, https://a233a2.github.io/p/drcan-learn-blog-advance/14.4_hu3667027648305391904.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;2&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;218&#34;
		data-flex-basis=&#34;525px&#34;
	
&gt;&lt;br&gt;
可以看到直接线性化处理的方式简单粗暴，因为输入存在x的三次方所以导致开始时输入值非常大。这是难以实现的。 &lt;br&gt;
对于李雅普诺夫直接法设计的输入以及输出较为合理。 &lt;br&gt;
李雅普诺夫分析后直接消除非ND项的做法较直接线性化处理有一定优势，但是稳态效果不好。&lt;/p&gt;
&lt;h3 id=&#34;15-非线性反步法设计-important&#34;&gt;15-非线性反步法设计-Important
&lt;/h3&gt;&lt;p&gt;反步法设计可以说是&lt;strong&gt;非线性链式系统&lt;/strong&gt;的通用设计方法。 &lt;br&gt;
如下图，输入可以直接控制X2的状态，但是输入无法直接影响状态X1。  &lt;br&gt;
&lt;img src=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/15.1.jpg&#34;
	width=&#34;2182&#34;
	height=&#34;3086&#34;
	srcset=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/15.1_hu10678219543084000214.jpg 480w, https://a233a2.github.io/p/drcan-learn-blog-advance/15.1_hu7128712128322331439.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;2&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;70&#34;
		data-flex-basis=&#34;169px&#34;
	
&gt;&lt;br&gt;
对两个引入的状态进行稳定性分析。 &lt;br&gt;
&lt;img src=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/15.2.jpg&#34;
	width=&#34;2182&#34;
	height=&#34;1508&#34;
	srcset=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/15.2_hu17337528155372937008.jpg 480w, https://a233a2.github.io/p/drcan-learn-blog-advance/15.2_hu2897981912637891707.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;2&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;144&#34;
		data-flex-basis=&#34;347px&#34;
	
&gt;&lt;br&gt;
Dr.Can设计的Simulink仿真模型。 &lt;br&gt;
&lt;img src=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/15.3.jpg&#34;
	width=&#34;1709&#34;
	height=&#34;1100&#34;
	srcset=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/15.3_hu1036969065662031353.jpg 480w, https://a233a2.github.io/p/drcan-learn-blog-advance/15.3_hu10041066303553636064.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;Dr.Can设计的Simulink仿真模型&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;155&#34;
		data-flex-basis=&#34;372px&#34;
	
&gt;&lt;br&gt;
对例题进行分析 &lt;br&gt;
&lt;img src=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/15.4.jpg&#34;
	width=&#34;2182&#34;
	height=&#34;3086&#34;
	srcset=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/15.4_hu2176705203236782246.jpg 480w, https://a233a2.github.io/p/drcan-learn-blog-advance/15.4_hu2396978591001888174.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;2&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;70&#34;
		data-flex-basis=&#34;169px&#34;
	
&gt; &lt;br&gt;
&lt;img src=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/15.5.jpg&#34;
	width=&#34;2182&#34;
	height=&#34;959&#34;
	srcset=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/15.5_hu15441917180270956965.jpg 480w, https://a233a2.github.io/p/drcan-learn-blog-advance/15.5_hu5027431554718673641.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;2&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;227&#34;
		data-flex-basis=&#34;546px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;16-非线性自适应控制器&#34;&gt;16-非线性自适应控制器
&lt;/h3&gt;&lt;p&gt;自认为的自适应控制器简化设计步骤： &lt;br&gt;
自适应控制器是处理a参数未知的情况。通过设计一个估计值，再引入估计误差。 &lt;br&gt;
估计误差的导数因为a参数缓慢变化，所以a的导数为0。但是不禁让人思考a变化迅速的时候呢？    &lt;br&gt;
对估计误差与原本控制误差进行联合Lyapunov稳定行为分析。设计u使得李函数的导数为ND。   &lt;br&gt;
在之前认为a参数已知的反馈线性化的设计过程中，把a换为a的估计值，带入到u中。&lt;/p&gt;
&lt;p&gt;处理联合的李函数，通过设计a的估计使得难以负定的项为0。得到a估计的导的Hope值。 &lt;br&gt;
此时把a积分，再带回反馈系统线性化设计的u。设计完成。  &lt;br&gt;
（貌似这些设计的步骤都是通用的，都类似反步法的设计步骤）&lt;/p&gt;
&lt;p&gt;此时联合李函数是NSD的。&lt;strong&gt;不能说a估计和e趋近于0，只能说他们是稳定的。&lt;/strong&gt;  &lt;br&gt;
需要引入Lyapunov-like lemma。证明一下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/16.1.jpg&#34;
	width=&#34;2182&#34;
	height=&#34;3086&#34;
	srcset=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/16.1_hu5061890813754158188.jpg 480w, https://a233a2.github.io/p/drcan-learn-blog-advance/16.1_hu13324598345828524263.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;2&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;70&#34;
		data-flex-basis=&#34;169px&#34;
	
&gt; &lt;br&gt;
参考DrCan以及其他学员分享的Simulink设计，设计如下的系统。     &lt;br&gt;
&lt;img src=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/16.3.jpg&#34;
	width=&#34;1530&#34;
	height=&#34;891&#34;
	srcset=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/16.3_hu6765899608876502882.jpg 480w, https://a233a2.github.io/p/drcan-learn-blog-advance/16.3_hu5436791327526401788.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;2&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;171&#34;
		data-flex-basis=&#34;412px&#34;
	
&gt;  &lt;br&gt;
Xd改为变化量，a改为变化量。在k等于20的情况下跟踪性能也还行。&lt;/p&gt;
&lt;p&gt;k太小不行。k小的时候x根本无法完成跟踪。k必须很大才能很好的跟踪。
但是k太大的话会导致u变得十分的抽象，显然是难以实现u的输出 不符合实际工程的运用。  &lt;br&gt;
下图为k为20的跟踪情况，感觉已经非常不错了！     &lt;br&gt;
&lt;img src=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/16.4.png&#34;
	width=&#34;3200&#34;
	height=&#34;1769&#34;
	srcset=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/16.4_hu8220659023791264729.png 480w, https://a233a2.github.io/p/drcan-learn-blog-advance/16.4_hu2737523474660313422.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;k为20的跟踪情况&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;180&#34;
		data-flex-basis=&#34;434px&#34;
	
&gt; &lt;br&gt;
下图为k为20的输入u的情况。可以看到已经有点抽象了，幅度跨度很大。也可能是我这个系统的a变化幅度太大，以及目标值太过苛刻。不知道实际工程中的使用情况是如何的？      &lt;br&gt;
&lt;img src=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/16.5.png&#34;
	width=&#34;1191&#34;
	height=&#34;618&#34;
	srcset=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/16.5_hu1876342014172403373.png 480w, https://a233a2.github.io/p/drcan-learn-blog-advance/16.5_hu17529427337839311296.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;k为20的输入u的情况&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;192&#34;
		data-flex-basis=&#34;462px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;课后题：对经典弹簧系统进行非线性自适应控制器的设计
自己做的有点错误 &lt;br&gt;
标准答案如下图片 &lt;br&gt;
&lt;img src=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/16.2.jpg&#34;
	width=&#34;1220&#34;
	height=&#34;1461&#34;
	srcset=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/16.2_hu4954459544782785366.jpg 480w, https://a233a2.github.io/p/drcan-learn-blog-advance/16.2_hu14239506101412178476.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;2&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;83&#34;
		data-flex-basis=&#34;200px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;17-非线性鲁棒控制器&#34;&gt;17-非线性鲁棒控制器
&lt;/h3&gt;&lt;p&gt;鲁棒控制相关可以看山东科技大学的周克敏教授视频：https://space.bilibili.com/615075414&lt;/p&gt;
&lt;h4 id=&#34;17-1-滑膜控制器&#34;&gt;17-1 滑膜控制器
&lt;/h4&gt;&lt;p&gt;&lt;img src=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/17.1.jpg&#34;
	width=&#34;2182&#34;
	height=&#34;3086&#34;
	srcset=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/17.1_hu1499857284783875841.jpg 480w, https://a233a2.github.io/p/drcan-learn-blog-advance/17.1_hu9927858859803883763.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;2&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;70&#34;
		data-flex-basis=&#34;169px&#34;
	
&gt;&lt;br&gt;
这里滑模控制的形式就是使得 &lt;br&gt;
$$
u=ke+\dot{x}_d+\rho \frac{\left| e \right|}{e}
$$
&lt;strong&gt;而e的项是一个类似符号函数sgn(e)的东西。&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;而$\rho$是一个大于fx的绝对值的一个函数。&lt;/strong&gt; &lt;br&gt;
将u的形式代回到e导中，画出e和e导的状态图相轨迹。可以看到一个面-滑模面，系统状态就在这个面上趋近于0。  &lt;br&gt;
部分摘自：&lt;a class=&#34;link&#34; href=&#34;https://zhuanlan.zhihu.com/p/463230163&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;滑膜控制的简单理解-知乎&lt;/a&gt;   &lt;br&gt;
上图右侧是证明过程，在此用到了一个数学手法，对微分方程的不等式的证明，引入了一个松弛变量来变为等式。最终通过微分方程的通解的方式解出李函数在经过放缩，得出李函数小于某值。       &lt;br&gt;
&lt;strong&gt;接着将李函数反带回这个不等式&lt;/strong&gt;，直接解出e的状态是小于xx值的，最后得出这个状态e是指数渐进稳定的。这个证明手法确实巧妙。&lt;/p&gt;
&lt;h4 id=&#34;17-2-其他两种鲁棒控制-高增益高频&#34;&gt;17-2 其他两种鲁棒控制 高增益/高频
&lt;/h4&gt;&lt;p&gt;在Drcan的视频中解释鲁棒控制的u通式都是   &lt;br&gt;
$$
u=ke+\dot{x}&lt;em&gt;d+u&lt;/em&gt;{aux}
$$
$u_{aux}$是辅助用的。针对不同的鲁棒控制，仅仅是$u_{aux}$不同。  &lt;br&gt;
下图给出了其他两种鲁棒控制的$u_{aux}$形式。另外给出了证明过程。都是与滑膜的证明过程相似的过程。可以好好学习一下。 &lt;br&gt;
可以简单的理解 高增益控制方式就是使用足够大的输入去抵消不确定性。 &lt;br&gt;
而高频的控制方式就是滑膜的一种变式，通过设置参数使得其相较于滑模控制更为平和。  &lt;br&gt;
&lt;img src=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/17.2.jpg&#34;
	width=&#34;2182&#34;
	height=&#34;3086&#34;
	srcset=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/17.2_hu11561626687153324929.jpg 480w, https://a233a2.github.io/p/drcan-learn-blog-advance/17.2_hu16203061386306202606.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;2&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;70&#34;
		data-flex-basis=&#34;169px&#34;
	
&gt;  &lt;br&gt;
&lt;img src=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/17.3.jpg&#34;
	width=&#34;2182&#34;
	height=&#34;3086&#34;
	srcset=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/17.3_hu9117547256349787586.jpg 480w, https://a233a2.github.io/p/drcan-learn-blog-advance/17.3_hu7805912238490529829.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;2&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;70&#34;
		data-flex-basis=&#34;169px&#34;
	
&gt; &lt;br&gt;
以下是对三种控制方式进行建模分析。对滑膜控制分一个子系统，对其他两种分别不同的参数大小分别设置4个子系统如下图：  &lt;br&gt;
&lt;img src=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/17.4.jpg&#34;
	width=&#34;810&#34;
	height=&#34;671&#34;
	srcset=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/17.4_hu12348265309963556556.jpg 480w, https://a233a2.github.io/p/drcan-learn-blog-advance/17.4_hu7246052337841657702.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;2&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;120&#34;
		data-flex-basis=&#34;289px&#34;
	
&gt; &lt;br&gt;
运行结果： &lt;br&gt;
首先是四个系统的误差消除情况如下图：  &lt;br&gt;
&lt;img src=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/17.5.png&#34;
	width=&#34;3000&#34;
	height=&#34;1457&#34;
	srcset=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/17.5_hu1684519565462834997.png 480w, https://a233a2.github.io/p/drcan-learn-blog-advance/17.5_hu5328053693850226919.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;2&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;205&#34;
		data-flex-basis=&#34;494px&#34;
	
&gt; &lt;br&gt;
接着是四个系统的输入情况：  &lt;br&gt;
&lt;img src=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/17.6.png&#34;
	width=&#34;3000&#34;
	height=&#34;1457&#34;
	srcset=&#34;https://a233a2.github.io/p/drcan-learn-blog-advance/17.6_hu9185021091418649597.png 480w, https://a233a2.github.io/p/drcan-learn-blog-advance/17.6_hu1484279808355957790.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;2&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;205&#34;
		data-flex-basis=&#34;494px&#34;
	
&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>DRCAN-Learn-Blog-Basic</title>
        <link>https://a233a2.github.io/p/drcan-learn-blog-basic/</link>
        <pubDate>Wed, 23 Oct 2024 00:00:00 +0000</pubDate>
        
        <guid>https://a233a2.github.io/p/drcan-learn-blog-basic/</guid>
        <description>&lt;p&gt;此Blog记录了本人按照DRCAN视频推荐的学习顺序来系统学习DRCAN发表的控制相关视频。博客作为笔记使用。&lt;/p&gt;
&lt;h3 id=&#34;卷积定理&#34;&gt;卷积定理
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;卷积操作&lt;br&gt;
$$L[{f(t)*g(t)}]=F(s)​G(s)$$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;拉普拉斯变换&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;$$L{ f(t) } = F(s) = \int_0^{\infty} f(t) e^{-st} , dt$$&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;卷积定理（拉普拉斯域）&lt;br&gt;
卷积定理指出，在时间域中两个函数的卷积，在拉普拉斯变换后相当于它们的拉普拉斯变换的乘积。&lt;br&gt;
如果$f(t)$和$g(t)$的拉氏变换分别为$F(s)$和$G(s)$,那么：&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;$$ L[{f(t) ∗g(t)}] =F( s ) G( s) $$&lt;/p&gt;
&lt;p&gt;这意味着在时间域中复杂的卷积操作可以通过拉普拉斯变换简化为频域中的简单乘法。
这在处理线性时不变系统时非常有用，特别是当我们&lt;strong&gt;有系统的输入和系统的脉冲响应时，
利用卷积定理可以将输入信号和系统的响应进行频域分析。&lt;/strong&gt;&lt;br&gt;
数学证明：&lt;br&gt;
&lt;img src=&#34;https://a233a2.github.io/p/drcan-learn-blog-basic/%E5%8D%B7%E7%A7%AF%E5%AE%9A%E7%90%86%E6%95%B0%E5%AD%A6%E8%AF%81%E6%98%8E.jpg&#34;
	width=&#34;1079&#34;
	height=&#34;1527&#34;
	srcset=&#34;https://a233a2.github.io/p/drcan-learn-blog-basic/%E5%8D%B7%E7%A7%AF%E5%AE%9A%E7%90%86%E6%95%B0%E5%AD%A6%E8%AF%81%E6%98%8E_hu12515043388887547171.jpg 480w, https://a233a2.github.io/p/drcan-learn-blog-basic/%E5%8D%B7%E7%A7%AF%E5%AE%9A%E7%90%86%E6%95%B0%E5%AD%A6%E8%AF%81%E6%98%8E_hu3113174287893646857.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;设置1&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;70&#34;
		data-flex-basis=&#34;169px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;拉普拉斯变换&#34;&gt;拉普拉斯变换
&lt;/h3&gt;</description>
        </item>
        <item>
        <title>DRCAN-Learn-Blog-OPT</title>
        <link>https://a233a2.github.io/p/drcan-learn-blog-opt/</link>
        <pubDate>Wed, 23 Oct 2024 00:00:00 +0000</pubDate>
        
        <guid>https://a233a2.github.io/p/drcan-learn-blog-opt/</guid>
        <description>&lt;p&gt;此Blog记录了本人按照DRCAN视频推荐的学习顺序来系统学习DRCAN发表的控制相关视频。博客作为笔记使用。&lt;/p&gt;
&lt;h3 id=&#34;lqr&#34;&gt;LQR
&lt;/h3&gt;&lt;p&gt;线性二次型调节器，在Advance教程中有提及到。&lt;/p&gt;
&lt;h3 id=&#34;mpc&#34;&gt;MPC
&lt;/h3&gt;</description>
        </item>
        <item>
        <title>XTdrone仿真环境</title>
        <link>https://a233a2.github.io/p/xtdrone%E4%BB%BF%E7%9C%9F%E7%8E%AF%E5%A2%83/</link>
        <pubDate>Tue, 22 Oct 2024 00:00:00 +0000</pubDate>
        
        <guid>https://a233a2.github.io/p/xtdrone%E4%BB%BF%E7%9C%9F%E7%8E%AF%E5%A2%83/</guid>
        <description>&lt;img src="https://a233a2.github.io/p/xtdrone%E4%BB%BF%E7%9C%9F%E7%8E%AF%E5%A2%83/%E9%85%8D%E7%BD%AE%E5%A5%BD%E7%9A%84%E5%9B%BE.jpg" alt="Featured image of post XTdrone仿真环境" /&gt;&lt;h3 id=&#34;xtdrone仿真环境搭建&#34;&gt;XTdrone仿真环境搭建
&lt;/h3&gt;&lt;p&gt;使用了XTdrone推荐的自动配置，开发环境是Ubuntu 22.04&lt;br&gt;
下午时花了两个小时手动配置没配置好，弄这种大工程还是得新系统比较好一点。&lt;br&gt;
&lt;img src=&#34;https://a233a2.github.io/p/xtdrone%E4%BB%BF%E7%9C%9F%E7%8E%AF%E5%A2%83/%E9%85%8D%E7%BD%AE%E5%A5%BD%E7%9A%84%E5%9B%BE.jpg&#34;
	width=&#34;1920&#34;
	height=&#34;1080&#34;
	srcset=&#34;https://a233a2.github.io/p/xtdrone%E4%BB%BF%E7%9C%9F%E7%8E%AF%E5%A2%83/%E9%85%8D%E7%BD%AE%E5%A5%BD%E7%9A%84%E5%9B%BE_hu18099202995669554499.jpg 480w, https://a233a2.github.io/p/xtdrone%E4%BB%BF%E7%9C%9F%E7%8E%AF%E5%A2%83/%E9%85%8D%E7%BD%AE%E5%A5%BD%E7%9A%84%E5%9B%BE_hu2642333738181242516.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;111&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;177&#34;
		data-flex-basis=&#34;426px&#34;
	
&gt;&lt;br&gt;
另外作者太牛逼了&lt;br&gt;
&lt;a class=&#34;link&#34; href=&#34;https://www.yuque.com/xtdrone/manual_cn/install_scripts&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.yuque.com/xtdrone/manual_cn/install_scripts&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;后续使用引言&#34;&gt;后续使用引言
&lt;/h3&gt;&lt;p&gt;打算在其之上二次开发PX4的程序。XTdrone提供了风场生成的插件。但是如何在PX4原版代码上修改是一个大问题。  &lt;br&gt;
为了简化可以搭载机载电脑，然后运行ROS系统，在ROS系统上检测风场并进行稳态控制。这是一个方法。但是无疑会造成设备增多，复杂度增加。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>PX4二次开发以及仿真PX4-2</title>
        <link>https://a233a2.github.io/p/px4%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%E4%BB%A5%E5%8F%8A%E4%BB%BF%E7%9C%9Fpx4-2/</link>
        <pubDate>Thu, 10 Oct 2024 00:00:00 +0000</pubDate>
        
        <guid>https://a233a2.github.io/p/px4%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%E4%BB%A5%E5%8F%8A%E4%BB%BF%E7%9C%9Fpx4-2/</guid>
        <description>&lt;img src="https://a233a2.github.io/p/px4%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%E4%BB%A5%E5%8F%8A%E4%BB%BF%E7%9C%9Fpx4-2/fengmian.png" alt="Featured image of post PX4二次开发以及仿真PX4-2" /&gt;&lt;h3 id=&#34;px4在linux环境下的编译make&#34;&gt;PX4在Linux环境下的编译（make）
&lt;/h3&gt;&lt;p&gt;使用VM17虚拟机以及Ubuntu20.04对PX4项目进行编译。&lt;br&gt;
参考了超维空间科技的文章:&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/qq_38768959/article/details/106041494&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;超维空间科技的文章&lt;/a&gt; &lt;br&gt;
后续配置参考了Xtdrone仿真平台的一键配置，更为简单:&lt;a class=&#34;link&#34; href=&#34;https://www.yuque.com/xtdrone/manual_cn&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Xtdrone仿真平台文档&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;gazebo配合qgc地面站仿真&#34;&gt;Gazebo配合QGC地面站仿真
&lt;/h3&gt;&lt;h4 id=&#34;linux-qgc的安装&#34;&gt;Linux-QGC的安装：
&lt;/h4&gt;&lt;p&gt;QGC官网指导下进行配置，之后下载AppImage文件运行QGC地面站即可。 &lt;br&gt;
仿真中：&lt;br&gt;
&lt;img src=&#34;https://a233a2.github.io/p/px4%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%E4%BB%A5%E5%8F%8A%E4%BB%BF%E7%9C%9Fpx4-2/px4&amp;#43;gazebo.png&#34;
	width=&#34;2560&#34;
	height=&#34;1549&#34;
	srcset=&#34;https://a233a2.github.io/p/px4%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%E4%BB%A5%E5%8F%8A%E4%BB%BF%E7%9C%9Fpx4-2/px4&amp;#43;gazebo_hu16359290037193365331.png 480w, https://a233a2.github.io/p/px4%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%E4%BB%A5%E5%8F%8A%E4%BB%BF%E7%9C%9Fpx4-2/px4&amp;#43;gazebo_hu11163092954185164344.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;PX4工程文件1&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;165&#34;
		data-flex-basis=&#34;396px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;新建飞行任务antiwindtask&#34;&gt;新建飞行任务AntiWindTask
&lt;/h3&gt;&lt;p&gt;按照PX4官方指导文档新建自己的一个飞行任务 &lt;a class=&#34;link&#34; href=&#34;https://docs.px4.io/v1.14/en/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;官方新建任务指导&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最终参考了1.14版本的指导文件，一开始看的main指导文件去配置了XTdrone自动配置的1.13的PX4工程，发现在moduls文件下根本没有飞行任务配置。。。接着去使用1.15的PX4工程，但是在CMakeList文件中有所不同，在每一个版本中都有不同之处。1.15版本也会有bug存在。&lt;br&gt;
最后使用1.14版本，参考了1.14的指导文档，依然是CmakeList那里不对，文档中的放置位置在官方代码1.14.4版本中根本就没有。&lt;/p&gt;
&lt;p&gt;1.14.4版本中最后无奈我放到了一个差不多的位置。如下： &lt;br&gt;
&lt;img src=&#34;https://a233a2.github.io/p/px4%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%E4%BB%A5%E5%8F%8A%E4%BB%BF%E7%9C%9Fpx4-2/1.png&#34;
	width=&#34;595&#34;
	height=&#34;182&#34;
	srcset=&#34;https://a233a2.github.io/p/px4%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%E4%BB%A5%E5%8F%8A%E4%BB%BF%E7%9C%9Fpx4-2/1_hu18098538440630685739.png 480w, https://a233a2.github.io/p/px4%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%E4%BB%A5%E5%8F%8A%E4%BB%BF%E7%9C%9Fpx4-2/1_hu7742442885986621283.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;Error&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;326&#34;
		data-flex-basis=&#34;784px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;但是在进行FMU-V2构建烧录代码时也会一直出现bug如下，但是很奇怪使用PX4-SITL构建仿真时便没有错误出现，1.15也是如此： &lt;br&gt;
&lt;img src=&#34;https://a233a2.github.io/p/px4%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%E4%BB%A5%E5%8F%8A%E4%BB%BF%E7%9C%9Fpx4-2/2.png&#34;
	width=&#34;751&#34;
	height=&#34;507&#34;
	srcset=&#34;https://a233a2.github.io/p/px4%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%E4%BB%A5%E5%8F%8A%E4%BB%BF%E7%9C%9Fpx4-2/2_hu10717576958982321655.png 480w, https://a233a2.github.io/p/px4%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%E4%BB%A5%E5%8F%8A%E4%BB%BF%E7%9C%9Fpx4-2/2_hu8964904137106437533.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;1&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;148&#34;
		data-flex-basis=&#34;355px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;最后在github工程发表了issues，最终我更换了FMU-V3来构建，这个错误便消除了。最终成功执行了任务。在QGC地面站也可以正常识别。&lt;br&gt;
&lt;img src=&#34;https://a233a2.github.io/p/px4%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%E4%BB%A5%E5%8F%8A%E4%BB%BF%E7%9C%9Fpx4-2/AntiWind.png&#34;
	width=&#34;1117&#34;
	height=&#34;579&#34;
	srcset=&#34;https://a233a2.github.io/p/px4%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%E4%BB%A5%E5%8F%8A%E4%BB%BF%E7%9C%9Fpx4-2/AntiWind_hu8455000950526164640.png 480w, https://a233a2.github.io/p/px4%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%E4%BB%A5%E5%8F%8A%E4%BB%BF%E7%9C%9Fpx4-2/AntiWind_hu2756004170727178923.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;AntiWind&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;192&#34;
		data-flex-basis=&#34;463px&#34;
	
&gt;&lt;/p&gt;
&lt;h4 id=&#34;newflighttask分析&#34;&gt;NewFlightTask分析：
&lt;/h4&gt;&lt;p&gt;在指导文件中，其让我们修改了MPC_POS_MOD这个参数，很确定的是此参数决定了飞机在手动-Position定点飞行模式时要执行的实际代码中的任务模式。在源工程中有4中，但只能选择一种。 &lt;br&gt;
这也在侧面看出PX4的代码很庞大，实际运行只有那么一点。但是要真正简化这个系统也是很麻烦且没必要。&lt;br&gt;
指导文件默认的效果是控制台输出一段文字。然后实际飞机并不会升高。&lt;br&gt;
&lt;img src=&#34;https://a233a2.github.io/p/px4%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%E4%BB%A5%E5%8F%8A%E4%BB%BF%E7%9C%9Fpx4-2/%E9%A3%9E%E8%A1%8C%E6%A8%A1%E5%BC%8F%E6%9C%80%E5%88%9D%E4%BB%BF%E7%9C%9F%E6%95%88%E6%9E%9C.png&#34;
	width=&#34;1553&#34;
	height=&#34;977&#34;
	srcset=&#34;https://a233a2.github.io/p/px4%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%E4%BB%A5%E5%8F%8A%E4%BB%BF%E7%9C%9Fpx4-2/%E9%A3%9E%E8%A1%8C%E6%A8%A1%E5%BC%8F%E6%9C%80%E5%88%9D%E4%BB%BF%E7%9C%9F%E6%95%88%E6%9E%9C_hu16148123657284509088.png 480w, https://a233a2.github.io/p/px4%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%E4%BB%A5%E5%8F%8A%E4%BB%BF%E7%9C%9Fpx4-2/%E9%A3%9E%E8%A1%8C%E6%A8%A1%E5%BC%8F%E6%9C%80%E5%88%9D%E4%BB%BF%E7%9C%9F%E6%95%88%E6%9E%9C_hu15306114322350412902.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;飞行模式最初仿真效果&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;158&#34;
		data-flex-basis=&#34;381px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;manual-position飞行模式分析&#34;&gt;Manual-Position飞行模式分析
&lt;/h3&gt;&lt;p&gt;下面以Manual-Position飞行模式为例子对PX4原有的飞行模式进行分析，以便我们写出自己的飞行模式。 &lt;br&gt;
但是在飞行模式中，可以看出并没有PID相关的直接控制。在这些控制代码中，更多的是作为一种高级控制。分析摇杆输入等混合输入，来对SetPoint进行赋值，分发给更底层的PID控制机构。&lt;/p&gt;
&lt;h3 id=&#34;四旋翼数学模型推导&#34;&gt;四旋翼数学模型推导
&lt;/h3&gt;</description>
        </item>
        <item>
        <title>ADRC课程笔记</title>
        <link>https://a233a2.github.io/p/adrc%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/</link>
        <pubDate>Mon, 16 Sep 2024 00:00:00 +0000</pubDate>
        
        <guid>https://a233a2.github.io/p/adrc%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/</guid>
        <description>&lt;h3 id=&#34;adrc课程笔记&#34;&gt;ADRC课程笔记
&lt;/h3&gt;&lt;p&gt;本人对ADRC控制有着深厚的研究兴趣。在讨论研究韩京清先生的ADRC知识之前，我想先给不太专业的自己补习一些经典与现代控制理论方向的相关知识。&lt;/p&gt;
&lt;h4 id=&#34;生理前馈系统&#34;&gt;生理前馈系统
&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;在生理学上，前馈控制的例子是在实际体力活动之前，自主神经系统对心跳的正常预期调节。前馈控制可以比作对已知线索的预期反应（预测编码）。心跳的反馈调节为机体提供了进一步对运动的适应性。  &amp;ndash;wiki百科&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在前馈系统中，控制变量的调整不是以目标和回授之间的误差为基础，它是以过程&lt;strong&gt;数学模型&lt;/strong&gt;的知识和&lt;strong&gt;过程扰动&lt;/strong&gt;的知识或测量为基础。&lt;/p&gt;
&lt;p&gt;所以对于数学模型的整体掌握是对系统扰动进行前馈消除的前提。&lt;/p&gt;
&lt;p&gt;正所谓要想系统稳得住，必须得有前馈引入。前馈控制在某些控制场合下是必须项。&lt;/p&gt;
&lt;h3 id=&#34;前馈控制&#34;&gt;前馈控制
&lt;/h3&gt;&lt;h6 id=&#34;摘自高志强-自抗扰控制思想探究&#34;&gt;摘自《高志强: 自抗扰控制思想探究》
&lt;/h6&gt;&lt;p&gt;前馈控制是一种&lt;strong&gt;基于对扰动的预测&lt;/strong&gt;进行补偿的控制方法。它通过&lt;strong&gt;测量&lt;/strong&gt;可能影响系统输出的扰动变量，并根据扰动变量与系统输出之间的关系，计算出所需的控制量，在&lt;strong&gt;扰动对系统产生影响之前&lt;/strong&gt;就进行调节，以抵消扰动的影响。&lt;br&gt;
在自动控制系统理论中学习过，由传递函数理论数学推导，前馈的引入可以完全的消除系统的扰动误差。现在这显然并不是这么的简单，这需要对系统数学模型有着十分精确的掌握。&lt;br&gt;
前馈控制在工业界用途广泛, 但是学术界对它很少关心, 认为是开环控制, 没有什么理论可言. 前馈的使用方式主要有两种: 一种是&lt;strong&gt;根据参考输入和对象模型的逆&lt;/strong&gt;而得到的控制量, 不依赖对象的实时信息,暂且称之为A类前馈; 另外一种前馈, 是&lt;strong&gt;根据被控量之外的对象信息&lt;/strong&gt;所产生的控制量, 即B类前馈。&lt;br&gt;
前馈控制提出的本意是要区别于上面提到的狭义的反馈控制, 表示控制量的一部分甚至全部都可以完全独立于被控量的量测. Black定义的反馈(feedback)本来就是针对前馈(feedforward)而言的, 表示信号流向反转, 由输出到输入. 这里信号的走向一正一反, 概念很清楚。&lt;br&gt;
可是当反馈这个通讯工程的概念被借用到控制工程时, 它的反义词前馈的含义便有了两种解释. 比如上面说的A类前馈明显是开环控制, 控制量完全独立于对象的实时信息. 可是B类前馈则不然, 它依赖的还是对象信息, 实际上是前面提到的广义反馈, 只不过反馈的不是输出量而已. B类前馈在文献中也被称为扰动前馈, 它是基于对象扰动信息的实时提取, 就像指南车. 可是同样是基于对象信息的提取, 指南车为什么会被称为开环控制呢？其实B类前馈属于广义反馈, 不应称其为前馈或开环控制. 鉴于前馈的概念和用法前后重叠, 为了概念的清晰, 建议今后可把B类前馈归入抗扰原理讨论; 把前馈狭义地定义为A类前馈.那么这样的前馈有什么意义呢？为什么它的用途这么广呢？主要原因是它降低了快速跟踪的成本。&lt;br&gt;
一个控制系统要使输出迅速跟踪给定值有两个途径: 1) 高带宽; 2) 前馈. 但是在工业上, 带宽就是成本.高带宽虽然能使跟踪速度提高, 但也带来很多问题:1) 对执行机构的品质要求提高; 2) 激励了对象的高频动态使控制问题复杂化; 3) 闭环系统的稳定裕度下降,对相位滞后和时间延迟更敏感; 4) 对传感器噪声更敏感, 等等.高带宽的成本在20世 50年代就有专门、详细的讨论, 比如文献[46], 但是至今没能在理论界引起重视, 乃至高增益控制器、观测器的文章比比皆是, 而能用上的却寥寥无几. 这反映了不考虑成本的研究, 在工程上是没有多少意义的。&lt;br&gt;
工程师们在实践中基于对系统物理特性的知识发现了前馈这个办法. 这种独立于反馈回路拟合出的控制量通常是结合参考输入, 以数据或图表形式表示的,常常在控制信号中占主要部分. 同时也使用PID反馈控制器, 发挥微调、纠错的作用. 因此, 工业上的PID控制器常常是与前馈控制结合使用的。&lt;br&gt;
以上总结的是控制论的基本原理, 是从事自动控制的人们在长期的工程实践中发现、挖掘出来的, 是控制论继续发展的基石. 要系统地、科学地建立和发展一套完整的理论体系, 就需要对基本原理进行提炼、抽象和升华, 使得工程控制的实践能够更加系统,并不断进入更高的层次, 从而“下学而上达”。&lt;/p&gt;
&lt;h3 id=&#34;状态观测器&#34;&gt;状态观测器
&lt;/h3&gt;&lt;h3 id=&#34;扩张状态观测器&#34;&gt;扩张状态观测器
&lt;/h3&gt;</description>
        </item>
        <item>
        <title>YSYX学习日记</title>
        <link>https://a233a2.github.io/p/ysyx%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/</link>
        <pubDate>Mon, 16 Sep 2024 00:00:00 +0000</pubDate>
        
        <guid>https://a233a2.github.io/p/ysyx%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0/</guid>
        <description>&lt;h3 id=&#34;ysyx学习日记&#34;&gt;YSYX学习日记
&lt;/h3&gt;&lt;p&gt;学习记录： &lt;a class=&#34;link&#34; href=&#34;https://docs.qq.com/sheet/DQ0lRY2tNb2VIZWVB?newPad=1&amp;amp;newPadType=clone&amp;amp;tab=BB08J4&amp;amp;_t=1728471922939&amp;amp;u=555637143d844e0f8b3d1a7c9c34bebf&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;学习记录&lt;/a&gt;。&lt;/p&gt;
&lt;h4 id=&#34;ubuntu安装&#34;&gt;Ubuntu安装
&lt;/h4&gt;&lt;p&gt;测试赛&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
