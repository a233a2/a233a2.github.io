<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Math on sunjiyi&#39;s Blogggg</title>
        <link>https://a233a2.github.io/tags/math/</link>
        <description>Recent content in Math on sunjiyi&#39;s Blogggg</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <copyright>Sunjiyi Make and Design</copyright>
        <lastBuildDate>Fri, 08 Nov 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://a233a2.github.io/tags/math/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>算法挖坑填坑</title>
        <link>https://a233a2.github.io/p/%E7%AE%97%E6%B3%95%E6%8C%96%E5%9D%91%E5%A1%AB%E5%9D%91/</link>
        <pubDate>Fri, 08 Nov 2024 00:00:00 +0000</pubDate>
        
        <guid>https://a233a2.github.io/p/%E7%AE%97%E6%B3%95%E6%8C%96%E5%9D%91%E5%A1%AB%E5%9D%91/</guid>
        <description>&lt;h3 id=&#34;反步法&#34;&gt;反步法
&lt;/h3&gt;&lt;p&gt;本质上也是利用&lt;strong&gt;李雅普诺夫第二方法&lt;/strong&gt;对系统的控制器进行状态反馈设计。通过对系统的每一个状态方程依次进行迭代设计，最终串联成一个控制方案。 &lt;br&gt;
反步法(Backsteping method)又称为后推法，是一种由前往后递推的设计方法，该方法所对应的系统是通过串联形成的非线性系统，最初由科克托维奇(Kokotovic)于1991年提出，该方法的提出最初是用于线性系统，随着研究的深入发现它针对非线性系统也有很好的控制。    &lt;br&gt;
它的设计思想是将复杂的系统分解成若干个不超过原系统阶数的子系统，然后根据Lyapunov稳定性定理，针对每个子系统设计出中间的虚拟控制量，一直“反推”至整个系统，从而设计出系统的总控制律。&lt;/p&gt;
&lt;h4 id=&#34;简单的二阶非线性系统&#34;&gt;简单的二阶非线性系统
&lt;/h4&gt;&lt;p&gt;对于一个简单的二阶非线性系统：   &lt;br&gt;
&lt;img src=&#34;https://a233a2.github.io/p/%E7%AE%97%E6%B3%95%E6%8C%96%E5%9D%91%E5%A1%AB%E5%9D%91/%E5%8F%8D%E6%AD%A5%E6%B3%951.bmp&#34;
	width=&#34;314&#34;
	height=&#34;140&#34;
	srcset=&#34;https://a233a2.github.io/p/%E7%AE%97%E6%B3%95%E6%8C%96%E5%9D%91%E5%A1%AB%E5%9D%91/%E5%8F%8D%E6%AD%A5%E6%B3%951_hu11078211995131865912.bmp 480w, https://a233a2.github.io/p/%E7%AE%97%E6%B3%95%E6%8C%96%E5%9D%91%E5%A1%AB%E5%9D%91/%E5%8F%8D%E6%AD%A5%E6%B3%951_hu14187467472633476988.bmp 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;反步法1&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;224&#34;
		data-flex-basis=&#34;538px&#34;
	
&gt; &lt;br&gt;
$$ &lt;br&gt;
{\begin{array}{l}
\dot{x}_1=f(x_1) +g( x_1 ) x_2\
\dot{x}_2=u\
\end{array}
$$ &lt;br&gt;
控制目标：使系统控制到原点处。（如果要控制在别的地方，先进行方程的坐标变换到原点即可）&lt;/p&gt;
&lt;p&gt;对于二阶系统的反步法，我们对两个方程分别分两步设计进行：
第一步，对第一个方程，将$x_2$看作输入。设计一个反馈控制率$x_2=\phi \left( x_1 \right)$ ，使得第一个方程稳定； &lt;br&gt;
第二步，对第二个方程，将$u$看做输入，设计一个反馈控制率，使得第二个方程也稳定；&lt;br&gt;
最后，得到的最终反馈控制率$u$，可以使得整个系统稳定。&lt;/p&gt;
&lt;h5 id=&#34;step1-设计x2使得x1稳定&#34;&gt;Step1 设计X2使得X1稳定
&lt;/h5&gt;&lt;p&gt;$$
\varphi = 1+\frac{1} {1+\frac{1} {1+\frac{1} {1+\cdots} } }
$$&lt;/p&gt;
&lt;h3 id=&#34;卡尔曼滤波算法&#34;&gt;卡尔曼滤波算法
&lt;/h3&gt;&lt;h3 id=&#34;扩展卡尔曼滤波算法ekf&#34;&gt;扩展卡尔曼滤波算法（EKF）
&lt;/h3&gt;&lt;h3 id=&#34;傅里叶变换&#34;&gt;傅里叶变换
&lt;/h3&gt;&lt;h3 id=&#34;快速傅里叶变换法&#34;&gt;快速傅里叶变换法
&lt;/h3&gt;&lt;h3 id=&#34;滑膜算法&#34;&gt;滑膜算法
&lt;/h3&gt;&lt;h3 id=&#34;模糊pid算法&#34;&gt;模糊PID算法
&lt;/h3&gt;</description>
        </item>
        <item>
        <title>工程数学基础</title>
        <link>https://a233a2.github.io/p/%E5%B7%A5%E7%A8%8B%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/</link>
        <pubDate>Thu, 24 Oct 2024 00:00:00 +0000</pubDate>
        
        <guid>https://a233a2.github.io/p/%E5%B7%A5%E7%A8%8B%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/</guid>
        <description>&lt;h2 id=&#34;一些概念&#34;&gt;一些概念
&lt;/h2&gt;&lt;h3 id=&#34;范数&#34;&gt;范数
&lt;/h3&gt;&lt;h3 id=&#34;高斯函数&#34;&gt;高斯函数
&lt;/h3&gt;&lt;h3 id=&#34;最小二乘法&#34;&gt;最小二乘法
&lt;/h3&gt;&lt;h3 id=&#34;最小二乘-矩阵形式推导&#34;&gt;最小二乘-矩阵形式推导
&lt;/h3&gt;</description>
        </item>
        
    </channel>
</rss>
